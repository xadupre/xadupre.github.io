
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>VBuffer Care and Feeding &#8212; Custom Extensions to ML.net 0.8.0 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="https://unpkg.com/font-awesome@4.5.0/css/font-awesome.min.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script type="text/javascript" src="https://unpkg.com/@jupyter-widgets/html-manager@^0.14.0/dist/embed-amd.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="MVP Spec" href="mvp.html" />
    <link rel="prev" title="Schema comprehension in ML.NET" href="schemacomprehension.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="vbuffer-care-and-feeding">
<span id="vbuffer-care-and-feeding"></span><h1><code class="docutils literal notranslate"><span class="pre">VBuffer</span></code> Care and Feeding<a class="headerlink" href="#vbuffer-care-and-feeding" title="Permalink to this headline">¶</a></h1>
<p>The <code class="docutils literal notranslate"><span class="pre">VBuffer</span></code> is ML.NET’s central vector type, used throughout our data
pipeline and many other places to represent vectors of values. For example,
nearly all trainers accept feature vectors as <code class="docutils literal notranslate"><span class="pre">VBuffer&lt;float&gt;</span></code>.</p>
<div class="section" id="technical-vbuffers">
<span id="technical-vbuffers"></span><h2>Technical <code class="docutils literal notranslate"><span class="pre">VBuffers</span></code><a class="headerlink" href="#technical-vbuffers" title="Permalink to this headline">¶</a></h2>
<p>A <code class="docutils literal notranslate"><span class="pre">VBuffer&lt;T&gt;</span></code> is a generic type that supports both dense and sparse vectors
over items of type <code class="docutils literal notranslate"><span class="pre">T</span></code>. This is the representation type for all
<a class="reference external" href="IDataViewTypeSystem.md#vector-representations"><code class="docutils literal notranslate"><span class="pre">VectorType</span></code></a> instances in the
<code class="docutils literal notranslate"><span class="pre">IDataView</span></code> ecosystem. When an instance of this is passed to a row cursor
getter, the callee is free to take ownership of and re-use the arrays
(<code class="docutils literal notranslate"><span class="pre">Values</span></code> and <code class="docutils literal notranslate"><span class="pre">Indices</span></code>).</p>
<p>A <code class="docutils literal notranslate"><span class="pre">VBuffer&lt;T&gt;</span></code> is a struct, and has the following <code class="docutils literal notranslate"><span class="pre">readonly</span></code> fields:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">Length</span></code>: The logical length of the buffer.</li>
<li><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">Count</span></code>: The number of items explicitly represented. This equals <code class="docutils literal notranslate"><span class="pre">Length</span></code>
when the representation is dense and is less than <code class="docutils literal notranslate"><span class="pre">Length</span></code> when sparse.</li>
<li><code class="docutils literal notranslate"><span class="pre">T[]</span> <span class="pre">Values</span></code>: The values. Only the first <code class="docutils literal notranslate"><span class="pre">Count</span></code> of these are valid.</li>
<li><code class="docutils literal notranslate"><span class="pre">int[]</span> <span class="pre">Indices</span></code>: The indices. For a dense representation, this array is not
used, and may be <code class="docutils literal notranslate"><span class="pre">null</span></code>. For a sparse representation it is parallel to
values and specifies the logical indices for the corresponding values. Only
the first <code class="docutils literal notranslate"><span class="pre">Count</span></code> of these are valid.</li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">Values</span></code> must have length equal to at least <code class="docutils literal notranslate"><span class="pre">Count</span></code>. If the representation is
sparse, that is, <code class="docutils literal notranslate"><span class="pre">Count</span> <span class="pre">&lt;</span> <span class="pre">Length</span></code>, then <code class="docutils literal notranslate"><span class="pre">Indices</span></code> must have length also
greater than or equal to <code class="docutils literal notranslate"><span class="pre">Count</span></code>. If <code class="docutils literal notranslate"><span class="pre">Count</span> <span class="pre">==</span> <span class="pre">0</span></code>, then it is entirely legal
for <code class="docutils literal notranslate"><span class="pre">Values</span></code> or <code class="docutils literal notranslate"><span class="pre">Indices</span></code> to be <code class="docutils literal notranslate"><span class="pre">null</span></code>, and if dense then <code class="docutils literal notranslate"><span class="pre">Indices</span></code> can always
be <code class="docutils literal notranslate"><span class="pre">null</span></code>.</p>
<p>On the subject of <code class="docutils literal notranslate"><span class="pre">Count</span> <span class="pre">==</span> <span class="pre">0</span></code>, note that having no valid values in <code class="docutils literal notranslate"><span class="pre">Indices</span></code>
and <code class="docutils literal notranslate"><span class="pre">Values</span></code> merely means that no values are explicitly defined, and the
vector should be treated, logically, as being filled with <code class="docutils literal notranslate"><span class="pre">default(T)</span></code>.</p>
<p>For sparse vectors, <code class="docutils literal notranslate"><span class="pre">Indices</span></code> must have length equal to at least <code class="docutils literal notranslate"><span class="pre">Count</span></code>, and
the first <code class="docutils literal notranslate"><span class="pre">Count</span></code> indices must be increasing, with all indices between <code class="docutils literal notranslate"><span class="pre">0</span></code>
inclusive and <code class="docutils literal notranslate"><span class="pre">Length</span></code> exclusive.</p>
<p>Regarding the generic type parameter <code class="docutils literal notranslate"><span class="pre">T</span></code>, the only real assumption made about
this type is that assignment (that is, using <code class="docutils literal notranslate"><span class="pre">=</span></code>) is sufficient to create an
<em>independent</em> copy of that item. All representation types of the <a class="reference external" href="IDataViewTypeSystem.md#standard-column-types">primitive
types</a> have this property (for example,
<code class="docutils literal notranslate"><span class="pre">DvText</span></code>, <code class="docutils literal notranslate"><span class="pre">DvInt4</span></code>, <code class="docutils literal notranslate"><span class="pre">Single</span></code>, <code class="docutils literal notranslate"><span class="pre">Double</span></code>, etc.), but for example, <code class="docutils literal notranslate"><span class="pre">VBuffer&lt;&gt;</span></code>
itself does not have this property. So, no <code class="docutils literal notranslate"><span class="pre">VBuffer</span></code> of <code class="docutils literal notranslate"><span class="pre">VBuffer</span></code>s for you.</p>
</div>
<div class="section" id="sparse-values-as-default-t">
<span id="sparse-values-as-default-t"></span><h2>Sparse Values as <code class="docutils literal notranslate"><span class="pre">default(T)</span></code><a class="headerlink" href="#sparse-values-as-default-t" title="Permalink to this headline">¶</a></h2>
<p>Any implicit value in a sparse <code class="docutils literal notranslate"><span class="pre">VBuffer&lt;T&gt;</span></code> <strong>must</strong> logically be treated as
though it has value <code class="docutils literal notranslate"><span class="pre">default(T)</span></code>. For example, suppose we have the following
two declarations:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">a</span> <span class="p">=</span> <span class="k">new</span> <span class="n">VBuffer</span><span class="p">&lt;</span><span class="kt">float</span><span class="p">&gt;(</span><span class="m">5</span><span class="p">,</span> <span class="k">new</span> <span class="kt">float</span><span class="p">[]</span> <span class="p">{</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">2</span> <span class="p">});</span>
<span class="kt">var</span> <span class="n">b</span> <span class="p">=</span> <span class="k">new</span> <span class="n">VBuffer</span><span class="p">&lt;</span><span class="kt">float</span><span class="p">&gt;(</span><span class="m">5</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="k">new</span> <span class="kt">float</span><span class="p">[]</span> <span class="p">{</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span> <span class="p">},</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[]</span> <span class="p">{</span> <span class="m">1</span><span class="p">,</span> <span class="m">4</span> <span class="p">});</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">a</span></code> is dense, and <code class="docutils literal notranslate"><span class="pre">b</span></code> is sparse. However, any operations over either
must treat the logical indices <code class="docutils literal notranslate"><span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">2</span></code>, and <code class="docutils literal notranslate"><span class="pre">3</span></code> as if they have value <code class="docutils literal notranslate"><span class="pre">0.0f</span></code>.
The two should be equivalent!</p>
<p>ML.NET throughout its codebase assumes in many places that sparse and dense
representations are interchangeable: if it is more efficient to consider
something sparse or dense, the code will have no qualms about making that
conversion. This does mean though, that we depend upon all code that deals
with <code class="docutils literal notranslate"><span class="pre">VBuffer</span></code> responding in the same fashion, and respecting this convention.</p>
<p>As a corollary to the above note about equivalence of sparse and dense
representations, since they are equivalent it follows that any code consuming
<code class="docutils literal notranslate"><span class="pre">VBuffer</span></code>s must work equally well with <em>both</em>. That is, there must never be a
condition where data is read and assumed to be either sparse, or dense, since
implementers of <code class="docutils literal notranslate"><span class="pre">IDataView</span></code> and related interfaces are perfectly free to
produce either.</p>
<p>The only “exception” to this rule is a necessary acknowledgment of the reality
of floating point mathematics: sometimes due to the way the JIT will optimize
code one code path or another, and due to the fact that floating point math is
not commutative, operations over sparse <code class="docutils literal notranslate"><span class="pre">VBuffer&lt;float&gt;</span></code> or <code class="docutils literal notranslate"><span class="pre">VBuffer&lt;double&gt;</span></code>
vectors can sometimes result in modestly different results than the “same”
operation over dense values.</p>
</div>
<div class="section" id="why-buffer-reuse">
<span id="why-buffer-reuse"></span><h2>Why Buffer Reuse<a class="headerlink" href="#why-buffer-reuse" title="Permalink to this headline">¶</a></h2>
<p>The question is often asked by people new to this codebase: why bother with
buffer reuse at all? Without going into too many details, we used to not and
suffered for it. We had a far simpler system where examples were yielded
through an
<a class="reference external" href="https://msdn.microsoft.com/en-us/library/9eekhta0.aspx"><code class="docutils literal notranslate"><span class="pre">IEnumerable&lt;&gt;</span></code></a>, and
our vector type at the time had <code class="docutils literal notranslate"><span class="pre">Indices</span></code> and <code class="docutils literal notranslate"><span class="pre">Values</span></code> arrays as well, but
their sizes were there actual sizes, and being returned through an
<code class="docutils literal notranslate"><span class="pre">IEnumerable&lt;&gt;</span></code> there was no plausible way to “recycle” the buffers.</p>
<p>Also: who “owned” a fetched example (the caller, or callee) was not clear.
Because it was not clear, code was inevitably written and checked in that made
<em>either</em> assumption, which meant, ultimately, that everything that touched
these would try to duplicate everything by default, because doing anything
else would fail in some case.</p>
<p>The reason why this becomes important is because <a class="reference external" href="https://msdn.microsoft.com/en-us/library/0xy59wtx.aspx">garbage
collection</a> in the
.NET framework is not free. Creating and destroying these arrays <em>can</em> be
cheap, provided that they are sufficiently small, short lived, and only ever
exist in a single thread. But, violate any of these, there is a possibility
these arrays could be allocated on the large object heap, or promoted to gen-2
collection. The results could be disastrous: in one particularly memorable
incident regarding neural net training, the move to <code class="docutils literal notranslate"><span class="pre">IDataView</span></code> and its
<code class="docutils literal notranslate"><span class="pre">VBuffer</span></code>s resulted in a more than tenfold decrease in runtime performance,
because under the old regime the garbage collection of the feature vectors was
just taking so much time.</p>
<p>This is somewhat unfortunate: a joke-that’s-not-really-a-joke on the team was
that we were writing C# as though it were C code. Be that as it may, buffer
reuse is essential to our performance, especially on larger problems.</p>
<p>This design requirement of buffer reuse has deeper implications for the
ecosystem merely than the type here. For example, it is one crucial reason why
so many value accessors in the <code class="docutils literal notranslate"><span class="pre">IDataView</span></code> ecosystem fill in values passed in
through a <code class="docutils literal notranslate"><span class="pre">ref</span></code> parameter, rather than, say, being a return value.</p>
</div>
<div class="section" id="buffer-re-use-as-a-user">
<span id="buffer-re-use-as-a-user"></span><h2>Buffer Re-use as a User<a class="headerlink" href="#buffer-re-use-as-a-user" title="Permalink to this headline">¶</a></h2>
<p>Let’s imagine we have an <code class="docutils literal notranslate"><span class="pre">IDataView</span></code> in a variable <code class="docutils literal notranslate"><span class="pre">dataview</span></code>, and we just so
happen to know that the column with index 5 has representation type
<code class="docutils literal notranslate"><span class="pre">VBuffer&lt;float&gt;</span></code>. (In real code, this would presumably we achieved through
more complicated involving an inspection of <code class="docutils literal notranslate"><span class="pre">dataview.Schema</span></code>, but we omit
such details here.)</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="p">(</span><span class="n">IRowCursor</span> <span class="n">cursor</span> <span class="p">=</span> <span class="n">dataview</span><span class="p">.</span><span class="n">GetRowCursor</span><span class="p">(</span><span class="n">col</span> <span class="p">=&gt;</span> <span class="n">col</span> <span class="p">==</span> <span class="m">5</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">ValueGetter</span><span class="p">&lt;</span><span class="n">VBuffer</span><span class="p">&lt;</span><span class="kt">float</span><span class="p">&gt;&gt;</span> <span class="n">getter</span> <span class="p">=</span> <span class="n">cursor</span><span class="p">.</span><span class="n">GetGetter</span><span class="p">&lt;</span><span class="n">VBuffer</span><span class="p">&lt;</span><span class="kt">float</span><span class="p">&gt;&gt;(</span><span class="m">5</span><span class="p">);</span>
    <span class="kt">var</span> <span class="k">value</span> <span class="p">=</span> <span class="k">default</span><span class="p">(</span><span class="n">VBuffer</span><span class="p">&lt;</span><span class="kt">float</span><span class="p">&gt;);</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">cursor</span><span class="p">.</span><span class="n">MoveNext</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">getter</span><span class="p">(</span><span class="k">ref</span> <span class="k">value</span><span class="p">);</span>
        <span class="c1">// Presumably something else is done with value.</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this example, we open a cursor (telling it to make only column 5 active),
then get the “getter” over this column. What enables buffer re-use for this is
that, as we go row by row over the data with the <code class="docutils literal notranslate"><span class="pre">while</span></code> loop, we pass in the
same <code class="docutils literal notranslate"><span class="pre">value</span></code> variable in to the <code class="docutils literal notranslate"><span class="pre">getter</span></code> delegate, again and again. Presumably
the first time, or several, memory is allocated. Initially <code class="docutils literal notranslate"><span class="pre">value</span> <span class="pre">=</span> <span class="pre">default(VBuffer&lt;float&gt;)</span></code>, that is, it has zero <code class="docutils literal notranslate"><span class="pre">Length</span></code> and <code class="docutils literal notranslate"><span class="pre">Count</span></code> and <code class="docutils literal notranslate"><span class="pre">null</span></code>
<code class="docutils literal notranslate"><span class="pre">Indices</span></code> and <code class="docutils literal notranslate"><span class="pre">Values</span></code>. Presumably at some point, probably the first call,
<code class="docutils literal notranslate"><span class="pre">value</span></code> is replaced with a <code class="docutils literal notranslate"><span class="pre">VBuffer&lt;float&gt;</span></code> that has actual values allocated.
In subsequent calls, perhaps these are judged as insufficiently large, and new
arrays are allocated, but we would expect at some point the arrays would
become “large enough” to accommodate many values, so reallocations would
become increasingly rare.</p>
<p>A common mistake made by first time users is to do something like move the
<code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">value</span></code> declaration inside the <code class="docutils literal notranslate"><span class="pre">while</span></code> loop, thus dooming <code class="docutils literal notranslate"><span class="pre">getter</span></code> to have
to allocate the arrays every single time, completely defeating the purpose of
buffer reuse.</p>
</div>
<div class="section" id="buffer-re-use-as-a-developer">
<span id="buffer-re-use-as-a-developer"></span><h2>Buffer Re-use as a Developer<a class="headerlink" href="#buffer-re-use-as-a-developer" title="Permalink to this headline">¶</a></h2>
<p>Nearly all methods in ML.NET that “return” a <code class="docutils literal notranslate"><span class="pre">VBuffer&lt;T&gt;</span></code> do not really return
a <code class="docutils literal notranslate"><span class="pre">VBuffer&lt;T&gt;</span></code> <em>at all</em>, but instead have a parameter <code class="docutils literal notranslate"><span class="pre">ref</span> <span class="pre">VBuffer&lt;T&gt;</span> <span class="pre">dst</span></code>,
where they are expected to put the result. See the above example, with the
<code class="docutils literal notranslate"><span class="pre">getter</span></code>. A <code class="docutils literal notranslate"><span class="pre">ValueGetter</span></code> is defined:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">delegate</span> <span class="k">void</span> <span class="n">ValueGetter</span><span class="p">&lt;</span><span class="n">TValue</span><span class="p">&gt;(</span><span class="k">ref</span> <span class="n">TValue</span> <span class="k">value</span><span class="p">);</span>
</pre></div>
</div>
<p>Let’s describe the typical practice of “returning” a <code class="docutils literal notranslate"><span class="pre">VBuffer</span></code> in, say, a
<code class="docutils literal notranslate"><span class="pre">ref</span></code> parameter named <code class="docutils literal notranslate"><span class="pre">dst</span></code>: if <code class="docutils literal notranslate"><span class="pre">dst.Indices</span></code> and <code class="docutils literal notranslate"><span class="pre">dst.Values</span></code> are
sufficiently large to contain the result, they are used, and the value is
calculated, or sometimes copied, into them. If either is insufficiently large,
then a new array is allocated in its place. After all the calculation happens,
a <em>new</em> <code class="docutils literal notranslate"><span class="pre">VBuffer</span></code> is constructed and assigned to <code class="docutils literal notranslate"><span class="pre">dst</span></code>. (And possibly, if they
were large enough, using the same <code class="docutils literal notranslate"><span class="pre">Indices</span></code> and <code class="docutils literal notranslate"><span class="pre">Values</span></code> arrays as were passed
in, albeit with different values.)</p>
<p><code class="docutils literal notranslate"><span class="pre">VBuffer</span></code>s can be either sparse or dense. However, even when returning a dense
<code class="docutils literal notranslate"><span class="pre">VBuffer</span></code>, you would not discard the <code class="docutils literal notranslate"><span class="pre">Indices</span></code> array of the passed in buffer,
assuming there was one. The <code class="docutils literal notranslate"><span class="pre">Indices</span></code> array was merely larger than necessary
to store <em>this</em> result: that you happened to not need it this call does not
justify throwing it away. We don’t care about buffer re-use just for a single
call, after all! The dense constructor for the <code class="docutils literal notranslate"><span class="pre">VBuffer</span></code> accepts an <code class="docutils literal notranslate"><span class="pre">Indices</span></code>
array for precisely this reason!</p>
<p>Also note: when you return a <code class="docutils literal notranslate"><span class="pre">VBuffer</span></code> in this fashion, the caller is assumed
to <em>own</em> it at that point. This means they can do whatever they like to it,
like pass the same variable into some other getter, or modify its values.
Indeed, this is quite common: normalizers in ML.NET get values from their
source, then immediately scale the contents of <code class="docutils literal notranslate"><span class="pre">Values</span></code> appropriately. This
would hardly be possible if the callee was considered to have some stake in
that result.</p>
<p>There is a corollary on this point: because the caller owns any <code class="docutils literal notranslate"><span class="pre">VBuffer</span></code>,
then you shouldn’t do anything that irrevocably destroys their usefulness to
the caller. For example, consider this method that takes a vector <code class="docutils literal notranslate"><span class="pre">src</span></code>, and
stores the scaled result in <code class="docutils literal notranslate"><span class="pre">dst</span></code>.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">VectorUtils</span><span class="p">.</span><span class="n">ScaleBy</span><span class="p">(</span><span class="k">ref</span> <span class="n">VBuffer</span><span class="p">&lt;</span><span class="kt">float</span><span class="p">&gt;</span> <span class="n">src</span><span class="p">,</span> <span class="k">ref</span> <span class="n">VBuffer</span><span class="p">&lt;</span><span class="kt">float</span><span class="p">&gt;</span> <span class="n">dst</span><span class="p">,</span> <span class="kt">float</span> <span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
<p>What this does is, copy the values from <code class="docutils literal notranslate"><span class="pre">src</span></code> to <code class="docutils literal notranslate"><span class="pre">dst</span></code>, while scaling each
value seen by <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
<p>One possible alternate (wrong) implementation of this would be to just say
<code class="docutils literal notranslate"><span class="pre">dst=src</span></code> then scale all contents of <code class="docutils literal notranslate"><span class="pre">dst.Values</span></code> by <code class="docutils literal notranslate"><span class="pre">c</span></code>. But, then <code class="docutils literal notranslate"><span class="pre">dst</span></code> and
<code class="docutils literal notranslate"><span class="pre">src</span></code> would share references to their internal arrays, completely compromising
the caller’s ability to do anything useful with them: if the caller were to
pass <code class="docutils literal notranslate"><span class="pre">dst</span></code> into some other method that modified it, this could easily
(silently!) modify the contents of <code class="docutils literal notranslate"><span class="pre">src</span></code>. The point is: if you are writing
code <em>anywhere</em> whose end result is that two distinct <code class="docutils literal notranslate"><span class="pre">VBuffer</span></code> structs share
references to their internal arrays, you’ve almost certainly introduced a
<strong>nasty</strong> pernicious bug for your users.</p>
</div>
<div class="section" id="utilities-for-working-with-vbuffers">
<span id="utilities-for-working-with-vbuffers"></span><h2>Utilities for Working with <code class="docutils literal notranslate"><span class="pre">VBuffer</span></code>s<a class="headerlink" href="#utilities-for-working-with-vbuffers" title="Permalink to this headline">¶</a></h2>
<p>ML.NET’s runtime code has a number of utilities for operating over <code class="docutils literal notranslate"><span class="pre">VBuffer</span></code>s
that we have written to be generally useful. We will not treat on these in
detail here, but:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">Microsoft.ML.Runtime.Data.VBuffer&lt;T&gt;</span></code> itself contains a few methods for
accessing and iterating over its values.</li>
<li><code class="docutils literal notranslate"><span class="pre">Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils</span></code> contains utilities
mainly for non-numeric manipulation of <code class="docutils literal notranslate"><span class="pre">VBuffer</span></code>s.</li>
<li><code class="docutils literal notranslate"><span class="pre">Microsoft.ML.Runtime.Numeric.VectorUtils</span></code> contains math operations
over <code class="docutils literal notranslate"><span class="pre">VBuffer&lt;float&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">float[]</span></code>, like computing norms, dot-products, and
whatnot.</li>
<li><code class="docutils literal notranslate"><span class="pre">Microsoft.ML.Runtime.Data.BufferBuilder&lt;T&gt;</span></code> is an abstract class whose
concrete implementations are used throughout ML.NET to build up <code class="docutils literal notranslate"><span class="pre">VBuffer&lt;T&gt;</span></code>
instances. Note that if one <em>can</em> simply build a <code class="docutils literal notranslate"><span class="pre">VBuffer</span></code> oneself easily
and do not need the niceties provided by the buffer builder, you should
probably just do it yourself.</li>
<li><code class="docutils literal notranslate"><span class="pre">Microsoft.MachineLearning.Internal.Utilities.EnsureSize</span></code> is often useful to
ensure that the arrays are of the right size.</li>
</ul>
</div>
<div class="section" id="golden-rules">
<span id="golden-rules"></span><h2>Golden Rules<a class="headerlink" href="#golden-rules" title="Permalink to this headline">¶</a></h2>
<p>Here are some golden rules to remember:</p>
<p>Remember the conditions under which <code class="docutils literal notranslate"><span class="pre">Indices</span></code> and <code class="docutils literal notranslate"><span class="pre">Values</span></code> can be <code class="docutils literal notranslate"><span class="pre">null</span></code>! A
developer forgetting that <code class="docutils literal notranslate"><span class="pre">null</span></code> values for these fields are legal is probably
the most common error in our code. (And unfortunately one that sometimes takes
a while to pop up: most users don’t feed in empty inputs to our trainers.)</p>
<p>In terms of accessing anything in <code class="docutils literal notranslate"><span class="pre">Values</span></code> or <code class="docutils literal notranslate"><span class="pre">Indices</span></code>, remember, treat
<code class="docutils literal notranslate"><span class="pre">Count</span></code> as the real length of these arrays, not the actual length of the
arrays.</p>
<p>If you write code that results in two distinct <code class="docutils literal notranslate"><span class="pre">VBuffer</span></code>s sharing references
to their internal arrays, (for example, there are two <code class="docutils literal notranslate"><span class="pre">VBuffer</span></code>s <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>, with
<code class="docutils literal notranslate"><span class="pre">a.Indices</span> <span class="pre">==</span> <span class="pre">b.Indices</span></code> with <code class="docutils literal notranslate"><span class="pre">a.Indices</span> <span class="pre">!=</span> <span class="pre">null</span></code>, or <code class="docutils literal notranslate"><span class="pre">a.Values</span> <span class="pre">==</span> <span class="pre">b.Values</span></code>
with <code class="docutils literal notranslate"><span class="pre">a.Values</span> <span class="pre">!=</span> <span class="pre">null</span></code>) then you’ve almost certainly done something wrong.</p>
<p>Structure your code so that <code class="docutils literal notranslate"><span class="pre">VBuffer</span></code>s have their buffers re-used as much as
possible. If you have code called repeatedly where you are passing in some
<code class="docutils literal notranslate"><span class="pre">default(VBuffer&lt;T&gt;)</span></code>, there’s almost certainly an opportunity there.</p>
<p>When re-using a <code class="docutils literal notranslate"><span class="pre">VBuffer</span></code> that’s been passed to you, remember that even when
constructing a dense vector, you should still re-use the <code class="docutils literal notranslate"><span class="pre">Indices</span></code> array that
was passed in.</p>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/project_ico.png" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../index.html">Custom Extensions to ML.net</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dataframe.html">DataFrames in C#</a></li>
<li class="toctree-l1"><a class="reference internal" href="../commandline.html">Command Line</a></li>
<li class="toctree-l1"><a class="reference internal" href="../components/index.html">ML.net Components</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../machinelearning_docs.html">ML.net details</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html">ML.net details</a></li>
<li class="toctree-l2"><a class="reference internal" href="changes.html">ML.net releases details</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../concepts.html">Scikit.ML details</a></li>
<li class="toctree-l1"><a class="reference internal" href="../apicsharpdoc.html">CSharp API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../aonnx.html">ML.net and ONNX</a></li>
<li class="toctree-l1"><a class="reference internal" href="../incompatibilities.html">ML.net customization</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="../machinelearning_docs.html">ML.net details</a><ul>
  <li><a href="index.html">ML.net details</a><ul>
      <li>Previous: <a href="schemacomprehension.html" title="previous chapter">Schema comprehension in ML.NET</a></li>
      <li>Next: <a href="mvp.html" title="next chapter">MVP Spec</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/mlnetdocs/vbuffercarefeeding.md.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>