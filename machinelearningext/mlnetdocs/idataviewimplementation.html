
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>IDataView Implementation &#8212; Custom Extensions to ML.net 0.8.0 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="https://unpkg.com/font-awesome@4.5.0/css/font-awesome.min.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script type="text/javascript" src="https://unpkg.com/@jupyter-widgets/html-manager@^0.14.0/dist/embed-amd.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="IDataView Type System" href="idataviewtypesystem.html" />
    <link rel="prev" title="IDataView Design Principles" href="idataviewdesignprinciples.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="idataview-implementation">
<span id="idataview-implementation"></span><h1><code class="docutils literal notranslate"><span class="pre">IDataView</span></code> Implementation<a class="headerlink" href="#idataview-implementation" title="Permalink to this headline">¶</a></h1>
<p>This document is intended as an essay on the best practices for <code class="docutils literal notranslate"><span class="pre">IDataView</span></code>
implementations. As a prerequisite, we suppose that someone has read, and
mostly understood, the following documents:</p>
<ul class="simple">
<li><a class="reference external" href="IDataViewDesignPrinciples.md">Design principles</a> and</li>
<li><a class="reference external" href="IDataViewTypeSystem.md">Type system</a>.</li>
</ul>
<p>and has also read and understood the code documentation for the <code class="docutils literal notranslate"><span class="pre">IDataView</span></code>
and its attendant interfaces. Given that background, we will expand on best
practices and common patterns that go into a successful implementation of
<code class="docutils literal notranslate"><span class="pre">IDataView</span></code>, and motivate them with real examples, and historical learnings.</p>
<p>Put another way: There are now within the ML.NET codebase many implementations
of <code class="docutils literal notranslate"><span class="pre">IDataView</span></code> and many others in other related code bases that interface with
ML.NET. The corresponding PRs and discussions have resulted in the
accumulation of some information, stuff that is not and perhaps should not be
covered in the specification or XML code documentation, but that is
nonetheless quite valuable to know. That is, not the <code class="docutils literal notranslate"><span class="pre">IDataView</span></code> spec itself,
but many of the logical implications of that spec.</p>
<p>We will here start with the idioms and practices for <code class="docutils literal notranslate"><span class="pre">IDataView</span></code> generally,
before launching into specific <em>types</em> of data views: right now there are two
types of data views that have risen to the dignity of being “general”: loaders
and transforms. (There are many “specific” non-general data views: “array”
data views, cache data views, join data views, data views for taking other
abstractions for representing data and phrasing it in a way our code can
understand, but these do not follow any more general pattern as loaders and
transforms do.)</p>
</div>
<div class="section" id="urgency-in-adhering-to-invariants">
<span id="urgency-in-adhering-to-invariants"></span><h1>Urgency in Adhering to Invariants<a class="headerlink" href="#urgency-in-adhering-to-invariants" title="Permalink to this headline">¶</a></h1>
<p>The point of <code class="docutils literal notranslate"><span class="pre">IDataView</span></code> is that it enables composable data pipelines. But
what does that composability, practically, entail?</p>
<p>There are many implementations of <code class="docutils literal notranslate"><span class="pre">IDataView</span></code> and <code class="docutils literal notranslate"><span class="pre">IDataTransform</span></code> in the
ML.NET codebase. There are, further, many instances of <code class="docutils literal notranslate"><span class="pre">ITrainer</span></code> that consume
those data views. There are more implementations of these currently outside of
this codebase, totaling some hundreds. Astonishingly, they all actually work
well together. The reason why so many transforms can work well with so many
different dataviews as potential inputs, chained in arbitrary and strange ways
we can hardly imagine, and feed well into so many instances of <code class="docutils literal notranslate"><span class="pre">ITrainer</span></code> is
not of course because we wrote code to accommodate the Cartesian product of
all possible inputs, but merely because we assume that any given
implementation of <code class="docutils literal notranslate"><span class="pre">IDataView</span></code> obeys the invariants and principles it must.</p>
<p>This is a general principal of software engineering, or indeed any
engineering: it is nearly impossible to build any complex system of multiple
parts unless those subcomponents adhere to whatever specifications they’re
supposed to, and fulfill their requirements.</p>
<p>We can to some extent tolerate divergence from the invariants in <em>some</em>
components, if they are isolated: we have some losses that behave strangely,
even trainers behave somewhat strangely, sort of. Yet <code class="docutils literal notranslate"><span class="pre">IDataView</span></code> is the
center of our data pipeline, and divergences are more potentially harmful.
There is, for every requirement listed here, actually <em>something</em> that is
relying on it.</p>
<p>The inverse is also true: not only must <code class="docutils literal notranslate"><span class="pre">IDataView</span></code> conform to invariants,
code that consumes <code class="docutils literal notranslate"><span class="pre">IDataView</span></code> should be robust to situations other than the
“happy path.” It needn’t succeed, but it should at least be able to detect if
data is not in the expected form and throw an error message to the user
telling them how they misused it.</p>
<p>To give the most common example of what I have seen in PRs: often one designs
a transform or learner whose anticipated usage is that it will be used in
conjunction with another transform “upstream” to prepare the data. (Again,
this is very common: a <code class="docutils literal notranslate"><span class="pre">KeyToVector</span></code> transform for example assumes there’s
<em>something</em> upstream producing key values.) What happens sometimes is people
forget to check that the input data actually <em>does</em> conform to that, with the
result that if a pipeline was composed in some other fashion, there would be
some error.</p>
<p>The only thing you can really assume is that an <code class="docutils literal notranslate"><span class="pre">IDataView</span></code> behaves “sanely”
according to the contracts of the <code class="docutils literal notranslate"><span class="pre">IDataView</span></code> interface, so that future ML.NET
developers can form some reasonable expectations of how your code behaves, and
also have a prayer of knowing how to maintain the code. It is hard enough to
write software correctly even when the code you’re working with actually does
what it is supposed to, and impossible when it doesn’t. Anyway, not to belabor
the point: hidden undocumented implicit requirements on the usage</p>
</div>
<div class="section" id="design-decisions">
<span id="design-decisions"></span><h1>Design Decisions<a class="headerlink" href="#design-decisions" title="Permalink to this headline">¶</a></h1>
<p>Presumably you are motivated to read this document because you have some
problem of how to get some data into ML.NET, or process data using ML.NET, or
something along these lines. There is a decision to be made about how to even
engineer a solution. Sometimes it’s quite obvious: text featurization
obviously belongs as a transform. But other cases are <em>less</em> obvious. We will
talk here about how we think about these things.</p>
<p>One crucial question is whether something should be a data view at all: Often
there is ambiguity. To give some examples of previously contentious points:
should clustering be <em>transform</em> or a <em>trainer</em>? What about PCA? What about
LDA? In the end, we decided clustering was a <em>trainer</em> and both PCA and LDA
are <em>transforms</em>, but this decision was hardly unambiguous. Indeed, what
purpose is served by considering trainers and transforms fundamentally
different things, at all?</p>
<p>Even once we decide whether something <em>should</em> be an <code class="docutils literal notranslate"><span class="pre">IDataView</span></code> of some sort,
the question remains what type of data view. We have some canonical types of
data views:</p>
<p>If it involves taking data from a stream, like a file, or some sort of stream
of data from a network, or other such thing, we might consider this a
<em>loader</em>, that is, it should perhaps implement <code class="docutils literal notranslate"><span class="pre">IDataLoader</span></code>.</p>
<p>If it involves taking a <em>single</em> data view, and transmuting it in some
fashion, <strong>and</strong> the intent is this same transmutation might be applied to
novel data, then it should perhaps implement <code class="docutils literal notranslate"><span class="pre">IDataTransform</span></code>, and be a
transform.</p>
<p>Now then, consider that not everything should be a loader, or a transform,
even when data could be considered to be read from a stream, or when there is
a data view based on another single data view. The essential purpose of loader
and transforms is that they can exist as part of the data model, that is, they
should be serializable and applicable to new data. A nice rule of thumb is: if
when designing some you can imagine a scenario where you want to apply some
logic to <em>both</em> a training set as well as a test set, then it might make sense
to make it a loader or a transform. If not, it probably does not make sense.</p>
<ol class="simple">
<li>Often data comes from some programmatic source, as a starting point for an
ML.NET pipeline. Despite being at the head of the data pipe, it is <em>not</em> a
loader, because the data source is not a stream (though it is stream<em>ing</em>):
it is a <code class="docutils literal notranslate"><span class="pre">RowSetDataView</span></code>.</li>
<li>During training, data is sometimes cached. the structure that handles the
data caching is a <code class="docutils literal notranslate"><span class="pre">CacheDataView</span></code>. It is absolutely not a transform,
despite taking a single input and being itself an <code class="docutils literal notranslate"><span class="pre">IDataView</span></code>. There is no
reason to make it a transform, because there is no plausible rationale to
make it part of the data model: the decision of whether you want to cache
data during <em>training</em> has nothing at all to do with whether you want to
cache data during <em>scoring</em>, so there is no point in saving it to the data
model.</li>
<li>The ML.NET API for prediction uses a scheme that phrases input data
programmatically as coming from an enumerable of typed objects: the
underlying programmatic <code class="docutils literal notranslate"><span class="pre">IDataView</span></code> that is constructed to wrap this is
<em>not</em> a loader, because it is not part of the data model. It is merely the
entry point to the data model, at least, in typical usage.</li>
</ol>
</div>
<div class="section" id="why-getgetter">
<span id="why-getgetter"></span><h1>Why <code class="docutils literal notranslate"><span class="pre">GetGetter</span></code>?<a class="headerlink" href="#why-getgetter" title="Permalink to this headline">¶</a></h1>
<p>Let us address something fairly conspicuous. The question almost everyone
asks, when they first start using <code class="docutils literal notranslate"><span class="pre">IDataView</span></code>: what is up with these getters?</p>
<p>One does not fetch values directly from an <code class="docutils literal notranslate"><span class="pre">IRow</span></code> implementation (including
<code class="docutils literal notranslate"><span class="pre">IRowCursor</span></code>). Rather, one retains a delegate that can be used to fetch
objects, through the <code class="docutils literal notranslate"><span class="pre">GetGetter</span></code> method on <code class="docutils literal notranslate"><span class="pre">IRow</span></code>. This delegate is:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">delegate</span> <span class="k">void</span> <span class="n">ValueGetter</span><span class="p">&lt;</span><span class="n">TValue</span><span class="p">&gt;(</span><span class="k">ref</span> <span class="n">TValue</span> <span class="k">value</span><span class="p">);</span>
</pre></div>
</div>
<p>If you are unfamiliar with delegates, <a class="reference external" href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/">read
this</a>.
Anyway: you open a row cursor, you get the delegate through this <code class="docutils literal notranslate"><span class="pre">GetGetter</span></code>
method, and you use this delegate multiple times to fetch the actual column
values as you <code class="docutils literal notranslate"><span class="pre">MoveNext</span></code> through the cursor.</p>
<p>Some history to motivate this: In the first version of <code class="docutils literal notranslate"><span class="pre">IDataView</span></code> the
<code class="docutils literal notranslate"><span class="pre">IRowCursor</span></code> implementation did not actually have these “getters” but rather
had a method, <code class="docutils literal notranslate"><span class="pre">GetColumnValue&lt;TValue&gt;(int</span> <span class="pre">col,</span> <span class="pre">ref</span> <span class="pre">TValue</span> <span class="pre">val)</span></code>. However, this
has the following problems:</p>
<ul class="simple">
<li><strong>Every</strong> call had to verify that the column was active,</li>
<li><strong>Every</strong> call had to verify that <code class="docutils literal notranslate"><span class="pre">TValue</span></code> was of the right type,</li>
<li>When these were part of, say, a transform in a chain (as they often are,
considering how common transforms are used by ML.NET’s users) each access
would be accompanied by a virtual method call to the upstream cursor’s
<code class="docutils literal notranslate"><span class="pre">GetColumnValue</span></code>.</li>
</ul>
<p>In contrast, consider the situation with these getter delegates. The
verification of whether the column is active happens <em>exactly</em> once. The
verification of types happens <em>exactly</em> once. Rather than <em>every</em> access being
passed up through a chain of dozens of transform cursors, you merely get a
getter from whatever cursor is serving it up, and do every access directly
without having to pass through umpteen virtual method calls (each, naturally,
accompanied by their own checks!). With these preliminaries done, a getter on
every iteration, when called, merely has to just fill in the value: all this
verification work is already taken care of. The practical result of this is
that, for some workloads where the getters merely amounted to assigning
values, the “getter” method became an order of magnitude faster. So: we got
rid of this <code class="docutils literal notranslate"><span class="pre">GetColumnValue</span></code> method, and now work with <code class="docutils literal notranslate"><span class="pre">GetGetter</span></code>.</p>
</div>
<div class="section" id="repeatability">
<span id="repeatability"></span><h1>Repeatability<a class="headerlink" href="#repeatability" title="Permalink to this headline">¶</a></h1>
<p>A single <code class="docutils literal notranslate"><span class="pre">IDataView</span></code> instance should be considered a consistent view onto
data. So: if you open a cursor on the same <code class="docutils literal notranslate"><span class="pre">IDatView</span></code> instance, and access
values for the same columns, it will apparently be a “consistent” view. It is
probably obvious what this mean, but specifically:</p>
<p>The cursor as returned through <code class="docutils literal notranslate"><span class="pre">GetRowCursor</span></code> (with perhaps an identically
constructed <code class="docutils literal notranslate"><span class="pre">IRandom</span></code> instance) in any iteration should return the same number
of rows on all calls, and with the same values at each row.</p>
<p>Why is this important? Many machine learning algorithms require multiple
passes over the dataset. Most stochastic methods wouldn’t really care if the
data changed, but others are <em>very</em> sensitive to changes in the data. For
example, how could an L-BFGS or OWL-QN algorithm effectively compute its
approximation to a Hessian, if the examples from which the per-pass history
are computed were not consistent? How could a dual algorithm like SDCA
function with any accuracy, if the examples associated with any given dual
variable were to change? Consider even a relatively simple transform, like a
forward looking windowed averager, or anything relating to time series. The
implementation of those <code class="docutils literal notranslate"><span class="pre">ICursor</span></code> interfaces often open <em>two</em> cursors on the
underlying <code class="docutils literal notranslate"><span class="pre">IDataView</span></code>, one “look ahead” cursor used to gather and calculate
necessary statistics, and another cursor for any data: how could the column
constructed out of that transform be meaningful of the look ahead cursor was
consuming different data from the contemporaneous cursor? There are many
examples of this throughout the codebase.</p>
<p>Nevertheless: in very specific circumstances we have relaxed this. For
example, some ML.NET API code serves up corrupt <code class="docutils literal notranslate"><span class="pre">IDataView</span></code> implementations
that have their underlying data change, since reconstituting a data pipeline
on fresh data is at the present moment too resource intensive. Nonetheless,
this is wrong: for example, the <code class="docutils literal notranslate"><span class="pre">TrainingCursorBase</span></code> and related subclasses
rely upon the data not changing. Since, however, that is used for <em>training</em>
and the prediction engines of the API as used for <em>scoring</em>, we accept these.
However this is not, strictly speaking, correct, and this sort of corruption
of <code class="docutils literal notranslate"><span class="pre">IDataView</span></code> should only be considered as a last resort, and only when some
great good can be accomplished through this. We certainly did not accept this
corruption lightly!</p>
</div>
<div class="section" id="norms-for-the-data-model">
<span id="norms-for-the-data-model"></span><h1>Norms for the Data Model<a class="headerlink" href="#norms-for-the-data-model" title="Permalink to this headline">¶</a></h1>
<p>In a similar vein for repeatability and consistency is the notion of the data
model. Unlike repeatability, this topic is a bit specialized: <code class="docutils literal notranslate"><span class="pre">IDataView</span></code>
specifically is not serializable, but both <code class="docutils literal notranslate"><span class="pre">IDataLoader</span></code> and <code class="docutils literal notranslate"><span class="pre">IDataTransform</span></code>
are serializable. Nonetheless those are the two most important types of data
views, so we will treat on them here.</p>
<p>From a user’s perspective, when they run ML.NET and specify a loader or set of
transforms, what they are doing is composing a data pipe. For example, perhaps
they specify a way to load data from, say, a text file, apply some
normalization, some categorical handling, some text, some this, some that,
some everything, and it all just works, and is consistent whether we’re
applying that to the training data on which the transforms were defined, or
some other test set, whether we programmatically load the model in the API and
apply it to some production setting, whether we are running in a distributed
environment and want to make sure <em>all</em> worker nodes are featurizing data in
exactly the same way, etc. etc.</p>
<p>The way in which this consistency is accomplished is by having certain
requirements on the essential parts of the data model: loaders and transforms.
The essential reason these things exist is so that they can be applied to new
data in a consistent way.</p>
<p>Let us formalize this somewhat. We consider two data views to be functionally
identical if there is absolutely no way to distinguish them: they return the
same values, have the same types, same number of rows, they shuffle
identically given identically constructed <code class="docutils literal notranslate"><span class="pre">IRandom</span></code> when row cursors are
constructed, return the same ID for rows from the ID getter, etc. Obviously
this concept is transitive. (Of course, <code class="docutils literal notranslate"><span class="pre">Batch</span></code> in a cursor might be different
between the two, but that is the case even with two cursors constructed on the
same data view.) So some rules:</p>
<ol class="simple">
<li>If you have an <code class="docutils literal notranslate"><span class="pre">IDataLoader</span></code>, then saving/loading the associated data model
on the same data should result in a functionally identical <code class="docutils literal notranslate"><span class="pre">IDataLoader</span></code>.</li>
<li>If you have an <code class="docutils literal notranslate"><span class="pre">IDataTransform</span></code>, then saving/loading the associated data
model for the transforms on functionally identical <code class="docutils literal notranslate"><span class="pre">IDataView</span></code>s, should
itself result in functionally identical <code class="docutils literal notranslate"><span class="pre">IDataView</span></code>s.</li>
</ol>
<div class="section" id="versioning">
<span id="versioning"></span><h2>Versioning<a class="headerlink" href="#versioning" title="Permalink to this headline">¶</a></h2>
<p>This requirement for consistency of a data model often has implications across
versions of ML.NET, and our requirements for data model backwards
compatibility. As time has passed, we often feel like it would make sense if a
transform behaved <em>differently</em>, that is, if it organized or calculated its
output in a different way than it currently does. For example, suppose we
wanted to switch the hash transform to something a bit more efficient than
murmur hashes, for example. If we did so, presumably the same input values
would map to different outputs. We are free to do so, of course, yet: when we
deserialize a hash transform from before we made this change, that hash
transform should continue to output values as it did, before we made that
change. (This, of course, assuming that the transform was released as part of
a “blessed” non-preview point release of ML.NET. We can, and have, broken
backwards compatibility for something that has not yet been incorporated in
any sort of blessed release, though we prefer to not.)</p>
</div>
<div class="section" id="what-is-not-functionally-identical">
<span id="what-is-not-functionally-identical"></span><h2>What is Not Functionally Identical<a class="headerlink" href="#what-is-not-functionally-identical" title="Permalink to this headline">¶</a></h2>
<p>Note that identically <em>constructed</em> data views are not necessarily
<em>functionally</em> identical. Consider this usage of the train and score transform
with <code class="docutils literal notranslate"><span class="pre">xf=trainScore{tr=ap}</span></code>, where we first train averaged perceptron, then
copy its score and probability columns out of the way, then construct the
same basic transform again.</p>
<div class="highlight-maml notranslate"><div class="highlight"><pre><span></span>maml.exe showdata saver=md seed=1 data=breast-cancer.txt xf=trainScore{tr=ap}
    xf=copy{col=ScoreA:Score col=ProbA:Probability} xf=trainScore{tr=ap}
</pre></div>
</div>
<p>The result is this.</p>
<p>Label | Features                     | PredictedLabel | Score  | Probability  | ScoreA | ProbA
——|——————————|—————-|——–|————–|——–|——-
0     | 5, 1, 1, 1, 2, 1, 3, 1, 1    | 0              | -62.07 | 0.0117       | -75.28 | 0.0107
0     | 5, 4, 4, 5, 7, 10, 3, 2, 1   | 1              |  88.41 | 0.8173       |  92.04 | 0.8349
0     | 3, 1, 1, 1, 2, 2, 3, 1, 1    | 0              | -40.53 | 0.0269       | -44.23 | 0.0329
0     | 6, 8, 8, 1, 3, 4, 3, 7, 1    | 1              | 201.21 | 0.9973       | 208.07 | 0.9972
0     | 4, 1, 1, 3, 2, 1, 3, 1, 1    | 0              | -43.11 | 0.0243       | -55.32 | 0.0221
1     | 8, 10, 10, 8, 7, 10, 9, 7, 1 | 1              | 259.22 | 0.9997       | 257.43 | 0.9995
0     | 1, 1, 1, 1, 2, 10, 3, 1, 1   | 1              |  71.10 | 0.6933       |  89.52 | 0.8218
0     | 2, 1, 2, 1, 2, 1, 3, 1, 1    | 0              | -38.94 | 0.0286       | -39.59 | 0.0388
0     | 2, 1, 1, 1, 2, 1, 1, 1, 5    | 0              | -32.87 | 0.0360       | -41.52 | 0.0362
0     | 4, 2, 1, 1, 2, 1, 2, 1, 1    | 0              | -31.76 | 0.0376       | -41.68 | 0.0360</p>
<p>One could argue it’s not <em>really</em> identically constructed, exactly, since both
of those transforms (including the underlying averaged perceptron learner!)
are initialized using the pseudo-random number generator in an <code class="docutils literal notranslate"><span class="pre">IHost</span></code> that
changes from one to another. But, that’s a bit nit-picky.</p>
<p>Note also: when we say functionally identical we include everything about it:
not just the data, but the schema, its metadata, the implementation of
shuffling, etc. For this reason, while serializing the data <em>model</em> has
guarantees of consistency, serializing the <em>data</em> has no such guarantee: if
you serialize data using the text saver, practically all metadata (except slot
names) will be completely lost, which can have implications on how some
transforms and downstream processes work. Or: if you serialize data using the
binary saver, suddenly it may become shufflable whereas it may not have been
before.</p>
<p>The inevitable caveat to all this stuff about “consistency” is that it is
ultimately limited by hardware and other runtime environment factors: the
truth is, certain machines will, with identical programs with seemingly
identical flows of execution result, <em>sometimes</em>, in subtly different answers
where floating point values are concerned. Even on the same machine there are
runtime considerations, for example, when .NET’s RyuJIT was introduced in VS2015, we
had lots of test failures around our model consistency tests because the JIT
was compiling the CLI just <em>slightly</em> differently. But, this sort of thing
aside (which we can hardly help), we expect the models to be the same.</p>
</div>
</div>
<div class="section" id="on-loaders-data-models-and-empty-imultistreamsources">
<span id="on-loaders-data-models-and-empty-imultistreamsources"></span><h1>On Loaders, Data Models, and Empty <code class="docutils literal notranslate"><span class="pre">IMultiStreamSource</span></code>s<a class="headerlink" href="#on-loaders-data-models-and-empty-imultistreamsources" title="Permalink to this headline">¶</a></h1>
<p>When you create a loader you have the option of specifying not only <em>one</em> data
input, but any number of data input files, including zero. But there’s also a
more general principle at work here with zero files: when deserializing a data
loader from a data model with an <code class="docutils literal notranslate"><span class="pre">IMultiStreamSource</span></code> with <code class="docutils literal notranslate"><span class="pre">Count</span> <span class="pre">==</span> <span class="pre">0</span></code> (for example,
as would be constructed with <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">MultiFileSource(null)</span></code>), we have a protocol
that <em>every</em> <code class="docutils literal notranslate"><span class="pre">IDataLoader</span></code> should work in that circumstance, and merely be a
data view with no rows, but the same schema as it had when it was serialized.
The purpose of this is that we often have circumstances where we need to
understand the schema of the data (what columns were produced, what the
feature names are, etc.) when all we have is the data model. (For example, the
<code class="docutils literal notranslate"><span class="pre">savemodel</span></code> command, and other things.)</p>
</div>
<div class="section" id="getters-must-fail-for-invalid-types">
<span id="getters-must-fail-for-invalid-types"></span><h1>Getters Must Fail for Invalid Types<a class="headerlink" href="#getters-must-fail-for-invalid-types" title="Permalink to this headline">¶</a></h1>
<p>For a given <code class="docutils literal notranslate"><span class="pre">IRow</span></code>, we must expect that <code class="docutils literal notranslate"><span class="pre">GetGetter&lt;TValue&gt;(col)</span></code> will throw if
either <code class="docutils literal notranslate"><span class="pre">IsColumnActive(col)</span></code> is <code class="docutils literal notranslate"><span class="pre">false</span></code>, or <code class="docutils literal notranslate"><span class="pre">typeof(TValue)</span> <span class="pre">!=</span> <span class="pre">Schema.GetColumnType(col).RawType</span></code>, as indicated in the code documentation.
But why? It might seem reasonable to add seemingly “harmless” flexibility to
this interface. So let’s imagine your type should be <code class="docutils literal notranslate"><span class="pre">float</span></code>, because the
corresponding column’s type’s <code class="docutils literal notranslate"><span class="pre">RawType</span></code> is <code class="docutils literal notranslate"><span class="pre">typeof(float)</span></code>. Now: if you
<em>happen</em> to call <code class="docutils literal notranslate"><span class="pre">GetGetter&lt;double&gt;(col)</span></code> instead of <code class="docutils literal notranslate"><span class="pre">GetGetter&lt;float&gt;(col)</span></code>,
it would actually be a fairly easy matter for <code class="docutils literal notranslate"><span class="pre">GetGetter</span></code> to actually
accommodate it, by doing the necessary transformations under the hood, and
<em>not</em> fail. This type of thinking is actually insidiously and massively
harmful to the codebase, as I will remark.</p>
<p>The danger of writing code is that there’s a chance someone might find it
useful. Imagine a consumer of your dataview actually relies on your
“tolerance.” What that means, of course, is that this consuming code cannot
function effectively on any <em>other</em> dataview. The consuming code is by
definition <em>buggy</em>: it is requesting data of a type we’ve explicitly claimed,
through the schema, that we do not support. And the developer, through a well
intentioned but misguided design decision, has allowed buggy code to pass a
test it should have failed, thus making the codebase more fragile when, if we
had simply maintained requirements, would have otherwise detected the bug.</p>
<p>Moreover: it is a solution to a problem that does not exist. <code class="docutils literal notranslate"><span class="pre">IDataView</span></code>s are
fundamentally composable structures already, and one of the most fundamental
operations you can do is transform columns into different types. So, there is
no need for you to do the conversion yourself. Indeed, it is harmful for you
to try: if we have the conversion capability in one place, including the logic
of what can be converted and <em>how</em> these things are to be converted, is it
reasonable to suppose we should have it in <em>every implementation of
<code class="docutils literal notranslate"><span class="pre">IDataView</span></code>?</em> Certainly not. At best the situation will be needless complexity
in the code: more realistically it will lead to inconsistency, and from
inconsistency, surprises and bugs for users and developers.</p>
</div>
<div class="section" id="thread-safety">
<span id="thread-safety"></span><h1>Thread Safety<a class="headerlink" href="#thread-safety" title="Permalink to this headline">¶</a></h1>
<p>Any <code class="docutils literal notranslate"><span class="pre">IDataView</span></code> implementation, as well as the <code class="docutils literal notranslate"><span class="pre">ISchema</span></code>, <em>must</em> be thread
safe. There is a lot of code that depends on this. For example, cross
validation works by operating over the same dataset (just, of course, filtered
to different subsets of the data). That amounts to multiple cursors being
opened, simultaneously, over the same data.</p>
<p>So: <code class="docutils literal notranslate"><span class="pre">IDataView</span></code> and <code class="docutils literal notranslate"><span class="pre">ISchema</span></code> must be thread safe. However, <code class="docutils literal notranslate"><span class="pre">IRowCursor</span></code>,
being a stateful object, we assume is accessed from exactly one thread at a
time. The <code class="docutils literal notranslate"><span class="pre">IRowCursor</span></code>s returned through a <code class="docutils literal notranslate"><span class="pre">GetRowCursorSet</span></code>, however, which
each single one must be accessed by a single thread at a time, multiple
threads can access this set of cursors simultaneously: that’s why we have that
method in the first place.</p>
</div>
<div class="section" id="exceptions-and-errors">
<span id="exceptions-and-errors"></span><h1>Exceptions and Errors<a class="headerlink" href="#exceptions-and-errors" title="Permalink to this headline">¶</a></h1>
<p>There is one non-obvious implication of the lazy evaluation while cursoring
over an <code class="docutils literal notranslate"><span class="pre">IDataView</span></code>: while cursoring, you should almost certainly not throw
exceptions.</p>
<p>Imagine you have a <code class="docutils literal notranslate"><span class="pre">TextLoader</span></code>. You might expect that if you have a parse
error, for example, you have a column of floats, and one of the rows has a value
like, <code class="docutils literal notranslate"><span class="pre">&quot;hi!&quot;</span></code> or something otherwise uninterpretable, you would throw. Yet,
consider the implications of lazy evaluation. If that column were not
selected, the cursoring would <em>succeed</em>, because it would not look at that
<code class="docutils literal notranslate"><span class="pre">&quot;hi!&quot;</span></code> token <em>at all</em>, much less detect that it was not parsable as a float.</p>
<p>If we were to throw, the effect is that <em>sometimes</em> the cursoring will succeed
(if the column is not selected), and <em>sometimes</em> will fail (if not selected).
These failures are explainable, ultimately, of course, in the sense that
anything is explainable, but a user knows nothing about lazy evaluation or
anything like this: correspondingly this is enormously confusing.</p>
<p>The implication is that we should not throw an exception in this case. We
instead consider this value “missing,” and we <em>may</em> register a warning using
an <code class="docutils literal notranslate"><span class="pre">IChannel.Warning</span></code>, but we cannot fail.</p>
<p>So: If you could reasonably catch the exception on <em>any</em> cursoring over your
<code class="docutils literal notranslate"><span class="pre">IDataView</span></code>, you can throw. If, however, detecting the condition on which you
could throw the exception requires that a certain column be made active, then
you should not throw. Of course, there are extreme circumstances: for example,
one cannot help but throw on a cursoring if, say, there is some weird system
event, and if one somehow detects in a subsequent iteration that something is
fundamentally broken then you can throw: for example, the binary loader will throw if
it detects the file it is reading is corrupted, even if that corruption may
not have been obvious immediately.</p>
</div>
<div class="section" id="getgetter-returning-the-same-delegate">
<span id="getgetter-returning-the-same-delegate"></span><h1><code class="docutils literal notranslate"><span class="pre">GetGetter</span></code> Returning the Same Delegate<a class="headerlink" href="#getgetter-returning-the-same-delegate" title="Permalink to this headline">¶</a></h1>
<p>On a single instance of <code class="docutils literal notranslate"><span class="pre">IRowCursor</span></code>, since each <code class="docutils literal notranslate"><span class="pre">IRowCursor</span></code> instance has no
requirement to be thread safe, it is entirely legal for a call to <code class="docutils literal notranslate"><span class="pre">GetGetter</span></code>
on a single column to just return the same getting delegate. It has come to
pass that the majority of implementations of <code class="docutils literal notranslate"><span class="pre">IRowCursor</span></code> actually do that,
since it is in some ways easier to write the code that way.</p>
<p>This practice has inadvertently enabled a fairly attractive tool for analysis
of data pipelines: by returning the same delegate each time, we can check in a
data pipeline what data is being passed through by seeing whether the
references to getter delegates are being passed through. Now this is
imperfect, because some transforms that could use the same delegate each time
do not, but the vast majority do.</p>
</div>
<div class="section" id="class-structuring">
<span id="class-structuring"></span><h1>Class Structuring<a class="headerlink" href="#class-structuring" title="Permalink to this headline">¶</a></h1>
<p>The essential attendant classes of an <code class="docutils literal notranslate"><span class="pre">IDataView</span></code> are its schema, as returned
through the <code class="docutils literal notranslate"><span class="pre">Schema</span></code> property, as well as the <code class="docutils literal notranslate"><span class="pre">IRowCursor</span></code> implementation(s),
as returned through the <code class="docutils literal notranslate"><span class="pre">GetRowCursor</span></code> and <code class="docutils literal notranslate"><span class="pre">GetRowCursorSet</span></code> methods. The
implementations for those two interfaces are typically nested within the
<code class="docutils literal notranslate"><span class="pre">IDataView</span></code> implementation itself. The cursor implementation is almost always
at the bottom of the data view class.</p>
</div>
<div class="section" id="irow-and-icursor-vs-irowcursor">
<span id="irow-and-icursor-vs-irowcursor"></span><h1><code class="docutils literal notranslate"><span class="pre">IRow</span></code> and <code class="docutils literal notranslate"><span class="pre">ICursor</span></code> vs. <code class="docutils literal notranslate"><span class="pre">IRowCursor</span></code><a class="headerlink" href="#irow-and-icursor-vs-irowcursor" title="Permalink to this headline">¶</a></h1>
<p>We have <code class="docutils literal notranslate"><span class="pre">IRowCursor</span></code> which descends from both <code class="docutils literal notranslate"><span class="pre">IRow</span></code> and <code class="docutils literal notranslate"><span class="pre">ICursor</span></code>. Why do
these other interfaces exist?</p>
<p>Firstly, there are implementations of <code class="docutils literal notranslate"><span class="pre">IRow</span></code> or <code class="docutils literal notranslate"><span class="pre">ICursor</span></code> that are not
<code class="docutils literal notranslate"><span class="pre">IRowCursor</span></code>s. We have occasionally found it useful to have something
resembling a key-value store, but that is strongly, dynamically typed in some
fashion. Why not simply represent this using the same idioms of <code class="docutils literal notranslate"><span class="pre">IDataView</span></code>?
So we put them in an <code class="docutils literal notranslate"><span class="pre">IRow</span></code>. Similarly: we have several things that behave
<em>like</em> cursors, but that are in no way <em>row</em> cursors.</p>
<p>However, more than that, there are a number of utility functions where we want
to operate over something like an <code class="docutils literal notranslate"><span class="pre">IRowCursor</span></code>, but we want to have some
indication that this function will not move the cursor (in which case <code class="docutils literal notranslate"><span class="pre">IRow</span></code>
is helpful), or that will not access any values (in which case <code class="docutils literal notranslate"><span class="pre">ICursor</span></code> is
helpful).</p>
</div>
<div class="section" id="schema">
<span id="schema"></span><h1>Schema<a class="headerlink" href="#schema" title="Permalink to this headline">¶</a></h1>
<p>The schema contains information about the columns. As we see in <a class="reference external" href="IDataViewDesignPrinciples.md">the design
principles</a>, it has index, data type, and
optional metadata.</p>
<p>While <em>programmatically</em> accesses to an <code class="docutils literal notranslate"><span class="pre">IDataView</span></code> are by index, from a
user’s perspective the indices are by name; most training algorithms
conceptually train on the <code class="docutils literal notranslate"><span class="pre">Features</span></code> column (under default settings). For this
reason nearly all usages of an <code class="docutils literal notranslate"><span class="pre">IDataView</span></code> will be prefixed with a call to the
schema’s <code class="docutils literal notranslate"><span class="pre">TryGetColumnIndex</span></code>.</p>
<p>Regarding name hiding, the principles mention that when multiple columns have
the same name, other columns are “hidden.” The convention all implementations
of <code class="docutils literal notranslate"><span class="pre">ISchema</span></code> obey is that the column with the <em>largest</em> index. Note however
that this is merely convention, not part of the definition of <code class="docutils literal notranslate"><span class="pre">ISchema</span></code>.</p>
<p>Implementations of <code class="docutils literal notranslate"><span class="pre">TryGetColumnIndex</span></code> should be O(1), that is, practically,
this mapping ought to be backed with a dictionary in most cases. (There are
obvious exceptions like, say, things like <code class="docutils literal notranslate"><span class="pre">LineLoader</span></code> which produce exactly
one column. There, a simple equality test suffices.)</p>
<p>It is best if <code class="docutils literal notranslate"><span class="pre">GetColumnType</span></code> returns the <em>same</em> object every time. That is,
things like key-types and vector-types, when returned, should not be created
in the function itself (thereby creating a new object every time), but rather
stored somewhere and returned.</p>
<div class="section" id="metadata">
<span id="metadata"></span><h2>Metadata<a class="headerlink" href="#metadata" title="Permalink to this headline">¶</a></h2>
<p>Since metadata is <em>optional</em>, one is not obligated to necessarily produce it,
or conform to any particular schemas for any particular kinds (beyond, say,
the obvious things like making sure that the types and values are consistent).
However, the flip side of that freedom given to <em>producers</em>, is that
<em>consumers</em> are obligated, when processing a data view input, to react
gracefully when metadata of a certain kind is absent, or not in a form that
one expects. One should <em>never</em> fail when input metadata is in a form one does
not expect.</p>
<p>To give a practical example of this: many transforms, learners, or other
components that process <code class="docutils literal notranslate"><span class="pre">IDataView</span></code>s will do something with the slot names,
but when the <code class="docutils literal notranslate"><span class="pre">SlotNames</span></code> metadata kind for a given column is either absent,
<em>or</em> not of the right type (vectors of strings), <em>or</em> not of the right size
(same length vectors as the input), the behavior is not to throw or yield
errors or do anything of the kind, but to simply say, “oh, I don’t really have
slot names,” and proceed as if the slot names hadn’t been present at all.</p>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/project_ico.png" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../index.html">Custom Extensions to ML.net</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dataframe.html">DataFrames in C#</a></li>
<li class="toctree-l1"><a class="reference internal" href="../commandline.html">Command Line</a></li>
<li class="toctree-l1"><a class="reference internal" href="../components/index.html">ML.net Components</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../machinelearning_docs.html">ML.net details</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html">ML.net details</a></li>
<li class="toctree-l2"><a class="reference internal" href="changes.html">ML.net releases details</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../concepts.html">Scikit.ML details</a></li>
<li class="toctree-l1"><a class="reference internal" href="../apicsharpdoc.html">CSharp API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../aonnx.html">ML.net and ONNX</a></li>
<li class="toctree-l1"><a class="reference internal" href="../incompatibilities.html">ML.net customization</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="../machinelearning_docs.html">ML.net details</a><ul>
  <li><a href="index.html">ML.net details</a><ul>
      <li>Previous: <a href="idataviewdesignprinciples.html" title="previous chapter">IDataView Design Principles</a></li>
      <li>Next: <a href="idataviewtypesystem.html" title="next chapter"><code class="docutils literal notranslate"><span class="pre">IDataView</span></code> Type System</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/mlnetdocs/idataviewimplementation.md.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>