<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">

  <title>skl2onnx.common._topology</title>

  <link rel="stylesheet" href="../../../_static/sphinx-modern-theme-modified.css" type="text/css"/>
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />
</head>
<body>
<div class="container">
  <div class="row" style="margin-top: 1rem;">
    <div id="sidebar" class="col-xs-12 col-sm-3">
      <a href="../../../index.html">
        <img style="margin-bottom: 0.5rem;" class="img-fluid" src="../../../_static/logo_main.png"/>
      </a>
      <div id="searchbox" style="display: none" role="search">
        <form class="form-inline" action="../../../search.html" method="get">
          <div class="form-group">
            <label class="sr-only" for="searchInput">Search</label>
            <input type="text" class="form-control" name="q" id="searchInput" placeholder="Search">
          </div>
          <button type="submit" class="btn btn-secondary" style="display:none">Go</button>
          <input type="hidden" name="check_keywords" value="yes"/>
          <input type="hidden" name="area" value="default"/>
        </form>
      </div>

      <hr>

        <div id="toc">
        <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial.html">Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorial.html#step-1-train-a-model-using-your-favorite-framework">Step 1: Train a model using your favorite framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorial.html#step-2-convert-or-export-the-model-into-onnx-format">Step 2: Convert or export the model into ONNX format</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorial.html#step-3-load-and-run-the-model-using-onnx-runtime">Step 3: Load and run the model using ONNX Runtime</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_summary.html">API Summary</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../api_summary.html#converters">Converters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api_summary.html#manipulate-onnx-graphs">Manipulate ONNX graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api_summary.html#registered-functions">Registered functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api_summary.html#parsers">Parsers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api_summary.html#utils-for-contributors">Utils for contributors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api_summary.html#concepts">Concepts</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/index.html">Gallery of examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../auto_examples/plot_backend.html">ONNX Runtime Backend for ONNX</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../auto_examples/plot_pipeline.html">Draw a pipeline</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../auto_examples/plot_metadata.html">Metadata</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../auto_examples/plot_convert_model.html">Train, convert and predict a model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../auto_examples/plot_errors_onnxruntime.html">Errors with onnxruntime</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../auto_examples/plot_pipeline_lightgbm.html">Convert a pipeline with a LightGbm model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../auto_examples/plot_complex_pipeline.html">Convert a pipeline with ColumnTransformer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../auto_examples/plot_tfidfvectorizer.html">TfIdfVectorizer with ONNX</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../auto_examples/plot_errors_pipeline.html">Errors while converting a pipeline</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../auto_examples/plot_intermediate_outputs.html">Walk through intermediate outputs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../auto_examples/plot_transfer_learning.html">Transfer learning with ONNX</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../auto_examples/plot_custom_model.html">Write your own converter for your own model</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../supported.html">Supported Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../pipeline.html">Convert a pipeline</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../pipeline.html#convert-complex-pipelines">Convert complex pipelines</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../pipeline.html#parser-shape-calculator-converter">Parser, shape calculator, converter</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../pipeline.html#new-converters-in-a-pipeline">New converters in a pipeline</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../pipeline.html#titanic-example">Titanic example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../pipeline.html#parameterize-the-conversion">Parameterize the conversion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../parameterized.html">Converters with options</a></li>
</ul>

        </div>
    </div>
    <div class="col-xs-12 col-sm-9">
      <h1>Source code for skl2onnx.common._topology</h1><div class="highlight"><pre>
<span></span><span class="c1"># -------------------------------------------------------------------------</span>
<span class="c1"># Copyright (c) Microsoft Corporation. All rights reserved.</span>
<span class="c1"># Licensed under the MIT License. See License.txt in the project root for</span>
<span class="c1"># license information.</span>
<span class="c1"># --------------------------------------------------------------------------</span>

<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">logging</span> <span class="k">import</span> <span class="n">getLogger</span>
<span class="kn">from</span> <span class="nn">onnx</span> <span class="k">import</span> <span class="n">onnx_pb</span> <span class="k">as</span> <span class="n">onnx_proto</span>
<span class="kn">from</span> <span class="nn">..proto</span> <span class="k">import</span> <span class="n">helper</span>
<span class="kn">from</span> <span class="nn">..proto</span> <span class="k">import</span> <span class="n">get_opset_number_from_onnx</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">_registration</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">utils</span>
<span class="kn">from</span> <span class="nn">.data_types</span> <span class="k">import</span> <span class="n">FloatType</span><span class="p">,</span> <span class="n">Int64Type</span><span class="p">,</span> <span class="n">StringType</span><span class="p">,</span> <span class="n">TensorType</span>
<span class="kn">from</span> <span class="nn">.data_types</span> <span class="k">import</span> <span class="n">DictionaryType</span><span class="p">,</span> <span class="n">FloatTensorType</span> <span class="c1"># noqa</span>
<span class="kn">from</span> <span class="nn">.data_types</span> <span class="k">import</span> <span class="n">Int64TensorType</span><span class="p">,</span> <span class="n">SequenceType</span> <span class="c1"># noqa</span>
<span class="kn">from</span> <span class="nn">._container</span> <span class="k">import</span> <span class="n">ModelComponentContainer</span>
<span class="kn">from</span> <span class="nn">.interface</span> <span class="k">import</span> <span class="n">OperatorBase</span>


<div class="viewcode-block" id="Variable"><a class="viewcode-back" href="../../../api_summary.html#skl2onnx.common._topology.Variable">[docs]</a><span class="k">class</span> <span class="nc">Variable</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines a variable which holds any data defined</span>
<span class="sd">    from *ONNX* types.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw_name</span><span class="p">,</span> <span class="n">onnx_name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param raw_name: A string indicating the variable&#39;s name in the</span>
<span class="sd">                         original model. Usually, it&#39;s the seed string</span>
<span class="sd">                         used to created its ONNX name (i.e., the</span>
<span class="sd">                         field *onnx_name* below).</span>
<span class="sd">        :param onnx_name: A string indicating the variable&#39;s name in</span>
<span class="sd">                          the converted model</span>
<span class="sd">        :param scope: A string. It&#39;s the name of the scope where this</span>
<span class="sd">                      variable is declared</span>
<span class="sd">        :param type: A type object defined in .common.data_types.py;</span>
<span class="sd">                     e.g., FloatTensorType</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_name</span> <span class="o">=</span> <span class="n">raw_name</span>  <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">onnx_name</span> <span class="o">=</span> <span class="n">onnx_name</span>  <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scope</span> <span class="o">=</span> <span class="n">scope</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">type</span>
        <span class="c1"># The following fields are bool variables used in parsing and</span>
        <span class="c1"># compiling stages</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_fed</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_root</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_leaf</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_abandoned</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">full_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a globally unique variable ID</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_name</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;Variable(raw_name=&#39;</span><span class="si">{0}</span><span class="s2">&#39;, onnx_name=&#39;</span><span class="si">{1}</span><span class="s2">&#39;, type=</span><span class="si">{2}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">raw_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">))</span></div>


<div class="viewcode-block" id="Operator"><a class="viewcode-back" href="../../../api_summary.html#skl2onnx.common._topology.Operator">[docs]</a><span class="k">class</span> <span class="nc">Operator</span><span class="p">(</span><span class="n">OperatorBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines an operator available in *ONNX*.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">onnx_name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">raw_operator</span><span class="p">,</span> <span class="n">target_opset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param onnx_name: A unique ID, which is a string</span>
<span class="sd">        :param scope: The name of the scope where this operator is</span>
<span class="sd">                      declared. It&#39;s a string.</span>
<span class="sd">        :param type: A object which uniquely characterizes the type of</span>
<span class="sd">                     this operator. For example, it can be a string,</span>
<span class="sd">                     pooling, if this operator is associated with a</span>
<span class="sd">                     CoreML pooling layer.</span>
<span class="sd">        :param raw_operator: The original operator which defines this operator;</span>
<span class="sd">                             for example, a scikit-learn Imputer and</span>
<span class="sd">                             a CoreML Normalizer.</span>
<span class="sd">        :param target_opset: The target opset number for the converted model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># operator name in the converted model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">onnx_name</span> <span class="o">=</span> <span class="n">onnx_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scope</span> <span class="o">=</span> <span class="n">scope</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_operator</span> <span class="o">=</span> <span class="n">raw_operator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_evaluated</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_abandoned</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_opset</span> <span class="o">=</span> <span class="n">target_opset</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">full_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a globally unique operator ID</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">input_full_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return all input variables&#39; names</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">variable</span><span class="o">.</span><span class="n">full_name</span> <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">output_full_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return all output variables&#39; names</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">variable</span><span class="o">.</span><span class="n">full_name</span> <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">original_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the original operator/layer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_operator</span>

    <span class="k">def</span> <span class="nf">infer_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Invoke a core inference function</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Unable to find a shape calculator for type &quot;</span>
                               <span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">)))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">shape_calc</span> <span class="o">=</span> <span class="n">_registration</span><span class="o">.</span><span class="n">get_shape_calculator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unable to find a shape calculator for alias &quot;</span>
                             <span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39; and type &#39;</span><span class="si">{}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">)))</span>
        <span class="n">shape_calc</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="Scope"><a class="viewcode-back" href="../../../api_summary.html#skl2onnx.common._topology.Scope">[docs]</a><span class="k">class</span> <span class="nc">Scope</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Every node of an *ONNX* graph must be unique. This class holds the list</span>
<span class="sd">    of existing name for every node already defined in graph. It also</span>
<span class="sd">    provides functions to create a unique unused name.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">parent_scopes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">variable_name_set</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">operator_name_set</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target_opset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">custom_shape_calculators</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param name: A string, the unique ID of this scope in a</span>
<span class="sd">                     Topology object</span>
<span class="sd">        :param parent_scopes: A list of Scope objects. The last element</span>
<span class="sd">                              should be the direct parent scope (i.e.,</span>
<span class="sd">                              where this scope is declared).</span>
<span class="sd">        :param variable_name_set: A set of strings serving as the name</span>
<span class="sd">                                  pool of variables</span>
<span class="sd">        :param operator_name_set: A set of strings serving as the name</span>
<span class="sd">                                  pool of operators</span>
<span class="sd">        :param target_opset: The target opset number for the converted</span>
<span class="sd">                             model.</span>
<span class="sd">        :param custom_conversion_functions: a dictionary for specifying</span>
<span class="sd">                                the user customized conversion function</span>
<span class="sd">        :param custom_shape_calculators: a dictionary for specifying</span>
<span class="sd">                                the user customized shape calculator</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent_scopes</span> <span class="o">=</span> <span class="n">parent_scopes</span> <span class="k">if</span> <span class="n">parent_scopes</span> <span class="k">else</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">onnx_variable_names</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">variable_name_set</span> <span class="k">if</span> <span class="n">variable_name_set</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">set</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">onnx_operator_names</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">operator_name_set</span> <span class="k">if</span> <span class="n">operator_name_set</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">set</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_opset</span> <span class="o">=</span> <span class="n">target_opset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span> <span class="o">=</span> <span class="n">custom_shape_calculators</span>

        <span class="c1"># An one-to-many map from raw variable name to ONNX variable</span>
        <span class="c1"># names. It looks like</span>
        <span class="c1"># (key, value) = (raw_name, [onnx_name, onnx_name1, onnx_name2, ..., onnx_nameN]) # noqa</span>
        <span class="c1"># The last name may hide all other names in this scope.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variable_name_mapping</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># A map of local variables defined in this scope.</span>
        <span class="c1"># (key, value) = (onnx_name, variable)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># A map of local operators defined in this scope.</span>
        <span class="c1"># (key, value) = (onnx_name, operator)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operators</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">get_shape_calculator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_type</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the shape calculator for the given model type.</span>

<span class="sd">        :param model_type: model type such as *LogisticRegression*</span>
<span class="sd">        :return: alias or None if not found</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">model_type</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_onnx_variable_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the variable ID of the given seed or create one</span>
<span class="sd">        if it is the first time of seeing this seed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">seed</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_name_mapping</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_name_mapping</span><span class="p">[</span><span class="n">seed</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_unique_variable_name</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

<div class="viewcode-block" id="Scope.get_unique_variable_name"><a class="viewcode-back" href="../../../api_summary.html#skl2onnx.common._topology.Scope.get_unique_variable_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_unique_variable_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a unique variable ID based on the given seed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Topology</span><span class="o">.</span><span class="n">_generate_unique_name</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_variable_names</span><span class="p">)</span></div>

<div class="viewcode-block" id="Scope.get_unique_operator_name"><a class="viewcode-back" href="../../../api_summary.html#skl2onnx.common._topology.Scope.get_unique_operator_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_unique_operator_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a unique operator ID based on the given seed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Topology</span><span class="o">.</span><span class="n">_generate_unique_name</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_operator_names</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">find_sink_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds sink variables in this scope.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First we assume all variables are sinks</span>
        <span class="n">is_sink</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="kc">True</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
        <span class="c1"># Then, we remove those variables which are inputs of some operators</span>
        <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operators</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
                <span class="n">is_sink</span><span class="p">[</span><span class="n">variable</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">variable</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">is_sink</span><span class="p">[</span><span class="n">name</span><span class="p">]]</span>

    <span class="k">def</span> <span class="nf">declare_local_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw_name</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function may create a new variable in this scope. If</span>
<span class="sd">        *raw_name* has been used to create other variables, the new</span>
<span class="sd">        variable will hide all other variables created using *raw_name*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get unique ID for the new variable</span>
        <span class="n">onnx_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_unique_variable_name</span><span class="p">(</span><span class="n">raw_name</span><span class="p">)</span>

        <span class="c1"># Create the variable</span>
        <span class="n">variable</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">raw_name</span><span class="p">,</span> <span class="n">onnx_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">onnx_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">variable</span>

        <span class="k">if</span> <span class="n">raw_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_name_mapping</span><span class="p">:</span>
            <span class="c1"># Hide existing variables with the same raw_name</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">prepend</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">variable_name_mapping</span><span class="p">[</span><span class="n">raw_name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">onnx_name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">variable_name_mapping</span><span class="p">[</span><span class="n">raw_name</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">onnx_name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">variable_name_mapping</span><span class="p">[</span><span class="n">raw_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">onnx_name</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">variable</span>

    <span class="k">def</span> <span class="nf">get_local_variable_or_declare_one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw_name</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function first checks if *raw_name* has been used to create</span>
<span class="sd">        some variables. If yes, the latest one named in</span>
<span class="sd">        ``self.variable_name_mapping[raw_name]`` will be returned.</span>
<span class="sd">        Otherwise, a new variable will be created and then returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">onnx_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_onnx_variable_name</span><span class="p">(</span><span class="n">raw_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">onnx_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">onnx_name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">variable</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">raw_name</span><span class="p">,</span> <span class="n">onnx_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">onnx_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">variable</span>
            <span class="k">if</span> <span class="n">raw_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_name_mapping</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">variable_name_mapping</span><span class="p">[</span><span class="n">raw_name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">onnx_name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">variable_name_mapping</span><span class="p">[</span><span class="n">raw_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">onnx_name</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">variable</span>

    <span class="k">def</span> <span class="nf">declare_local_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">raw_model</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function is used to declare new local operator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">onnx_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_unique_operator_name</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">))</span>
        <span class="n">operator</span> <span class="o">=</span> <span class="n">Operator</span><span class="p">(</span><span class="n">onnx_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">raw_model</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">target_opset</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operators</span><span class="p">[</span><span class="n">onnx_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">operator</span>
        <span class="k">return</span> <span class="n">operator</span>

    <span class="k">def</span> <span class="nf">delete_local_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">onnx_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes the operator whose onnx_name is the input *onnx_name*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">onnx_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_operator_names</span> <span class="ow">or</span>
                <span class="n">onnx_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operators</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;The operator to be removed not found&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">onnx_operator_names</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">onnx_name</span><span class="p">)</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">operators</span><span class="p">[</span><span class="n">onnx_name</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">delete_local_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">onnx_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes the variable whose *onnx_name* is the input *onnx_name*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">onnx_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_variable_names</span> <span class="ow">or</span>
                <span class="n">onnx_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;The variable to be removed not found&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">onnx_variable_names</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">onnx_name</span><span class="p">)</span>
        <span class="n">raw_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">onnx_name</span><span class="p">]</span><span class="o">.</span><span class="n">raw_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variable_name_mapping</span><span class="p">[</span><span class="n">raw_name</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">onnx_name</span><span class="p">)</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">onnx_name</span><span class="p">]</span></div>


<div class="viewcode-block" id="Topology"><a class="viewcode-back" href="../../../api_summary.html#skl2onnx.common._topology.Topology">[docs]</a><span class="k">class</span> <span class="nc">Topology</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Holds instances on :class:`Scope &lt;skl2onnx.common._topology.Scope&gt;` and</span>
<span class="sd">    :class:`SklearnModelContainer &lt;skl2onnx.common._container.SklearnModelContainer&gt;`.</span>
<span class="sd">    These are filled by the converters while a pipeline is being converted.</span>
<span class="sd">    When all converters were called, method</span>
<span class="sd">    :meth:`Topology.compile &lt;skl2onnx.common._topology.Topology.compile&gt;`</span>
<span class="sd">    must be called to convert the topological graph into *ONNX* graph.</span>
<span class="sd">    &quot;&quot;&quot;</span> <span class="c1"># noqa</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">default_batch_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">initial_types</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">reserved_variable_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reserved_operator_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">target_opset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">custom_conversion_functions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">custom_shape_calculators</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">metadata_props</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes a *Topology* object, which is an intermediate</span>
<span class="sd">        representation of a computational graph.</span>

<span class="sd">        :param model: RawModelContainer object or one of its derived</span>
<span class="sd">                      classes. It contains the original model.</span>
<span class="sd">        :param default_batch_size: batch_size prepend to scalar and</span>
<span class="sd">                                   array types from CoreML. It&#39;s usually</span>
<span class="sd">                                   1 or &#39;None&#39;.</span>
<span class="sd">        :param initial_types: A list providing some types for some</span>
<span class="sd">                              root variables.</span>
<span class="sd">        Each element is a tuple of a variable name and a type defined</span>
<span class="sd">        in *data_types.py*.</span>
<span class="sd">        :param reserved_variable_names: A set of strings which are not</span>
<span class="sd">                                        allowed to be used as a variable</span>
<span class="sd">                                        name</span>
<span class="sd">        :param reserved_operator_names: A set of strings which are not</span>
<span class="sd">                                        allowed to be used as a operator</span>
<span class="sd">                                        name</span>
<span class="sd">        :param custom_conversion_functions: a dictionary for specifying</span>
<span class="sd">                                the user customized conversion function</span>
<span class="sd">        :param custom_shape_calculators: a dictionary for specifying the</span>
<span class="sd">                                        user customized shape calculator</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scope_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variable_name_set</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">reserved_variable_names</span>
                    <span class="k">if</span> <span class="n">reserved_variable_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">set</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operator_name_set</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">reserved_operator_names</span>
                    <span class="k">if</span> <span class="n">reserved_operator_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">set</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_types</span> <span class="o">=</span> <span class="n">initial_types</span> <span class="k">if</span> <span class="n">initial_types</span> <span class="k">else</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata_props</span> <span class="o">=</span> <span class="n">metadata_props</span> <span class="k">if</span> <span class="n">metadata_props</span> <span class="k">else</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_batch_size</span> <span class="o">=</span> <span class="n">default_batch_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_opset</span> <span class="o">=</span> <span class="n">target_opset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">custom_conversion_functions</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">custom_conversion_functions</span> <span class="k">if</span> <span class="n">custom_conversion_functions</span> <span class="k">else</span> <span class="p">{})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">custom_shape_calculators</span> <span class="k">if</span> <span class="n">custom_shape_calculators</span> <span class="k">else</span> <span class="p">{})</span>

        <span class="c1"># This attribute is used in optimizing the graph structure. If</span>
        <span class="c1"># root_names is not empty, only the variables specified will be</span>
        <span class="c1"># treated as the roots (i.e., set is_fed to True in the</span>
        <span class="c1"># beginning of a graph evaluation) of the graph. Specifying all</span>
        <span class="c1"># root variables in this list and leaving it empty are</span>
        <span class="c1"># equivalent. This attribute directly affects</span>
        <span class="c1"># _initialize_graph_status_for_traversing function and</span>
        <span class="c1"># indirectly affects _infer_all_shapes and _prune functions.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_conversion_functions</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Keys in custom_conversion_functions must be &quot;</span>
                                <span class="s2">&quot;types not strings.&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Keys in custom_shape_calculators must be &quot;</span>
                                <span class="s2">&quot;types not strings.&quot;</span><span class="p">)</span>

        <span class="c1"># A map of local overwritten model aliases.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_aliases</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">all_model_types</span> <span class="o">=</span> <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">custom_conversion_functions</span><span class="p">)</span>
                           <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">mtype</span> <span class="ow">in</span> <span class="n">all_model_types</span><span class="p">:</span>
            <span class="n">alias</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mtype</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model_aliases</span><span class="p">[</span><span class="n">mtype</span><span class="p">]</span> <span class="o">=</span> <span class="n">alias</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_generate_unique_name</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">existing_names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Produce an unique string based on the seed</span>
<span class="sd">        :param seed: a string</span>
<span class="sd">        :param existing_names: a set containing strings which cannot be</span>
<span class="sd">                               produced</span>
<span class="sd">        :return: a string similar to the seed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">seed</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Name seed must be an non-empty string&#39;</span><span class="p">)</span>

        <span class="c1"># Make the seed meet C-style naming convention</span>
        <span class="c1"># Only alphabets and numbers are allowed</span>
        <span class="n">seed</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;[^0-9a-zA-Z]&#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="n">seed</span><span class="p">)</span>
        <span class="c1"># The first symbol cannot be a number</span>
        <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;^[0-9]&#39;</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
            <span class="n">seed</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">seed</span>

        <span class="c1"># If seed has never been seen, we return it as it is. Otherwise,</span>
        <span class="c1"># we will append an number to make it unique.</span>
        <span class="k">if</span> <span class="n">seed</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">existing_names</span><span class="p">:</span>
            <span class="n">existing_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">seed</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">seed</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="ow">in</span> <span class="n">existing_names</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">new_name</span> <span class="o">=</span> <span class="n">seed</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">existing_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_name</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new_name</span>

    <span class="k">def</span> <span class="nf">get_unique_scope_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Topology</span><span class="o">.</span><span class="n">_generate_unique_name</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scope_names</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">declare_scope</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">,</span> <span class="n">parent_scopes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new :class:`Scope &lt;skl2onnx.common._topology.Scope&gt;`</span>
<span class="sd">        and appends it to the list of existing scopes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scope</span> <span class="o">=</span> <span class="n">Scope</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_unique_scope_name</span><span class="p">(</span><span class="n">seed</span><span class="p">),</span> <span class="n">parent_scopes</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">variable_name_set</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator_name_set</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_opset</span><span class="p">,</span>
            <span class="n">custom_shape_calculators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">scope</span>

    <span class="k">def</span> <span class="nf">unordered_operator_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">scope</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">operators</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">operator</span>

    <span class="k">def</span> <span class="nf">unordered_variable_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">scope</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">variable</span>

    <span class="k">def</span> <span class="nf">find_root_and_sink_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds root variables of the whole graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First we assume all variables are roots</span>
        <span class="n">is_root</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">name</span><span class="p">:</span> <span class="kc">True</span> <span class="k">for</span> <span class="n">scope</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="c1"># Then, we remove those variables which are outputs of some operators</span>
        <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unordered_operator_iterator</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
                <span class="n">is_root</span><span class="p">[</span><span class="n">variable</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">is_sink</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">name</span><span class="p">:</span> <span class="kc">True</span> <span class="k">for</span> <span class="n">scope</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unordered_operator_iterator</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
                <span class="n">is_sink</span><span class="p">[</span><span class="n">variable</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">variable</span> <span class="k">for</span> <span class="n">scope</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span>
                <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">is_root</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="ow">or</span> <span class="n">is_sink</span><span class="p">[</span><span class="n">name</span><span class="p">]]</span>

    <span class="k">def</span> <span class="nf">topological_operator_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is an iterator of all operators in Topology object.</span>
<span class="sd">        Operators may be produced in a topological order. If you want to</span>
<span class="sd">        simply go though all operators without considering their</span>
<span class="sd">        topological structure, please use another function,</span>
<span class="sd">        unordered_operator_iterator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_graph_status_for_traversing</span><span class="p">()</span>
        <span class="n">priorities</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;tensorToProbabilityMap&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
            <span class="s1">&#39;tensorToLabel&#39;</span><span class="p">:</span> <span class="mi">1</span>
        <span class="p">}</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">is_evaluated</span> <span class="k">for</span> <span class="n">scope</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span>
                      <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">operators</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="n">is_evaluation_happened</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unordered_operator_iterator</span><span class="p">(),</span>
                                   <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">op</span><span class="p">:</span> <span class="n">priorities</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">type</span><span class="p">]</span>
                                   <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="n">priorities</span> <span class="k">else</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">is_fed</span> <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
                        <span class="ow">and</span> <span class="ow">not</span> <span class="n">operator</span><span class="o">.</span><span class="n">is_evaluated</span><span class="p">):</span>
                    <span class="c1"># Check if over-writing problem occurs (i.e., multiple</span>
                    <span class="c1"># operators produce results on one variable).</span>
                    <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
                        <span class="c1"># Throw an error if this variable has been treated as</span>
                        <span class="c1"># an output somewhere</span>
                        <span class="k">if</span> <span class="n">variable</span><span class="o">.</span><span class="n">is_fed</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;One variable can only be &#39;</span>
                                               <span class="s1">&#39;assigned once&#39;</span><span class="p">)</span>
                        <span class="c1"># Mark this variable as filled</span>
                        <span class="n">variable</span><span class="o">.</span><span class="n">is_fed</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="c1"># Make this operator as handled</span>
                    <span class="n">operator</span><span class="o">.</span><span class="n">is_evaluated</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">is_evaluation_happened</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="c1"># Send out an operator</span>
                    <span class="k">yield</span> <span class="n">operator</span>
            <span class="c1"># After scanning through the whole computational graph, at</span>
            <span class="c1"># least one operator should be evaluated. If not, we need</span>
            <span class="c1"># to terminate this procedure to avoid dead lock.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_evaluation_happened</span><span class="p">:</span>
                <span class="k">break</span>

    <span class="k">def</span> <span class="nf">rename_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old_name</span><span class="p">,</span> <span class="n">new_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replaces the old ONNX variable name with a new ONNX variable</span>
<span class="sd">        name. There are several fields we need to edit.</span>

<span class="sd">        a. Topology</span>
<span class="sd">            1. scopes (the scope where the specified ONNX variable was</span>
<span class="sd">                       declared)</span>
<span class="sd">            2. variable_name_set</span>
<span class="sd">        b. Scope</span>
<span class="sd">            1. onnx_variable_names (a mirror of Topology&#39;s</span>
<span class="sd">                                    variable_name_set)</span>
<span class="sd">            2. variable_name_mapping</span>
<span class="sd">            3. variables</span>

<span class="sd">        :param old_name: a string</span>
<span class="sd">        :param new_name: a string</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Search for the first variable that is named as old_name.</span>
        <span class="n">scope</span><span class="p">,</span> <span class="n">onnx_name</span><span class="p">,</span> <span class="n">variable</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span>
            <span class="p">(</span><span class="n">scope</span><span class="p">,</span> <span class="n">onnx_name</span><span class="p">,</span> <span class="n">variable</span><span class="p">)</span> <span class="k">for</span> <span class="n">scope</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span>
            <span class="k">for</span> <span class="n">onnx_name</span><span class="p">,</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">onnx_name</span> <span class="o">==</span> <span class="n">old_name</span><span class="p">)</span>

        <span class="c1"># Rename the variable we just found</span>
        <span class="n">variable</span><span class="o">.</span><span class="n">onnx_name</span> <span class="o">=</span> <span class="n">new_name</span>

        <span class="c1"># Because the ONNX name of the targeted variable got changed,</span>
        <span class="c1"># the (onnx_name, variable) pair in the associated scope&#39;s</span>
        <span class="c1"># variable dictionary should be changed as well. We therefore</span>
        <span class="c1"># create a new pair to replace the old pair.</span>
        <span class="n">scope</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">new_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">variable</span>
        <span class="k">del</span> <span class="n">scope</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">old_name</span><span class="p">]</span>

        <span class="c1"># One original CoreML name may have several ONNX names recorded.</span>
        <span class="c1"># To fix the record affected by renaming, we need to replace</span>
        <span class="c1"># old_name with new_name in the record of the associated CoreML</span>
        <span class="c1"># name (variable.raw_name). Note that derived_names contains</span>
        <span class="c1"># all ONNX variable names derived from variable.raw_name.</span>
        <span class="n">derived_names</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="n">variable_name_mapping</span><span class="p">[</span><span class="n">variable</span><span class="o">.</span><span class="n">raw_name</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">derived_names</span><span class="p">)):</span>
            <span class="c1"># Find old_name in derived_names</span>
            <span class="k">if</span> <span class="n">old_name</span> <span class="o">!=</span> <span class="n">derived_names</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="c1"># Replace the recorded ONNX name with the new name</span>
            <span class="n">derived_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_name</span>
            <span class="c1"># Because ONNX names are unique so name replacement only</span>
            <span class="c1"># happens once, we terminate the loop right after one name</span>
            <span class="c1"># replacement.</span>
            <span class="k">break</span>

        <span class="c1"># Finally, new_name takes the place of old_name in the set of</span>
        <span class="c1"># all existing variable names</span>
        <span class="n">scope</span><span class="o">.</span><span class="n">onnx_variable_names</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">old_name</span><span class="p">)</span>
        <span class="n">scope</span><span class="o">.</span><span class="n">onnx_variable_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function applies some rules to check if the parsed model is</span>
<span class="sd">        proper. Currently, it only checks if isolated variable and</span>
<span class="sd">        isolated operator exists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Collect all variable names and operator names</span>
        <span class="n">unused_variables</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">unused_operators</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unordered_variable_iterator</span><span class="p">():</span>
            <span class="n">unused_variables</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">full_name</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unordered_operator_iterator</span><span class="p">():</span>
            <span class="n">unused_operators</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">full_name</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unordered_operator_iterator</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
                <span class="c1"># A variable is used by an operator, so we remove the</span>
                <span class="c1"># variable from the unused-variable list.</span>
                <span class="n">unused_variables</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">full_name</span><span class="p">)</span>
                <span class="c1"># A operator has an input, so we remove the operator</span>
                <span class="c1"># from the unused-operator list.</span>
                <span class="n">unused_operators</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">full_name</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
                <span class="c1"># A variable is used by an operator, so we remove the</span>
                <span class="c1"># variable from the unused-variable list.</span>
                <span class="n">unused_variables</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">full_name</span><span class="p">)</span>
                <span class="c1"># A operator has an output, so we remove the operator</span>
                <span class="c1"># from the unused-operator list.</span>
                <span class="n">unused_operators</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">full_name</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unused_variables</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Isolated variables exist: </span><span class="si">%s</span><span class="s1">&#39;</span>
                               <span class="o">%</span> <span class="n">unused_variables</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unused_operators</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Isolated operators exist: </span><span class="si">%s</span><span class="s1">&#39;</span>
                               <span class="o">%</span> <span class="n">unused_operators</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_initialize_graph_status_for_traversing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the status of all variables and operators for</span>
<span class="sd">        traversing the underline graph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># In the beginning, we set is_root and is_leaf true. For is_fed,</span>
        <span class="c1"># we have two different behaviors depending on whether</span>
        <span class="c1"># root_names is empty.</span>
        <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unordered_variable_iterator</span><span class="p">():</span>
            <span class="c1"># If root_names is set, we only set those variable to be</span>
            <span class="c1"># fed. Otherwise, all roots would be fed.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_names</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">variable</span><span class="o">.</span><span class="n">onnx_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_names</span><span class="p">:</span>
                    <span class="n">variable</span><span class="o">.</span><span class="n">is_fed</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">variable</span><span class="o">.</span><span class="n">is_fed</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">variable</span><span class="o">.</span><span class="n">is_fed</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">variable</span><span class="o">.</span><span class="n">is_root</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">variable</span><span class="o">.</span><span class="n">is_leaf</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Then, we flip some flags by applying some simple rules so</span>
        <span class="c1"># that only</span>
        <span class="c1">#   1. all roots get is_root=True and is_fed=True</span>
        <span class="c1">#   2. all leaves get is_leaf=True</span>
        <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unordered_operator_iterator</span><span class="p">():</span>
            <span class="c1"># All operators are not processed in the beginning</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">is_evaluated</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
                <span class="c1"># Output cannot be fed before graph traversing</span>
                <span class="n">variable</span><span class="o">.</span><span class="n">is_fed</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="c1"># If the variable is an output of one operator,</span>
                <span class="c1"># it must not be a root</span>
                <span class="n">variable</span><span class="o">.</span><span class="n">is_root</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
                <span class="c1"># If the variable is an input of one operator,</span>
                <span class="c1"># it must not be a leaf</span>
                <span class="n">variable</span><span class="o">.</span><span class="n">is_leaf</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_infer_all_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Infer all variables&#39; shapes in the computational graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_graph_status_for_traversing</span><span class="p">()</span>

        <span class="c1"># Deliver user-specified types to root variables</span>
        <span class="k">for</span> <span class="n">raw_name</span><span class="p">,</span> <span class="n">initial_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_types</span><span class="p">:</span>
            <span class="c1"># Check all variables declared using raw_name in</span>
            <span class="c1"># the whole graph</span>
            <span class="k">for</span> <span class="n">scope</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">:</span>
                <span class="c1"># Skip scopes without having the considered variable</span>
                <span class="c1"># name</span>
                <span class="k">if</span> <span class="n">raw_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">variable_name_mapping</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="c1"># Assign initial_type to all variables declared using</span>
                <span class="c1"># raw_name</span>
                <span class="k">for</span> <span class="n">onnx_name</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">variable_name_mapping</span><span class="p">[</span><span class="n">raw_name</span><span class="p">]:</span>
                    <span class="n">variable</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">onnx_name</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">variable</span><span class="o">.</span><span class="n">is_root</span><span class="p">:</span>
                        <span class="c1"># Assign type to the root; existing type</span>
                        <span class="c1"># produced by parser may be overwritten</span>
                        <span class="n">variable</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">initial_type</span>

        <span class="c1"># Traverse the graph from roots to leaves</span>
        <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">topological_operator_iterator</span><span class="p">():</span>
            <span class="n">mtype</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mtype</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span><span class="p">:</span>
                <span class="c1"># overwritten operator.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span><span class="p">[</span><span class="n">mtype</span><span class="p">](</span><span class="n">operator</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">operator</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span><span class="p">[</span><span class="n">operator</span><span class="o">.</span><span class="n">type</span><span class="p">](</span><span class="n">operator</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">operator</span><span class="o">.</span><span class="n">infer_types</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_resolve_duplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merge variables connected by identity operator to reduce the</span>
<span class="sd">        number of redundant variables</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_graph_status_for_traversing</span><span class="p">()</span>

        <span class="c1"># Traverse the graph from roots to leaves</span>
        <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">topological_operator_iterator</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">operator</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="s1">&#39;identity&#39;</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">is_root</span> <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="nb">any</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">is_leaf</span> <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">outputs</span><span class="p">)):</span>
                <span class="k">continue</span>

            <span class="c1"># Replace the output variable with the input variable everywhere</span>
            <span class="n">original</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">duplicate</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">another_scope</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">another_operator</span> <span class="ow">in</span> <span class="n">another_scope</span><span class="o">.</span><span class="n">operators</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">another_operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">another_operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">onnx_name</span>
                                <span class="o">!=</span> <span class="n">duplicate</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">):</span>
                            <span class="k">continue</span>
                        <span class="n">another_operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">original</span>

            <span class="c1"># When original variable&#39;s documentation string or</span>
            <span class="c1"># denotation is empty but duplicate&#39;s is not, we copy that</span>
            <span class="c1"># field to the original variable to avoid information loss.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">original</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">doc_string</span> <span class="ow">and</span> <span class="n">duplicate</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">doc_string</span><span class="p">:</span>
                <span class="n">original</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">doc_string</span> <span class="o">=</span> <span class="n">duplicate</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">doc_string</span>

            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">original</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">TensorType</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">duplicate</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">TensorType</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">original</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">denotation</span> <span class="ow">and</span> <span class="n">duplicate</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">denotation</span><span class="p">:</span>
                    <span class="n">original</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">denotation</span> <span class="o">=</span> <span class="n">duplicate</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">denotation</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">original</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">channel_denotations</span><span class="p">:</span>
                    <span class="n">original</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">channel_denotations</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">duplicate</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">channel_denotations</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">duplicate</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">channel_denotations</span><span class="p">:</span>
                    <span class="c1"># Merge the channel denotations if available in both</span>
                    <span class="c1"># the original and the duplicate</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">original</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">channel_denotations</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="n">original</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">channel_denotations</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                            <span class="k">continue</span>
                        <span class="n">original</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">channel_denotations</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">duplicate</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">channel_denotations</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="c1"># Sometime, shapes of duplicates are different. We try</span>
                <span class="c1"># to replace the original variable&#39;s unknown dimensions</span>
                <span class="c1"># as many as possible because we will get rid of the</span>
                <span class="c1"># duplicate.</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">original</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">duplicate</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">original</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="n">original</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;None&#39;</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="n">original</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">duplicate</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># Because we&#39;re iterating through the topology, we cannot</span>
            <span class="c1"># delete any operator or variable. Otherwise, the traversing</span>
            <span class="c1"># function may be broken. We will delete those abandoned</span>
            <span class="c1"># ones later.</span>
            <span class="n">duplicate</span><span class="o">.</span><span class="n">is_abandoned</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">is_abandoned</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">for</span> <span class="n">scope</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">:</span>
            <span class="c1"># Find out who is going to be abandoned</span>
            <span class="n">abandoned_operator_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
                <span class="n">onnx_name</span> <span class="k">for</span> <span class="n">onnx_name</span><span class="p">,</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">operators</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">operator</span><span class="o">.</span><span class="n">is_abandoned</span><span class="p">)</span>
            <span class="n">abandoned_variable_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
                <span class="n">onnx_name</span> <span class="k">for</span> <span class="n">onnx_name</span><span class="p">,</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">variable</span><span class="o">.</span><span class="n">is_abandoned</span><span class="p">)</span>

            <span class="c1"># Remove abandoned operators</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">abandoned_operator_names</span><span class="p">:</span>
                <span class="n">scope</span><span class="o">.</span><span class="n">delete_local_operator</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

            <span class="c1"># Remove abandoned variables</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">abandoned_variable_names</span><span class="p">:</span>
                <span class="n">scope</span><span class="o">.</span><span class="n">delete_local_variable</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_fix_shapes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function applies some rules to adjust graph inputs</span>
<span class="sd">        (i.e., roots) before doing shape inference</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Identify roots of a graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_graph_status_for_traversing</span><span class="p">()</span>

        <span class="c1"># Scan through all operators and adjust their variables&#39; shapes</span>
        <span class="c1"># if needed</span>
        <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unordered_operator_iterator</span><span class="p">():</span>
            <span class="c1"># Rule 1 (CoreML):</span>
            <span class="c1"># Some operator in CoreML only accepts 4-D tensors but</span>
            <span class="c1"># their protobuf models might specify a 2-D one.</span>
            <span class="c1"># We fix this problem here.</span>
            <span class="k">if</span> <span class="n">operator</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="p">[</span>
                    <span class="s1">&#39;bias&#39;</span><span class="p">,</span> <span class="s1">&#39;concat&#39;</span><span class="p">,</span> <span class="s1">&#39;convolution&#39;</span><span class="p">,</span> <span class="s1">&#39;crop&#39;</span><span class="p">,</span> <span class="s1">&#39;flatten&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;scalerPreprocessor&#39;</span><span class="p">,</span> <span class="s1">&#39;lrn&#39;</span><span class="p">,</span> <span class="s1">&#39;meanImagePreprocessor&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;padding&#39;</span><span class="p">,</span> <span class="s1">&#39;permute&#39;</span><span class="p">,</span> <span class="s1">&#39;pooling&#39;</span><span class="p">,</span> <span class="s1">&#39;reduce&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;reorganizeData&#39;</span><span class="p">,</span> <span class="s1">&#39;reshape&#39;</span><span class="p">,</span> <span class="s1">&#39;scale&#39;</span><span class="p">,</span> <span class="s1">&#39;slice&#39;</span><span class="p">,</span> <span class="s1">&#39;upsample&#39;</span><span class="p">]:</span>
                <span class="c1"># We only adjust inputs because outputs will be</span>
                <span class="c1"># automatically fixed at our shape inference stage</span>
                <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">variable</span><span class="o">.</span><span class="n">is_root</span><span class="p">:</span>
                        <span class="c1"># Convert [N, C] to [N, C, 1, 1] while</span>
                        <span class="c1"># [N, C, H, W] is unchanged</span>
                        <span class="n">variable</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span> <span class="o">+=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span>
                            <span class="mi">4</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_prune</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Conduct a dummy evaluation of this topology. It may set all</span>
        <span class="c1"># reachable operators evaluated and all reachable variables fed.</span>
        <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">topological_operator_iterator</span><span class="p">():</span>
            <span class="k">pass</span>

        <span class="k">for</span> <span class="n">scope</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">:</span>
            <span class="c1"># Remove unused operators</span>
            <span class="n">abandoned_operator_names</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">operators</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">operator</span><span class="o">.</span><span class="n">is_evaluated</span><span class="p">:</span>
                    <span class="n">abandoned_operator_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">onnx_name</span> <span class="ow">in</span> <span class="n">abandoned_operator_names</span><span class="p">:</span>
                <span class="n">scope</span><span class="o">.</span><span class="n">delete_local_operator</span><span class="p">(</span><span class="n">onnx_name</span><span class="p">)</span>

            <span class="c1"># Remove unused variables</span>
            <span class="n">abandoned_variable_names</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">variable</span><span class="o">.</span><span class="n">is_fed</span><span class="p">:</span>
                    <span class="n">abandoned_variable_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">onnx_name</span> <span class="ow">in</span> <span class="n">abandoned_variable_names</span><span class="p">:</span>
                <span class="n">scope</span><span class="o">.</span><span class="n">delete_local_variable</span><span class="p">(</span><span class="n">onnx_name</span><span class="p">)</span>

<div class="viewcode-block" id="Topology.compile"><a class="viewcode-back" href="../../../api_summary.html#skl2onnx.common._topology.Topology.compile">[docs]</a>    <span class="k">def</span> <span class="nf">compile</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function aims at giving every operator enough information</span>
<span class="sd">        so that all operator conversions can happen independently. We</span>
<span class="sd">        also want to check, fix, and simplify the network structure</span>
<span class="sd">        here.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prune</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_duplicates</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fix_shapes</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_infer_all_types</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_structure</span><span class="p">()</span></div></div>


<span class="k">def</span> <span class="nf">convert_topology</span><span class="p">(</span><span class="n">topology</span><span class="p">,</span> <span class="n">model_name</span><span class="p">,</span> <span class="n">doc_string</span><span class="p">,</span> <span class="n">target_opset</span><span class="p">,</span>
                     <span class="n">channel_first_inputs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function is used to convert our Topology object defined in</span>
<span class="sd">    _parser.py into a ONNX model (type: ModelProto).</span>
<span class="sd">    :param topology: The Topology object we are going to convert</span>
<span class="sd">    :param model_name: GraphProto&#39;s name. Let &quot;model&quot; denote the</span>
<span class="sd">                       returned model. The string &quot;model_name&quot; would be</span>
<span class="sd">                       assigned to &quot;model.graph.name.&quot;</span>
<span class="sd">    :param doc_string: A string attached to the produced model</span>
<span class="sd">    :param target_opset: number, for example, 7 for ONNX 1.2, and 8 for</span>
<span class="sd">                         ONNX 1.3.</span>
<span class="sd">    :param options: see :ref:`l-conv-options`</span>
<span class="sd">    include &#39;1.1.2&#39;, &#39;1.2&#39;, and so on.</span>
<span class="sd">    :return: a ONNX ModelProto</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">target_opset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">target_opset</span> <span class="o">=</span> <span class="n">get_opset_number_from_onnx</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">target_opset</span> <span class="o">&gt;</span> <span class="n">get_opset_number_from_onnx</span><span class="p">():</span>
        <span class="n">found</span> <span class="o">=</span> <span class="n">get_opset_number_from_onnx</span><span class="p">()</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="s2">&quot;target_opset </span><span class="si">{}</span><span class="s2"> &gt; </span><span class="si">{}</span><span class="s2"> is higher than the number of the installed &quot;</span>
            <span class="s2">&quot;onnx package. See &quot;</span>
            <span class="s2">&quot;https://github.com/onnx/onnx/blob/master/docs/Versioning.md#released-versions&quot;</span> <span class="c1"># noqa</span>
            <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">target_opset</span><span class="p">,</span> <span class="n">found</span><span class="p">))</span>

    <span class="n">topology</span><span class="o">.</span><span class="n">_initialize_graph_status_for_traversing</span><span class="p">()</span>

    <span class="n">container</span> <span class="o">=</span> <span class="n">ModelComponentContainer</span><span class="p">(</span><span class="n">target_opset</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">)</span>

    <span class="c1"># Put roots and leaves as ONNX&#39;s model into buffers. They will be</span>
    <span class="c1"># added into ModelComponentContainer later.</span>
    <span class="n">tensor_inputs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">other_inputs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">tensor_outputs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">other_outputs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">scope</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">scopes</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">variable</span><span class="o">.</span><span class="n">is_root</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="p">(</span><span class="n">TensorType</span><span class="p">,</span> <span class="n">Int64Type</span><span class="p">,</span>
                                              <span class="n">FloatType</span><span class="p">,</span> <span class="n">StringType</span><span class="p">)):</span>
                    <span class="n">tensor_inputs</span><span class="p">[</span><span class="n">variable</span><span class="o">.</span><span class="n">raw_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">variable</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">other_inputs</span><span class="p">[</span><span class="n">variable</span><span class="o">.</span><span class="n">raw_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">variable</span>
            <span class="k">if</span> <span class="n">variable</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="p">(</span><span class="n">TensorType</span><span class="p">,</span> <span class="n">Int64Type</span><span class="p">,</span>
                                              <span class="n">FloatType</span><span class="p">,</span> <span class="n">StringType</span><span class="p">)):</span>
                    <span class="n">tensor_outputs</span><span class="p">[</span><span class="n">variable</span><span class="o">.</span><span class="n">raw_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">variable</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">other_outputs</span><span class="p">[</span><span class="n">variable</span><span class="o">.</span><span class="n">raw_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">variable</span>

    <span class="c1"># Add roots the graph according to their order in the original model</span>
    <span class="n">invalid_name</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">nhwc_inputs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">channel_first_inputs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">channel_first_inputs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">raw_model</span><span class="o">.</span><span class="n">input_names</span><span class="p">:</span>
        <span class="c1"># Check input naming convention</span>
        <span class="n">input_name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">input_name</span> <span class="ow">and</span> <span class="p">(</span><span class="n">input_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()</span> <span class="ow">or</span>
                           <span class="p">(</span><span class="ow">not</span> <span class="n">input_name</span><span class="o">.</span><span class="n">isalnum</span><span class="p">())):</span>
            <span class="n">invalid_name</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">tensor_inputs</span><span class="p">:</span>
            <span class="c1"># type: Variable</span>
            <span class="n">onnx_input</span> <span class="o">=</span> <span class="n">tensor_inputs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="ow">in</span> <span class="n">channel_first_inputs</span> <span class="ow">or</span>
                    <span class="p">(</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;:0&#39;</span><span class="p">)</span> <span class="ow">and</span>
                     <span class="n">name</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="ow">in</span> <span class="n">channel_first_inputs</span><span class="p">)):</span>
                <span class="n">nhwc_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">onnx_input</span><span class="o">.</span><span class="n">full_name</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">onnx_input</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">onnx_input</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
            <span class="n">container</span><span class="o">.</span><span class="n">add_input</span><span class="p">(</span><span class="n">onnx_input</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">invalid_name</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Some input names are not compliant with ONNX naming &#39;</span>
                      <span class="s1">&#39;convention: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">invalid_name</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">raw_model</span><span class="o">.</span><span class="n">input_names</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">other_inputs</span><span class="p">:</span>
            <span class="n">container</span><span class="o">.</span><span class="n">add_input</span><span class="p">(</span><span class="n">other_inputs</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="c1"># Add leaves the graph according to their order in</span>
    <span class="c1"># the original model</span>
    <span class="n">invalid_name</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">raw_model</span><span class="o">.</span><span class="n">output_names</span><span class="p">:</span>
        <span class="c1"># Check output naming convention</span>
        <span class="n">output_name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">output_name</span> <span class="ow">and</span> <span class="p">(</span><span class="n">output_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()</span> <span class="ow">or</span>
                            <span class="p">(</span><span class="ow">not</span> <span class="n">output_name</span><span class="o">.</span><span class="n">isalnum</span><span class="p">())):</span>
            <span class="n">invalid_name</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">tensor_outputs</span><span class="p">:</span>
            <span class="n">container</span><span class="o">.</span><span class="n">add_output</span><span class="p">(</span><span class="n">tensor_outputs</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">invalid_name</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Some output names are not compliant with ONNX naming &#39;</span>
                      <span class="s1">&#39;convention: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">invalid_name</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">raw_model</span><span class="o">.</span><span class="n">output_names</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">other_outputs</span><span class="p">:</span>
            <span class="n">container</span><span class="o">.</span><span class="n">add_output</span><span class="p">(</span><span class="n">other_outputs</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="c1"># Traverse the graph from roots to leaves</span>
    <span class="c1"># This loop could eventually be parallelized.</span>
    <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">topological_operator_iterator</span><span class="p">():</span>
        <span class="n">scope</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">scope</span> <span class="k">for</span> <span class="n">scope</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">scopes</span>
                     <span class="k">if</span> <span class="n">scope</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">operator</span><span class="o">.</span><span class="n">scope</span><span class="p">)</span>
        <span class="n">mtype</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mtype</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">custom_conversion_functions</span><span class="p">:</span>
            <span class="n">conv</span> <span class="o">=</span> <span class="n">topology</span><span class="o">.</span><span class="n">custom_conversion_functions</span><span class="p">[</span><span class="n">mtype</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">operator</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">custom_conversion_functions</span><span class="p">:</span>
            <span class="n">conv</span> <span class="o">=</span> <span class="n">topology</span><span class="o">.</span><span class="n">custom_conversion_functions</span><span class="p">[</span><span class="n">operator</span><span class="o">.</span><span class="n">type</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Convert the selected operator into some ONNX objects and</span>
            <span class="c1"># save them into the container</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">conv</span> <span class="o">=</span> <span class="n">_registration</span><span class="o">.</span><span class="n">get_converter</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Unable to find converter for alias &#39;</span><span class="si">{}</span><span class="s2">&#39; type &quot;</span>
                    <span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
                                   <span class="nb">type</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="s1">&#39;raw_model&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))))</span>
        <span class="n">conv</span><span class="p">(</span><span class="n">scope</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">container</span><span class="p">)</span>

    <span class="c1"># When calling ModelComponentContainer&#39;s add_initializer(...),</span>
    <span class="c1"># nothing is added into the input list. However, in ONNX</span>
    <span class="c1"># initializers should also be model&#39;s (GraphProto) inputs. Thus, we</span>
    <span class="c1"># create ValueInfoProto objects from initializers(type: TensorProto)</span>
    <span class="c1"># directly and then add them into model&#39;s input list.</span>
    <span class="n">extra_inputs</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># ValueInfoProto list of the initializers</span>
    <span class="k">for</span> <span class="n">tensor</span> <span class="ow">in</span> <span class="n">container</span><span class="o">.</span><span class="n">initializers</span><span class="p">:</span>
        <span class="c1"># Sometimes (especially when creating optional input values</span>
        <span class="c1"># such as RNN&#39;s initial hidden state), an initializer is also</span>
        <span class="c1"># one of the original model&#39;s input, so it has been added into</span>
        <span class="c1"># the container&#39;s input list. If this is the case, we need to</span>
        <span class="c1"># skip one iteration to avoid duplicated inputs.</span>
        <span class="k">if</span> <span class="n">tensor</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="n">value_info</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">value_info</span> <span class="ow">in</span> <span class="n">container</span><span class="o">.</span><span class="n">inputs</span><span class="p">]:</span>
            <span class="k">continue</span>

        <span class="c1"># Initializers are always tensors so we can just call</span>
        <span class="c1"># make_tensor_value_info(...)</span>
        <span class="n">value_info</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">make_tensor_value_info</span><span class="p">(</span>
                <span class="n">tensor</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">tensor</span><span class="o">.</span><span class="n">data_type</span><span class="p">,</span> <span class="n">tensor</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">extra_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value_info</span><span class="p">)</span>

    <span class="c1"># Create a graph from its main components</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">make_graph</span><span class="p">(</span><span class="n">container</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">model_name</span><span class="p">,</span>
                              <span class="n">container</span><span class="o">.</span><span class="n">inputs</span> <span class="o">+</span> <span class="n">extra_inputs</span><span class="p">,</span>
                              <span class="n">container</span><span class="o">.</span><span class="n">outputs</span><span class="p">,</span> <span class="n">container</span><span class="o">.</span><span class="n">initializers</span><span class="p">)</span>

    <span class="c1"># Add extra information related to the graph</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">value_info</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">container</span><span class="o">.</span><span class="n">value_info</span><span class="p">)</span>

    <span class="c1"># Create model</span>
    <span class="n">onnx_model</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">make_model</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>

    <span class="c1"># Merge operator sets for the same domain, the largest version</span>
    <span class="c1"># number would be kept</span>
    <span class="n">purified_operator_set</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">op_domain</span><span class="p">,</span> <span class="n">op_version</span> <span class="ow">in</span> <span class="n">container</span><span class="o">.</span><span class="n">node_domain_version_pair_sets</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">op_domain</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">purified_operator_set</span><span class="p">:</span>
            <span class="n">purified_operator_set</span><span class="p">[</span><span class="n">op_domain</span><span class="p">]</span> <span class="o">=</span> <span class="n">op_version</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">purified_operator_set</span><span class="p">[</span><span class="n">op_domain</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                            <span class="n">purified_operator_set</span><span class="p">[</span><span class="n">op_domain</span><span class="p">],</span> <span class="n">op_version</span><span class="p">)</span>

    <span class="c1"># Fill operator sets</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">op_domain</span><span class="p">,</span> <span class="n">op_version</span> <span class="ow">in</span> <span class="n">purified_operator_set</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">onnx_model</span><span class="o">.</span><span class="n">opset_import</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Overwrite the default operator set created by</span>
            <span class="c1"># helper.make_model(...)</span>
            <span class="n">op_set</span> <span class="o">=</span> <span class="n">onnx_model</span><span class="o">.</span><span class="n">opset_import</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Just create one ONNX element in opset_import</span>
            <span class="n">op_set</span> <span class="o">=</span> <span class="n">onnx_model</span><span class="o">.</span><span class="n">opset_import</span><span class="o">.</span><span class="n">add</span><span class="p">()</span>
        <span class="n">op_set</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">op_domain</span>
        <span class="n">op_set</span><span class="o">.</span><span class="n">version</span> <span class="o">=</span> <span class="n">op_version</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">container</span><span class="o">.</span><span class="n">target_opset</span> <span class="o">&lt;</span> <span class="n">op_version</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">((</span><span class="s1">&#39;The specified opset </span><span class="si">%d</span><span class="s1"> is too low to convert &#39;</span>
                                <span class="s1">&#39;this model, which requires at least opset &#39;</span>
                                <span class="s1">&#39;</span><span class="si">%d</span><span class="s1">.&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">container</span><span class="o">.</span><span class="n">target_opset</span><span class="p">,</span> <span class="n">op_version</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">container</span><span class="o">.</span><span class="n">target_opset</span> <span class="o">&gt;</span> <span class="n">op_version</span><span class="p">:</span>
            <span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;skl2onnx&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;The maximum opset needed by this &#39;</span>
                                          <span class="s1">&#39;model is only </span><span class="si">%d</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="n">op_version</span><span class="p">)</span>

    <span class="c1"># Add extra information</span>
    <span class="n">onnx_model</span><span class="o">.</span><span class="n">ir_version</span> <span class="o">=</span> <span class="n">onnx_proto</span><span class="o">.</span><span class="n">IR_VERSION</span>
    <span class="n">onnx_model</span><span class="o">.</span><span class="n">producer_name</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_producer</span><span class="p">()</span>
    <span class="n">onnx_model</span><span class="o">.</span><span class="n">producer_version</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_producer_version</span><span class="p">()</span>
    <span class="n">onnx_model</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_domain</span><span class="p">()</span>
    <span class="n">onnx_model</span><span class="o">.</span><span class="n">model_version</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_model_version</span><span class="p">()</span>
    <span class="n">onnx_model</span><span class="o">.</span><span class="n">doc_string</span> <span class="o">=</span> <span class="n">doc_string</span>

    <span class="k">return</span> <span class="n">onnx_model</span>
</pre></div>
    </div>
  </div>
</div>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.0.0/jquery.min.js"
        integrity="sha384-THPy051/pYDQGanwU6poAc/hOdQxjnOEXzbT+OuUAFqNqFjL+4IGLBgCJC3ZOShY"
        crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tether/1.2.0/js/tether.min.js"
        integrity="sha384-Plbmg8JY28KFelvJVai01l8WyZzrYWG825m+cZ0eDDS1f7d/js6ikvy1+X+guPIB"
        crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.3/js/bootstrap.min.js"
        integrity="sha384-ux8v3A6CPtOTqOzMKiuo3d/DomGaaClxFYdCu2HPMBEkf6x2xiDyJ7gkXU0MWwaD"
        crossorigin="anonymous"></script>
<script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/0.6.0/lunr.min.js"></script>
<script src="../../../_static/searchtools.js"></script>
<script>$('#searchbox').show(0)</script>
</body>
</html>