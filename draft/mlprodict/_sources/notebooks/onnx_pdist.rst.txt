
.. _onnxpdistrst:

====================================
Pairwise distances with ONNX (pdist)
====================================


.. only:: html

    **Links:** :download:`notebook <onnx_pdist.ipynb>`, :downloadlink:`html <onnx_pdist2html.html>`, :download:`PDF <onnx_pdist.pdf>`, :download:`python <onnx_pdist.py>`, :downloadlink:`slides <onnx_pdist.slides.html>`, :githublink:`GitHub|_doc/notebooks/onnx_pdist.ipynb|*`


Function
`pdist <https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.pdist.html>`__
computes pairwise distances between observations in n-dimensional space.
It is not that difficult to convert that into *ONNX* when the dimension
of the input is always the same. What if not?

.. code:: ipython3

    from jyquickhelper import add_notebook_menu
    add_notebook_menu()






.. contents::
    :local:





.. code:: ipython3

    %load_ext mlprodict


.. parsed-literal::
    The mlprodict extension is already loaded. To reload it, use:
      %reload_ext mlprodict


Function pdist
--------------

The function
`pdist <https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.pdist.html>`__
distances. Let’s denote a list of vectors :math:`(X_1, ..., X_n)`,
function
`pdist <https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.pdist.html>`__
returns the matrix :math:`D=(d_{ij})` where
:math:`d_{ij}=dist(X_i, X_j)=\lVert X_i - X_j \rVert^2`.

.. code:: ipython3

    import numpy
    from scipy.spatial.distance import pdist, squareform
    
    M = numpy.array([[0, 1],
                     [1, 2],
                     [0.1, 1.1],
                     [2, 2]], dtype=float)
    
    d1 = squareform(pdist(M, metric='sqeuclidean'))
    d1




.. parsed-literal::
    array([[0.  , 2.  , 0.02, 5.  ],
           [2.  , 0.  , 1.62, 1.  ],
           [0.02, 1.62, 0.  , 4.42],
           [5.  , 1.  , 4.42, 0.  ]])



The two following functions are implemented to reduce the number of
allocations the algorithm requires.

.. code:: ipython3

    def custom_pdist(M):
        n = M.shape[0]
        res = numpy.zeros((n, n))
        buffer = numpy.empty(M.shape)
        for i in range(n):
            numpy.subtract(M, M[i], out=buffer)  # broadcasted substraction
            numpy.square(buffer, out=buffer)
            res[i, :] = numpy.sum(buffer, axis=1)
        return res
    
    d2 = custom_pdist(M)
    d2




.. parsed-literal::
    array([[0.  , 2.  , 0.02, 5.  ],
           [2.  , 0.  , 1.62, 1.  ],
           [0.02, 1.62, 0.  , 4.42],
           [5.  , 1.  , 4.42, 0.  ]])



This function computes :math:`n^2` distances wheres only
:math:`\frac{n(n-1)}{2}` are necessary since the final matrix is
symmetric. Let’s change the implementation to reflect that.

.. code:: ipython3

    def custom_pdist_lower(M):
        n = M.shape[0]
        res = numpy.zeros((n, n))
        buffer = numpy.empty((M.shape[0]-1, M.shape[1]))
        a = numpy.empty(M.shape[0])
        for i in range(1, n):
            numpy.subtract(M[:i], M[i], out=buffer[:i])  # broadcasted substraction
            numpy.square(buffer[:i], out=buffer[:i])
            numpy.sum(buffer[:i], axis=1, out=a[:i])
            res[:i, i] = a[:i]
            res[i, :i] = a[:i]
        return res
    
    d3 = custom_pdist_lower(M)
    d3




.. parsed-literal::
    array([[0.  , 2.  , 0.02, 5.  ],
           [2.  , 0.  , 1.62, 1.  ],
           [0.02, 1.62, 0.  , 4.42],
           [5.  , 1.  , 4.42, 0.  ]])



Loop mechanism in ONNX
----------------------

Operator
`Loop <https://github.com/onnx/onnx/blob/master/docs/Operators.md#Loop>`__
seems appropriate but it is just a loop wheras
`Scan <https://github.com/onnx/onnx/blob/master/docs/Operators.md#Scan>`__
holds accumulator. The first graph is what is repeated inside the loop.

.. code:: ipython3

    from skl2onnx.algebra.onnx_ops import OnnxAdd, OnnxIdentity, OnnxScan
    from skl2onnx.common.data_types import FloatTensorType
    
    initial = numpy.array([0, 0]).astype(numpy.float32).reshape((2,))
    x = numpy.array([1, 2, 3, 4, 5, 6]).astype(numpy.float32).reshape((3, 2))
    
    add_node = OnnxAdd('sum_in', 'next', output_names=['sum_out'], op_version=12)
    id_node = OnnxIdentity(add_node, output_names=['scan_out'], op_version=12)
    
    scan_body = id_node.to_onnx(
        {'sum_in': initial, 'next': initial},
        outputs=[('sum_out', FloatTensorType()),
                 ('scan_out', FloatTensorType())])
    
    # add -l 1 if nothing shows up
    %onnxview scan_body






.. raw:: html

    <div id="Mc52b56326a5f4e29924bee9559edbd58-cont"><div id="Mc52b56326a5f4e29924bee9559edbd58" style="width:;height:;"></div></div>
    <script>

    require(['http://www.xavierdupre.fr/js/vizjs/viz.js'], function() { var svgGraph = Viz("digraph{\n  ranksep=0.25;\n  nodesep=0.05;\n  orientation=portrait;\n  size=7;\n\n  sum_in [shape=box color=red label=\"sum_in\nfloat((0,))\" fontsize=10];\n  next [shape=box color=red label=\"next\nfloat((0,))\" fontsize=10];\n\n  sum_out [shape=box color=green label=\"sum_out\nfloat(('?',))\" fontsize=10];\n  scan_out [shape=box color=green label=\"scan_out\nfloat(('?',))\" fontsize=10];\n\n\n  Ad_Add [shape=box style=\"filled,rounded\" color=orange label=\"Add\n(Ad_Add)\" fontsize=10];\n  sum_in -> Ad_Add;\n  next -> Ad_Add;\n  Ad_Add -> sum_out;\n\n  Id_Identity [shape=box style=\"filled,rounded\" color=orange label=\"Identity\n(Id_Identity)\" fontsize=10];\n  sum_out -> Id_Identity;\n  Id_Identity -> scan_out;\n}");
    document.getElementById('Mc52b56326a5f4e29924bee9559edbd58').innerHTML = svgGraph; });

    </script>



The operator
`Scan <https://github.com/onnx/onnx/blob/master/docs/Operators.md#Scan>`__
repeats this graph a couple of times. *sum_in* is an accumulator, *next*
is the iterated row from the input matrix.

.. code:: ipython3

    node = OnnxScan('initial', 'x', output_names=['y', 'z'],
                    num_scan_inputs=1, body=scan_body.graph)
    
    model_def = node.to_onnx(
        {'initial': initial, 'x': x},
        outputs=[('y', FloatTensorType()),
                 ('z', FloatTensorType())])
    
    # add -l 1 if nothing shows up
    %onnxview model_def






.. raw:: html

    <div id="M8f1590c6985748479d1fa0335194ac96-cont"><div id="M8f1590c6985748479d1fa0335194ac96" style="width:;height:;"></div></div>
    <script>

    require(['http://www.xavierdupre.fr/js/vizjs/viz.js'], function() { var svgGraph = Viz("digraph{\n  ranksep=0.25;\n  nodesep=0.05;\n  orientation=portrait;\n  size=7;\n\n  initial [shape=box color=red label=\"initial\nfloat((0,))\" fontsize=10];\n  x [shape=box color=red label=\"x\nfloat((0, 2))\" fontsize=10];\n\n  y [shape=box color=green label=\"y\nfloat(('?',))\" fontsize=10];\n  z [shape=box color=green label=\"z\nfloat(('?',))\" fontsize=10];\n\n\n  Sc_Scan [shape=box style=\"filled,rounded\" color=orange label=\"Scan\n(Sc_Scan)\nbody=node {\n  input: 'sum_in'\...\nnum_scan_inputs=1\" fontsize=10];\n  initial -> Sc_Scan;\n  x -> Sc_Scan;\n  Sc_Scan -> y;\n  Sc_Scan -> z;\n}");
    document.getElementById('M8f1590c6985748479d1fa0335194ac96').innerHTML = svgGraph; });

    </script>



All together in the same graph.

.. code:: ipython3

    # add -l 1 if nothing shows up
    %onnxview model_def -r 1






.. raw:: html

    <div id="M0d8d5c07e16f4d91afb3576770ce7e80-cont"><div id="M0d8d5c07e16f4d91afb3576770ce7e80" style="width:;height:;"></div></div>
    <script>

    require(['http://www.xavierdupre.fr/js/vizjs/viz.js'], function() { var svgGraph = Viz("digraph{\n  ranksep=0.25;\n  nodesep=0.05;\n  orientation=portrait;\n  size=7;\n\n  initial [shape=box color=red label=\"initial\nfloat((0,))\" fontsize=10];\n  x [shape=box color=red label=\"x\nfloat((0, 2))\" fontsize=10];\n\n  y [shape=box color=green label=\"y\nfloat(('?',))\" fontsize=10];\n  z [shape=box color=green label=\"z\nfloat(('?',))\" fontsize=10];\n\n\n  subgraph cluster_Scan2426022751872_2425401252336 {\n    label=\"Scan\n(Sc_Scan)\nbody=node {\n  input: 'sum_in'\...\nnum_scan_inputs=1\";\n    fontsize=10;\n    color=black;\n    B_sum_in [shape=box color=red label=\"sum_in\nfloat((0,))\" fontsize=10];\n    B_next [shape=box color=red label=\"next\nfloat((0,))\" fontsize=10];\n  \n    B_sum_out [shape=box color=green label=\"sum_out\nfloat(('?',))\" fontsize=10];\n    B_scan_out [shape=box color=green label=\"scan_out\nfloat(('?',))\" fontsize=10];\n  \n  \n    B_Ad_Add [shape=box style=\"filled,rounded\" color=orange label=\"Add\n(Ad_Add)\" fontsize=10];\n    B_sum_in -> B_Ad_Add;\n    B_next -> B_Ad_Add;\n    B_Ad_Add -> B_sum_out;\n  \n    B_Id_Identity [shape=box style=\"filled,rounded\" color=orange label=\"Identity\n(Id_Identity)\" fontsize=10];\n    B_sum_out -> B_Id_Identity;\n    B_Id_Identity -> B_scan_out;\n  }\n  initial -> B_sum_in;\n  x -> B_next;\n  B_sum_out -> y;\n  B_scan_out -> z;\n  Sc_Scan -> B_Ad_Add [lhead=cluster_Scan2426022751872_2425401252336];\n  initial -> Sc_Scan;\n  x -> Sc_Scan;\n  Sc_Scan -> y;\n  Sc_Scan -> z;\n}");
    document.getElementById('M0d8d5c07e16f4d91afb3576770ce7e80').innerHTML = svgGraph; });

    </script>



.. code:: ipython3

    from mlprodict.onnxrt import OnnxInference
    oinf = OnnxInference(model_def)
    res = oinf.run({'initial': initial, 'x': x})
    res['y']




.. parsed-literal::
    array([ 9., 12.], dtype=float32)



.. code:: ipython3

    res['z']




.. parsed-literal::
    array([[ 1.,  2.],
           [ 4.,  6.],
           [ 9., 12.]], dtype=float32)



Back to pdist
-------------

`sklearn-onnx <https://github.com/onnx/sklearn-onnx>`__ implements
function *pdist* with *ONNX* operators. The parameter
``inputs=[('x', FloatTensorType())`` tels the method ``to_onnx`` that
the dimension of the inputs is not fixed and should not be checked.

.. code:: ipython3

    # from skl2onnx.algebra.complex_functions import squareform_pdist_
    
    from collections import OrderedDict
    from skl2onnx.algebra.onnx_ops import (
        OnnxSub, OnnxReduceSumSquare, OnnxSqueeze,
        OnnxIdentity, OnnxScan)
    from skl2onnx.common.data_types import FloatTensorType
    from mlprodict.tools import get_opset_number_from_onnx
    
    
    def squareform_pdist(X, **kwargs):
        """Returns the ONNX graph which computes
        ``squareform(pdist(X, metric='sqeuclidean')``."""
    
        # The subgraph executed at every iteration.
        opv = get_opset_number_from_onnx()
        diff = OnnxSub('next_in', 'next', output_names=['diff'], op_version=opv)
        id_next = OnnxIdentity('next_in', output_names=['next_out'], op_version=opv)
        norm = OnnxReduceSumSquare(diff, output_names=['norm'], axes=[1], op_version=opv)
        flat = OnnxSqueeze(norm, numpy.array([1], dtype=numpy.int64),
                           output_names=['scan_out'], op_version=opv)
        scan_body = id_next.to_onnx(
            OrderedDict([('next_in', FloatTensorType()),
                         ('next', FloatTensorType())]),
            # Size must be empty otherwise onnxruntime fails
            # at execution time if it receives a matrix
            # with a different shape. With 'None', the same ONNX graph
            # can compute pairwise distance for any shape.
            outputs=[('next_out', FloatTensorType([None, None])),
                     ('scan_out', FloatTensorType([None]))],
            other_outputs=[flat])
    
        # The loop.
        # 'scan0_{idself}' means the variable name will include
        # id(OnnxScan), this is needed if squareform_pdist is used
        # twice in the same graph.
        node = OnnxScan(X, X, output_names=['scan0_{idself}', 'scan1_{idself}'],
                        num_scan_inputs=1, body=scan_body.graph, op_version=opv,
                        **kwargs)
        return node[1]    
    
    opv = get_opset_number_from_onnx()
    onnx_fct = OnnxIdentity(squareform_pdist('x'), output_names='Y', op_version=opv)
    model_def = onnx_fct.to_onnx(inputs=[('x', FloatTensorType())])
    
    # add -l 1 if nothing shows up
    %onnxview model_def






.. raw:: html

    <div id="Mff995610d98f44daaa9a68202db64f19-cont"><div id="Mff995610d98f44daaa9a68202db64f19" style="width:;height:;"></div></div>
    <script>

    require(['http://www.xavierdupre.fr/js/vizjs/viz.js'], function() { var svgGraph = Viz("digraph{\n  ranksep=0.25;\n  nodesep=0.05;\n  orientation=portrait;\n  size=7;\n\n  x [shape=box color=red label=\"x\nfloat(('?',))\" fontsize=10];\n\n  Y [shape=box color=green label=\"Y\nfloat((0, 0))\" fontsize=10];\n\n\n  scan0_{idself} [shape=box label=\"scan0_{idself}\" fontsize=10];\n  scan1_{idself} [shape=box label=\"scan1_{idself}\" fontsize=10];\n  Sc_Scan [shape=box style=\"filled,rounded\" color=orange label=\"Scan\n(Sc_Scan)\nbody=node {\n  input: 'next_in'...\nnum_scan_inputs=1\" fontsize=10];\n  x -> Sc_Scan;\n  x -> Sc_Scan;\n  Sc_Scan -> scan0_{idself};\n  Sc_Scan -> scan1_{idself};\n\n  Id_Identity1 [shape=box style=\"filled,rounded\" color=orange label=\"Identity\n(Id_Identity1)\" fontsize=10];\n  scan1_{idself} -> Id_Identity1;\n  Id_Identity1 -> Y;\n}");
    document.getElementById('Mff995610d98f44daaa9a68202db64f19').innerHTML = svgGraph; });

    </script>



.. code:: ipython3

    from collections import OrderedDict
    from skl2onnx.algebra.onnx_ops import (
        OnnxSub, OnnxReduceSumSquare, OnnxSqueeze,
        OnnxIdentity, OnnxScan)
    from skl2onnx.common.data_types import FloatTensorType
    from mlprodict.tools import get_opset_number_from_onnx
    
    
    def squareform_pdist(X, **kwargs):
        # The subgraph executed at every iteration.
        opv = get_opset_number_from_onnx()
        diff = OnnxSub('next_in', 'next', output_names=['diff'], op_version=opv)
        id_next = OnnxIdentity('next_in', output_names=['next_out'], op_version=opv)
        norm = OnnxReduceSumSquare(diff, output_names=['norm'], axes=[1], op_version=opv)
        flat = OnnxSqueeze(norm, numpy.array([1], dtype=numpy.int64),
                           output_names=['scan_out'], op_version=opv)
        scan_body = id_next.to_onnx(
            OrderedDict([('next_in', FloatTensorType()),
                         ('next', FloatTensorType())]),
            outputs=[('next_out', FloatTensorType([None, None])),
                     ('scan_out', FloatTensorType([None]))],
            other_outputs=[flat])
    
        # The loop.
        node = OnnxScan(X, X, output_names=['scan0_{idself}', 'scan1_{idself}'],
                        num_scan_inputs=1, body=scan_body.graph, op_version=opv,
                        **kwargs)
        return node[1]    
    
    opv = get_opset_number_from_onnx()
    onnx_fct = OnnxIdentity(squareform_pdist('x'), output_names='Y', op_version=opv)
    model_def = onnx_fct.to_onnx(inputs=[('x', FloatTensorType())])

Notice the double arrow. Input *x* is used twice, once as an permanent
state involved in broacasted substract, another time to iterator rows.
On the other side, the first output of operator *Scan* is a permanent
state equal to the input, the second one is an aggregation of results
produced at each iteration. Each of those produces a row of a final
matrix.

.. code:: ipython3

    oinf = OnnxInference(model_def)
    body = oinf['Sc_Scan', 'body']
    
    # add -l 1 if nothing shows up
    %onnxview body.g






.. raw:: html

    <div id="Mb1efdaea083f436fb803ae6b1b5b4be9-cont"><div id="Mb1efdaea083f436fb803ae6b1b5b4be9" style="width:;height:;"></div></div>
    <script>

    require(['http://www.xavierdupre.fr/js/vizjs/viz.js'], function() { var svgGraph = Viz("digraph{\n  ranksep=0.25;\n  nodesep=0.05;\n  orientation=portrait;\n  size=7;\n\n  next_in [shape=box color=red label=\"next_in\nfloat(('?',))\" fontsize=10];\n  next [shape=box color=red label=\"next\nfloat(('?',))\" fontsize=10];\n\n  next_out [shape=box color=green label=\"next_out\nfloat((0, 0))\" fontsize=10];\n  scan_out [shape=box color=green label=\"scan_out\nfloat((0,))\" fontsize=10];\n\n  Sq_Squeezecst [shape=box label=\"Sq_Squeezecst\nint64((1,))\n[1]\" fontsize=10];\n\n  Id_Identity [shape=box style=\"filled,rounded\" color=orange label=\"Identity\n(Id_Identity)\" fontsize=10];\n  next_in -> Id_Identity;\n  Id_Identity -> next_out;\n\n  diff [shape=box label=\"diff\" fontsize=10];\n  Su_Sub [shape=box style=\"filled,rounded\" color=orange label=\"Sub\n(Su_Sub)\" fontsize=10];\n  next_in -> Su_Sub;\n  next -> Su_Sub;\n  Su_Sub -> diff;\n\n  norm [shape=box label=\"norm\" fontsize=10];\n  Re_ReduceSumSquare [shape=box style=\"filled,rounded\" color=orange label=\"ReduceSumSquare\n(Re_ReduceSumSquare)\naxes=[1]\" fontsize=10];\n  diff -> Re_ReduceSumSquare;\n  Re_ReduceSumSquare -> norm;\n\n  Sq_Squeeze [shape=box style=\"filled,rounded\" color=orange label=\"Squeeze\n(Sq_Squeeze)\" fontsize=10];\n  norm -> Sq_Squeeze;\n  Sq_Squeezecst -> Sq_Squeeze;\n  Sq_Squeeze -> scan_out;\n}");
    document.getElementById('Mb1efdaea083f436fb803ae6b1b5b4be9').innerHTML = svgGraph; });

    </script>



All together.

.. code:: ipython3

    # add -l 1 if nothing shows up
    %onnxview model_def -r 1






.. raw:: html

    <div id="M4a0522103b1445a49a4a0095e36c397b-cont"><div id="M4a0522103b1445a49a4a0095e36c397b" style="width:;height:;"></div></div>
    <script>

    require(['http://www.xavierdupre.fr/js/vizjs/viz.js'], function() { var svgGraph = Viz("digraph{\n  ranksep=0.25;\n  nodesep=0.05;\n  orientation=portrait;\n  size=7;\n\n  x [shape=box color=red label=\"x\nfloat(('?',))\" fontsize=10];\n\n  Y [shape=box color=green label=\"Y\nfloat((0, 0))\" fontsize=10];\n\n\n  scan0_{idself} [shape=box label=\"scan0_{idself}\" fontsize=10];\n  scan1_{idself} [shape=box label=\"scan1_{idself}\" fontsize=10];\n  subgraph cluster_Scan2426056374688_2425401252336 {\n    label=\"Scan\n(Sc_Scan)\nbody=node {\n  input: 'next_in'...\nnum_scan_inputs=1\";\n    fontsize=10;\n    color=black;\n    B_next_in [shape=box color=red label=\"next_in\nfloat(('?',))\" fontsize=10];\n    B_next [shape=box color=red label=\"next\nfloat(('?',))\" fontsize=10];\n  \n    B_next_out [shape=box color=green label=\"next_out\nfloat((0, 0))\" fontsize=10];\n    B_scan_out [shape=box color=green label=\"scan_out\nfloat((0,))\" fontsize=10];\n  \n    B_Sq_Squeezecst [shape=box label=\"Sq_Squeezecst\nint64((1,))\n[1]\" fontsize=10];\n  \n    B_Id_Identity [shape=box style=\"filled,rounded\" color=orange label=\"Identity\n(Id_Identity)\" fontsize=10];\n    B_next_in -> B_Id_Identity;\n    B_Id_Identity -> B_next_out;\n  \n    B_diff [shape=box label=\"diff\" fontsize=10];\n    B_Su_Sub [shape=box style=\"filled,rounded\" color=orange label=\"Sub\n(Su_Sub)\" fontsize=10];\n    B_next_in -> B_Su_Sub;\n    B_next -> B_Su_Sub;\n    B_Su_Sub -> B_diff;\n  \n    B_norm [shape=box label=\"norm\" fontsize=10];\n    B_Re_ReduceSumSquare [shape=box style=\"filled,rounded\" color=orange label=\"ReduceSumSquare\n(Re_ReduceSumSquare)\naxes=[1]\" fontsize=10];\n    B_diff -> B_Re_ReduceSumSquare;\n    B_Re_ReduceSumSquare -> B_norm;\n  \n    B_Sq_Squeeze [shape=box style=\"filled,rounded\" color=orange label=\"Squeeze\n(Sq_Squeeze)\" fontsize=10];\n    B_norm -> B_Sq_Squeeze;\n    B_Sq_Squeezecst -> B_Sq_Squeeze;\n    B_Sq_Squeeze -> B_scan_out;\n  }\n  x -> B_next_in;\n  x -> B_next;\n  B_next_out -> scan0_{idself};\n  B_scan_out -> scan1_{idself};\n  Sc_Scan -> B_Id_Identity [lhead=cluster_Scan2426056374688_2425401252336];\n  x -> Sc_Scan;\n  x -> Sc_Scan;\n  Sc_Scan -> scan0_{idself};\n  Sc_Scan -> scan1_{idself};\n\n  Id_Identity1 [shape=box style=\"filled,rounded\" color=orange label=\"Identity\n(Id_Identity1)\" fontsize=10];\n  scan1_{idself} -> Id_Identity1;\n  Id_Identity1 -> Y;\n}");
    document.getElementById('M4a0522103b1445a49a4a0095e36c397b').innerHTML = svgGraph; });

    </script>



Let’s now execute the graph and compare it with the original graph.

.. code:: ipython3

    d1 = squareform(pdist(M, metric='sqeuclidean'))
    d1




.. parsed-literal::
    array([[0.  , 2.  , 0.02, 5.  ],
           [2.  , 0.  , 1.62, 1.  ],
           [0.02, 1.62, 0.  , 4.42],
           [5.  , 1.  , 4.42, 0.  ]])



.. code:: ipython3

    oinf.run({'x': M})['Y']




.. parsed-literal::
    array([[0.  , 2.  , 0.02, 5.  ],
           [2.  , 0.  , 1.62, 1.  ],
           [0.02, 1.62, 0.  , 4.42],
           [5.  , 1.  , 4.42, 0.  ]])



.. code:: ipython3

    %timeit squareform(pdist(M, metric='sqeuclidean'))


.. parsed-literal::
    9.31 µs ± 423 ns per loop (mean ± std. dev. of 7 runs, 100,000 loops each)


.. code:: ipython3

    %timeit custom_pdist(M)


.. parsed-literal::
    35.1 µs ± 1.52 µs per loop (mean ± std. dev. of 7 runs, 10,000 loops each)


.. code:: ipython3

    %timeit custom_pdist_lower(M)


.. parsed-literal::
    34.2 µs ± 2.18 µs per loop (mean ± std. dev. of 7 runs, 10,000 loops each)


.. code:: ipython3

    %timeit oinf.run({'x': M})['Y']


.. parsed-literal::
    177 µs ± 11.3 µs per loop (mean ± std. dev. of 7 runs, 10,000 loops each)


.. code:: ipython3

    M32 = M.astype(numpy.float32)

.. code:: ipython3

    from mlprodict.tools import get_ir_version_from_onnx
    model_def.ir_version = get_ir_version_from_onnx()

.. code:: ipython3

    oinfrt = OnnxInference(model_def, runtime="onnxruntime1")
    oinfrt.run({'x': M32})['Y']


.. parsed-literal::
    No CUDA runtime is found, using CUDA_HOME='C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.5'




.. parsed-literal::

    array([[0.        , 2.        , 0.02000001, 5.        ],
           [2.        , 0.        , 1.6199999 , 1.        ],
           [0.02000001, 1.6199999 , 0.        , 4.42      ],
           [5.        , 1.        , 4.42      , 0.        ]], dtype=float32)



.. code:: ipython3

    %timeit oinfrt.run({'x': M32})['Y']


.. parsed-literal::
    43.1 µs ± 4.32 µs per loop (mean ± std. dev. of 7 runs, 10,000 loops each)


Benchmark
---------

.. code:: ipython3

    from timeit import Timer
    
    
    def measure_time(name, stmt, context, repeat=10, number=10):
        tim = Timer(stmt, globals=context)
        res = numpy.array(tim.repeat(repeat=repeat, number=number))
        res /= number
        mean = numpy.mean(res)
        dev = numpy.mean(res ** 2)
        dev = (dev - mean**2) ** 0.5
        return dict(average=mean, deviation=dev, min_exec=numpy.min(res),
                    max_exec=numpy.max(res), repeat=repeat, number=number,
                    nrows=context['M'].shape[0], ncols=context['M'].shape[1],
                    name=name)
    
    measure_time("scipy", "squareform(pdist(M, metric='sqeuclidean'))",
                 context={'squareform': squareform, 'M': M,
                          'pdist': pdist})




.. parsed-literal::
    {'average': 4.233300000009876e-05,
     'deviation': 2.7235873787981297e-05,
     'min_exec': 1.8629999999575375e-05,
     'max_exec': 0.00010153999999999997,
     'repeat': 10,
     'number': 10,
     'nrows': 4,
     'ncols': 2,
     'name': 'scipy'}



.. code:: ipython3

    from tqdm import trange
    
    def generator():
        for feat in [5, 10, 50, 100]:
            for n in [5, 10, 20, 50, 100, 400, 1000]:
                if n <= 500 or feat <= 10:
                    yield feat, n
                
    all_values = list(generator())
    
    rows = []
    
    with trange(len(all_values)) as t:
        for i in t:        
            feat, n = all_values[i]
            t.set_description("feat=%d n=%d" % (feat, n))
            M = numpy.random.rand(n, feat)
    
            context = {'squareform': squareform, 'M': M, 'pdist': pdist}
            res = measure_time("scipy", "squareform(pdist(M, metric='sqeuclidean'))", context=context)
            res['dimres'] = squareform(pdist(M, metric='sqeuclidean')).shape[0]
            rows.append(res)
    
            context = {'M': M, 'custom_pdist': custom_pdist}
            res = measure_time("numpy", "custom_pdist(M)", context=context)
            res['dimres'] = custom_pdist(M).shape[0]
            rows.append(res)
    
            context = {'M': M, 'custom_pdist_lower': custom_pdist_lower}
            res = measure_time("numpy-lower", "custom_pdist_lower(M)", context=context)
            res['dimres'] = custom_pdist_lower(M).shape[0]
            rows.append(res)
    
            context = {'oinf': oinf, 'M': M}
            res = measure_time("onnx-py", "oinf.run({'x': M})['Y']", context=context)
            res['dimres'] = oinf.run({'x': M})['Y'].shape[0]
            rows.append(res)
    
            M32 = M.astype(numpy.float32)
            context = {'oinfrt': oinfrt, 'M': M32}
            res = measure_time("onnx-rt", "oinfrt.run({'x': M})['Y']", context=context)
            res['dimres'] = oinfrt.run({'x': M32})['Y'].shape[0]
            rows.append(res)
    
        
    from pandas import DataFrame
    df = DataFrame(rows)
    df.head()


.. parsed-literal::
    feat=100 n=400: 100%|██████████| 26/26 [01:20<00:00,  3.10s/it]






.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }

        .dataframe tbody tr th {
            vertical-align: top;
        }

        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>average</th>
          <th>deviation</th>
          <th>min_exec</th>
          <th>max_exec</th>
          <th>repeat</th>
          <th>number</th>
          <th>nrows</th>
          <th>ncols</th>
          <th>name</th>
          <th>dimres</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>0.000015</td>
          <td>0.000005</td>
          <td>0.000010</td>
          <td>0.000025</td>
          <td>10</td>
          <td>10</td>
          <td>5</td>
          <td>5</td>
          <td>scipy</td>
          <td>5</td>
        </tr>
        <tr>
          <th>1</th>
          <td>0.000106</td>
          <td>0.000023</td>
          <td>0.000065</td>
          <td>0.000138</td>
          <td>10</td>
          <td>10</td>
          <td>5</td>
          <td>5</td>
          <td>numpy</td>
          <td>5</td>
        </tr>
        <tr>
          <th>2</th>
          <td>0.000053</td>
          <td>0.000005</td>
          <td>0.000048</td>
          <td>0.000064</td>
          <td>10</td>
          <td>10</td>
          <td>5</td>
          <td>5</td>
          <td>numpy-lower</td>
          <td>5</td>
        </tr>
        <tr>
          <th>3</th>
          <td>0.000240</td>
          <td>0.000017</td>
          <td>0.000219</td>
          <td>0.000273</td>
          <td>10</td>
          <td>10</td>
          <td>5</td>
          <td>5</td>
          <td>onnx-py</td>
          <td>5</td>
        </tr>
        <tr>
          <th>4</th>
          <td>0.000053</td>
          <td>0.000008</td>
          <td>0.000046</td>
          <td>0.000072</td>
          <td>10</td>
          <td>10</td>
          <td>5</td>
          <td>5</td>
          <td>onnx-rt</td>
          <td>5</td>
        </tr>
      </tbody>
    </table>
    </div>



.. code:: ipython3

    from pandas import pivot_table
    piv = pivot_table(df, index=["nrows"], columns= ['ncols', 'name'], values='average')
    piv.head().T






.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }

        .dataframe tbody tr th {
            vertical-align: top;
        }

        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>nrows</th>
          <th>5</th>
          <th>10</th>
          <th>20</th>
          <th>50</th>
          <th>100</th>
        </tr>
        <tr>
          <th>ncols</th>
          <th>name</th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th rowspan="5" valign="top">5</th>
          <th>numpy</th>
          <td>0.000106</td>
          <td>0.000108</td>
          <td>0.000193</td>
          <td>0.000464</td>
          <td>0.001121</td>
        </tr>
        <tr>
          <th>numpy-lower</th>
          <td>0.000053</td>
          <td>0.000099</td>
          <td>0.000225</td>
          <td>0.000520</td>
          <td>0.001190</td>
        </tr>
        <tr>
          <th>onnx-py</th>
          <td>0.000240</td>
          <td>0.000407</td>
          <td>0.000797</td>
          <td>0.002581</td>
          <td>0.003790</td>
        </tr>
        <tr>
          <th>onnx-rt</th>
          <td>0.000053</td>
          <td>0.000071</td>
          <td>0.000118</td>
          <td>0.000306</td>
          <td>0.000766</td>
        </tr>
        <tr>
          <th>scipy</th>
          <td>0.000015</td>
          <td>0.000011</td>
          <td>0.000014</td>
          <td>0.000020</td>
          <td>0.000044</td>
        </tr>
        <tr>
          <th rowspan="5" valign="top">10</th>
          <th>numpy</th>
          <td>0.000067</td>
          <td>0.000094</td>
          <td>0.000194</td>
          <td>0.000569</td>
          <td>0.001441</td>
        </tr>
        <tr>
          <th>numpy-lower</th>
          <td>0.000044</td>
          <td>0.000093</td>
          <td>0.000189</td>
          <td>0.000591</td>
          <td>0.001209</td>
        </tr>
        <tr>
          <th>onnx-py</th>
          <td>0.000226</td>
          <td>0.000379</td>
          <td>0.000751</td>
          <td>0.001945</td>
          <td>0.004731</td>
        </tr>
        <tr>
          <th>onnx-rt</th>
          <td>0.000048</td>
          <td>0.000072</td>
          <td>0.000144</td>
          <td>0.000329</td>
          <td>0.000995</td>
        </tr>
        <tr>
          <th>scipy</th>
          <td>0.000013</td>
          <td>0.000013</td>
          <td>0.000016</td>
          <td>0.000023</td>
          <td>0.000071</td>
        </tr>
        <tr>
          <th rowspan="5" valign="top">50</th>
          <th>numpy</th>
          <td>0.000084</td>
          <td>0.000114</td>
          <td>0.000257</td>
          <td>0.000833</td>
          <td>0.002031</td>
        </tr>
        <tr>
          <th>numpy-lower</th>
          <td>0.000069</td>
          <td>0.000114</td>
          <td>0.000272</td>
          <td>0.000757</td>
          <td>0.001749</td>
        </tr>
        <tr>
          <th>onnx-py</th>
          <td>0.000323</td>
          <td>0.000480</td>
          <td>0.001214</td>
          <td>0.002648</td>
          <td>0.006138</td>
        </tr>
        <tr>
          <th>onnx-rt</th>
          <td>0.000059</td>
          <td>0.000091</td>
          <td>0.000179</td>
          <td>0.000554</td>
          <td>0.001614</td>
        </tr>
        <tr>
          <th>scipy</th>
          <td>0.000016</td>
          <td>0.000016</td>
          <td>0.000027</td>
          <td>0.000088</td>
          <td>0.000200</td>
        </tr>
        <tr>
          <th rowspan="5" valign="top">100</th>
          <th>numpy</th>
          <td>0.000068</td>
          <td>0.000098</td>
          <td>0.000262</td>
          <td>0.000759</td>
          <td>0.002712</td>
        </tr>
        <tr>
          <th>numpy-lower</th>
          <td>0.000061</td>
          <td>0.000108</td>
          <td>0.000338</td>
          <td>0.000666</td>
          <td>0.002270</td>
        </tr>
        <tr>
          <th>onnx-py</th>
          <td>0.000261</td>
          <td>0.000451</td>
          <td>0.001082</td>
          <td>0.002272</td>
          <td>0.007142</td>
        </tr>
        <tr>
          <th>onnx-rt</th>
          <td>0.000050</td>
          <td>0.000084</td>
          <td>0.000166</td>
          <td>0.000672</td>
          <td>0.002097</td>
        </tr>
        <tr>
          <th>scipy</th>
          <td>0.000017</td>
          <td>0.000019</td>
          <td>0.000025</td>
          <td>0.000089</td>
          <td>0.000327</td>
        </tr>
      </tbody>
    </table>
    </div>



.. code:: ipython3

    %matplotlib inline

.. code:: ipython3

    import matplotlib.pyplot as plt
    fig, ax = plt.subplots(1, 3, figsize=(14, 3))
    for i, ncol in enumerate([10, 50, 100]):
        piv = df[df.ncols==ncol].pivot("nrows", "name", "average")
        piv.plot(ax=ax[i], logy=True, logx=True)
        ax[i].set_title("ncol=%d" % ncol)
    ax;



.. image:: onnx_pdist_40_0.png


Curves are not linear and rather difficult to interpret. The algorithm
*numpy-lower* and *scipy* should be close as the cost of both algorithm
are similar. However, *scipy* reduces the number of trips between C and
python. The C implementation of the distance is here:
`sqeuclidean_distance_double <https://github.com/scipy/scipy/blob/master/scipy/spatial/src/distance_impl.h#L50>`__.
The final cost is a combination of computation, multithreading,
allocations…

.. code:: ipython3

    from pyquickhelper.pycode.profiling import profile
    M = numpy.random.rand(100, 10)
    
    pr1, df1 = profile(lambda: [squareform(pdist(M, metric='sqeuclidean')) for i in range(0, 1000)],
                       as_df=True)
    pr2, df2 = profile(lambda: [custom_pdist_lower(M) for i in range(0, 1000)], as_df=True)

.. code:: ipython3

    ax = df1[['namefct', 'cum_tall']].head(n=15).set_index('namefct').plot(
        kind='bar', figsize=(8, 3), rot=30)
    ax.set_title("scipy")
    for la in ax.get_xticklabels():
        la.set_horizontalalignment('right')



.. image:: onnx_pdist_43_0.png


.. code:: ipython3

    ax = df2[['namefct', 'cum_tall']].head(n=15).set_index('namefct').plot(
        kind='bar', figsize=(8, 3), rot=30)
    ax.set_title("numpy-lower")
    for la in ax.get_xticklabels():
        la.set_horizontalalignment('right');    



.. image:: onnx_pdist_44_0.png


`Universal
function <https://docs.scipy.org/doc/numpy/reference/ufuncs.html>`__ do
not seem to be very efficient in our case. The last graph shows time
ratio between implementations of *pdist* and the baseline *scipy*.

.. code:: ipython3

    fig, ax = plt.subplots(1, 3, figsize=(14, 3))
    for i, ncol in enumerate([10, 50, 100]):
        piv = df[df.ncols==ncol].pivot("nrows", "name", "average")
        piv['numpy / scipy'] = piv['numpy'] / piv['scipy']
        piv['numpy-lower / scipy'] = piv['numpy-lower'] / piv['scipy']
        piv['onnx-py / scipy'] = piv['onnx-py'] / piv['scipy']
        piv['onnx-rt / scipy'] = piv['onnx-rt'] / piv['scipy']
        piv = piv[['numpy / scipy', 'numpy-lower / scipy', 
                   'onnx-py / scipy', 'onnx-rt / scipy']]
        piv.plot(ax=ax[i], logy=True, logx=True)
        ax[i].plot([0, max(piv.index)], [1, 1], '--', color='black')
        ax[i].plot([0, max(piv.index)], [10, 10], '--', color='black')
        ax[i].set_title("ncol=%d" % ncol)
    ax;



.. image:: onnx_pdist_46_0.png


Test with a new operator CDist
------------------------------

The final question is: *should we introduce a new operator into*\ `ONNX
specifications <https://github.com/onnx/onnx/blob/master/docs/Operators.md>`__\ *?*
The function
`pdist <https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.pdist.html>`__
is not necessarily often used for a big number of observations as the
square matrix it produces will even bigger. It seems reasonable. We
showed that a python runtime based on *numpy* would not help, the
implementation must be done in C++ or directly used the *scipy* version.
The experiment was done with a
`GaussianProcessRegressor <https://scikit-learn.org/stable/modules/generated/sklearn.gaussian_process.GaussianProcessRegressor.html>`__.
The following section tests with and without a new operator ``CDist``
reusing *scipy* implementation.

.. code:: ipython3

    import numpy
    from sklearn.datasets import load_iris
    from sklearn.model_selection import train_test_split
    from sklearn.gaussian_process import GaussianProcessRegressor
    from sklearn.gaussian_process.kernels import ExpSineSquared
    from mlprodict.onnx_conv import to_onnx
    from mlprodict.onnxrt import OnnxInference
    
    
    iris = load_iris()
    X, y = iris.data, iris.target
    X_train, X_test, y_train, __ = train_test_split(X, y, random_state=12)
    clr = GaussianProcessRegressor(ExpSineSquared(), alpha=20.)
    clr.fit(X_train, y_train)
    
    model_def = to_onnx(clr, X_train)
    
    %onnxview model_def -r 1






.. raw:: html

    <div id="Mbbc9e417c1334598b429aad877e320b3-cont"><div id="Mbbc9e417c1334598b429aad877e320b3" style="width:;height:;"></div></div>
    <script>

    require(['http://www.xavierdupre.fr/js/vizjs/viz.js'], function() { var svgGraph = Viz("digraph{\n  ranksep=0.25;\n  nodesep=0.05;\n  orientation=portrait;\n  size=7;\n\n  X [shape=box color=red label=\"X\ndouble((0, 4))\" fontsize=10];\n\n  GPmean [shape=box color=green label=\"GPmean\ndouble((0, 1))\" fontsize=10];\n\n  Sc_Scancst [shape=box label=\"Sc_Scancst\nfloat64((112, 4))\n[[5.8 4.  1.2 0.2]\n [6.  2.2 4.  1. ]\n [5.1 2.5 3....\" fontsize=10];\n  kgpd_Divcst [shape=box label=\"kgpd_Divcst\nfloat64((1,))\n[1.83052462]\" fontsize=10];\n  kgpd_Mulcst [shape=box label=\"kgpd_Mulcst\nfloat64((1,))\n[3.14159265]\" fontsize=10];\n  kgpd_Divcst1 [shape=box label=\"kgpd_Divcst1\nfloat64((1,))\n[1014.92199796]\" fontsize=10];\n  kgpd_Powcst [shape=box label=\"kgpd_Powcst\nfloat64((1,))\n[2.]\" fontsize=10];\n  kgpd_Mulcst1 [shape=box label=\"kgpd_Mulcst1\nfloat64((1,))\n[-2.]\" fontsize=10];\n  gpr_MatMulcst [shape=box label=\"gpr_MatMulcst\nfloat64((112,))\n[-0.0439394   0.00606057  0.00606066 -0.0439394  -...\" fontsize=10];\n  gpr_Addcst [shape=box label=\"gpr_Addcst\nfloat64((1, 1))\n[[0.]]\" fontsize=10];\n  Re_Reshapecst [shape=box label=\"Re_Reshapecst\nint64((2,))\n[-1  1]\" fontsize=10];\n\n  UU000UU [shape=box label=\"UU000UU\" fontsize=10];\n  UU001UU [shape=box label=\"UU001UU\" fontsize=10];\n  subgraph cluster_Scan2426386645440_2425401252336 {\n    label=\"Scan\n(Sc_Scan)\nbody=node {\n  input: 'next_in'...\nnum_scan_inputs=1\";\n    fontsize=10;\n    color=black;\n    B_next_in [shape=box color=red label=\"next_in\ndouble((0, 0))\" fontsize=10];\n    B_next [shape=box color=red label=\"next\ndouble((0,))\" fontsize=10];\n  \n    B_next_out [shape=box color=green label=\"next_out\ndouble((0, 0))\" fontsize=10];\n    B_scan_out [shape=box color=green label=\"scan_out\ndouble((0,))\" fontsize=10];\n  \n  \n    B_cdistdf_1_C0 [shape=box label=\"cdistdf_1_C0\" fontsize=10];\n    B_cdistdf_1_Sub [shape=box style=\"filled,rounded\" color=orange label=\"Sub\n(cdistdf_1_Sub)\" fontsize=10];\n    B_next_in -> B_cdistdf_1_Sub;\n    B_next -> B_cdistdf_1_Sub;\n    B_cdistdf_1_Sub -> B_cdistdf_1_C0;\n  \n    B_cdistd_1_Identity [shape=box style=\"filled,rounded\" color=orange label=\"Identity\n(cdistd_1_Identity)\" fontsize=10];\n    B_next_in -> B_cdistd_1_Identity;\n    B_cdistd_1_Identity -> B_next_out;\n  \n    B_cdistdf_1_reduced0 [shape=box label=\"cdistdf_1_reduced0\" fontsize=10];\n    B_cdistdf_1_ReduceSumSquare [shape=box style=\"filled,rounded\" color=orange label=\"ReduceSumSquare\n(cdistdf_1_ReduceSumSquare)\naxes=[1]\nkeepdims=0\" fontsize=10];\n    B_cdistdf_1_C0 -> B_cdistdf_1_ReduceSumSquare;\n    B_cdistdf_1_ReduceSumSquare -> B_cdistdf_1_reduced0;\n  \n    B_cdistdf_1_Identity [shape=box style=\"filled,rounded\" color=orange label=\"Identity\n(cdistdf_1_Identity)\" fontsize=10];\n    B_cdistdf_1_reduced0 -> B_cdistdf_1_Identity;\n    B_cdistdf_1_Identity -> B_scan_out;\n  }\n  X -> B_next_in;\n  Sc_Scancst -> B_next;\n  B_next_out -> UU000UU;\n  B_scan_out -> UU001UU;\n  Sc_Scan -> B_cdistdf_1_Sub [lhead=cluster_Scan2426386645440_2425401252336];\n  X -> Sc_Scan;\n  Sc_Scancst -> Sc_Scan;\n  Sc_Scan -> UU000UU;\n  Sc_Scan -> UU001UU;\n\n  kgpd_transposed0 [shape=box label=\"kgpd_transposed0\" fontsize=10];\n  kgpd_Transpose [shape=box style=\"filled,rounded\" color=orange label=\"Transpose\n(kgpd_Transpose)\nperm=[1 0]\" fontsize=10];\n  UU001UU -> kgpd_Transpose;\n  kgpd_Transpose -> kgpd_transposed0;\n\n  kgpd_Y0 [shape=box label=\"kgpd_Y0\" fontsize=10];\n  kgpd_Sqrt [shape=box style=\"filled,rounded\" color=orange label=\"Sqrt\n(kgpd_Sqrt)\" fontsize=10];\n  kgpd_transposed0 -> kgpd_Sqrt;\n  kgpd_Sqrt -> kgpd_Y0;\n\n  kgpd_C03 [shape=box label=\"kgpd_C03\" fontsize=10];\n  kgpd_Div [shape=box style=\"filled,rounded\" color=orange label=\"Div\n(kgpd_Div)\" fontsize=10];\n  kgpd_Y0 -> kgpd_Div;\n  kgpd_Divcst -> kgpd_Div;\n  kgpd_Div -> kgpd_C03;\n\n  kgpd_C02 [shape=box label=\"kgpd_C02\" fontsize=10];\n  kgpd_Mul [shape=box style=\"filled,rounded\" color=orange label=\"Mul\n(kgpd_Mul)\" fontsize=10];\n  kgpd_C03 -> kgpd_Mul;\n  kgpd_Mulcst -> kgpd_Mul;\n  kgpd_Mul -> kgpd_C02;\n\n  kgpd_output02 [shape=box label=\"kgpd_output02\" fontsize=10];\n  kgpd_Sin [shape=box style=\"filled,rounded\" color=orange label=\"Sin\n(kgpd_Sin)\" fontsize=10];\n  kgpd_C02 -> kgpd_Sin;\n  kgpd_Sin -> kgpd_output02;\n\n  kgpd_C01 [shape=box label=\"kgpd_C01\" fontsize=10];\n  kgpd_Div1 [shape=box style=\"filled,rounded\" color=orange label=\"Div\n(kgpd_Div1)\" fontsize=10];\n  kgpd_output02 -> kgpd_Div1;\n  kgpd_Divcst1 -> kgpd_Div1;\n  kgpd_Div1 -> kgpd_C01;\n\n  kgpd_Z0 [shape=box label=\"kgpd_Z0\" fontsize=10];\n  kgpd_Pow [shape=box style=\"filled,rounded\" color=orange label=\"Pow\n(kgpd_Pow)\" fontsize=10];\n  kgpd_C01 -> kgpd_Pow;\n  kgpd_Powcst -> kgpd_Pow;\n  kgpd_Pow -> kgpd_Z0;\n\n  kgpd_C0 [shape=box label=\"kgpd_C0\" fontsize=10];\n  kgpd_Mul1 [shape=box style=\"filled,rounded\" color=orange label=\"Mul\n(kgpd_Mul1)\" fontsize=10];\n  kgpd_Z0 -> kgpd_Mul1;\n  kgpd_Mulcst1 -> kgpd_Mul1;\n  kgpd_Mul1 -> kgpd_C0;\n\n  kgpd_output01 [shape=box label=\"kgpd_output01\" fontsize=10];\n  kgpd_Exp [shape=box style=\"filled,rounded\" color=orange label=\"Exp\n(kgpd_Exp)\" fontsize=10];\n  kgpd_C0 -> kgpd_Exp;\n  kgpd_Exp -> kgpd_output01;\n\n  gpr_Y0 [shape=box label=\"gpr_Y0\" fontsize=10];\n  gpr_MatMul [shape=box style=\"filled,rounded\" color=orange label=\"MatMul\n(gpr_MatMul)\" fontsize=10];\n  kgpd_output01 -> gpr_MatMul;\n  gpr_MatMulcst -> gpr_MatMul;\n  gpr_MatMul -> gpr_Y0;\n\n  gpr_C0 [shape=box label=\"gpr_C0\" fontsize=10];\n  gpr_Add [shape=box style=\"filled,rounded\" color=orange label=\"Add\n(gpr_Add)\" fontsize=10];\n  gpr_Y0 -> gpr_Add;\n  gpr_Addcst -> gpr_Add;\n  gpr_Add -> gpr_C0;\n\n  Re_Reshape [shape=box style=\"filled,rounded\" color=orange label=\"Reshape\n(Re_Reshape)\nallowzero=0\" fontsize=10];\n  gpr_C0 -> Re_Reshape;\n  Re_Reshapecst -> Re_Reshape;\n  Re_Reshape -> GPmean;\n}");
    document.getElementById('Mbbc9e417c1334598b429aad877e320b3').innerHTML = svgGraph; });

    </script>



.. code:: ipython3

    model_def_cdist = to_onnx(clr, X_train,
                              options={GaussianProcessRegressor: {'optim': 'cdist'}})
    %onnxview model_def_cdist






.. raw:: html

    <div id="M9203a11fdc704ebf9afabe73ae27e24b-cont"><div id="M9203a11fdc704ebf9afabe73ae27e24b" style="width:;height:;"></div></div>
    <script>

    require(['http://www.xavierdupre.fr/js/vizjs/viz.js'], function() { var svgGraph = Viz("digraph{\n  ranksep=0.25;\n  nodesep=0.05;\n  orientation=portrait;\n  size=7;\n\n  X [shape=box color=red label=\"X\ndouble((0, 4))\" fontsize=10];\n\n  GPmean [shape=box color=green label=\"GPmean\ndouble((0, 1))\" fontsize=10];\n\n  kgpd_CDistcst [shape=box label=\"kgpd_CDistcst\nfloat64((112, 4))\n[[5.8 4.  1.2 0.2]\n [6.  2.2 4.  1. ]\n [5.1 2.5 3....\" fontsize=10];\n  kgpd_Divcst [shape=box label=\"kgpd_Divcst\nfloat64((1,))\n[1.83052462]\" fontsize=10];\n  kgpd_Mulcst [shape=box label=\"kgpd_Mulcst\nfloat64((1,))\n[3.14159265]\" fontsize=10];\n  kgpd_Divcst1 [shape=box label=\"kgpd_Divcst1\nfloat64((1,))\n[1014.92199796]\" fontsize=10];\n  kgpd_Powcst [shape=box label=\"kgpd_Powcst\nfloat64((1,))\n[2.]\" fontsize=10];\n  kgpd_Mulcst1 [shape=box label=\"kgpd_Mulcst1\nfloat64((1,))\n[-2.]\" fontsize=10];\n  gpr_MatMulcst [shape=box label=\"gpr_MatMulcst\nfloat64((112,))\n[-0.0439394   0.00606057  0.00606066 -0.0439394  -...\" fontsize=10];\n  gpr_Addcst [shape=box label=\"gpr_Addcst\nfloat64((1, 1))\n[[0.]]\" fontsize=10];\n  Re_Reshapecst [shape=box label=\"Re_Reshapecst\nint64((2,))\n[-1  1]\" fontsize=10];\n\n  kgpd_dist [shape=box label=\"kgpd_dist\" fontsize=10];\n  kgpd_CDist [shape=box style=\"filled,rounded\" color=orange label=\"CDist\n(kgpd_CDist)\nmetric=b'euclidean'\" fontsize=10];\n  X -> kgpd_CDist;\n  kgpd_CDistcst -> kgpd_CDist;\n  kgpd_CDist -> kgpd_dist;\n\n  kgpd_C03 [shape=box label=\"kgpd_C03\" fontsize=10];\n  kgpd_Div [shape=box style=\"filled,rounded\" color=orange label=\"Div\n(kgpd_Div)\" fontsize=10];\n  kgpd_dist -> kgpd_Div;\n  kgpd_Divcst -> kgpd_Div;\n  kgpd_Div -> kgpd_C03;\n\n  kgpd_C02 [shape=box label=\"kgpd_C02\" fontsize=10];\n  kgpd_Mul [shape=box style=\"filled,rounded\" color=orange label=\"Mul\n(kgpd_Mul)\" fontsize=10];\n  kgpd_C03 -> kgpd_Mul;\n  kgpd_Mulcst -> kgpd_Mul;\n  kgpd_Mul -> kgpd_C02;\n\n  kgpd_output02 [shape=box label=\"kgpd_output02\" fontsize=10];\n  kgpd_Sin [shape=box style=\"filled,rounded\" color=orange label=\"Sin\n(kgpd_Sin)\" fontsize=10];\n  kgpd_C02 -> kgpd_Sin;\n  kgpd_Sin -> kgpd_output02;\n\n  kgpd_C01 [shape=box label=\"kgpd_C01\" fontsize=10];\n  kgpd_Div1 [shape=box style=\"filled,rounded\" color=orange label=\"Div\n(kgpd_Div1)\" fontsize=10];\n  kgpd_output02 -> kgpd_Div1;\n  kgpd_Divcst1 -> kgpd_Div1;\n  kgpd_Div1 -> kgpd_C01;\n\n  kgpd_Z0 [shape=box label=\"kgpd_Z0\" fontsize=10];\n  kgpd_Pow [shape=box style=\"filled,rounded\" color=orange label=\"Pow\n(kgpd_Pow)\" fontsize=10];\n  kgpd_C01 -> kgpd_Pow;\n  kgpd_Powcst -> kgpd_Pow;\n  kgpd_Pow -> kgpd_Z0;\n\n  kgpd_C0 [shape=box label=\"kgpd_C0\" fontsize=10];\n  kgpd_Mul1 [shape=box style=\"filled,rounded\" color=orange label=\"Mul\n(kgpd_Mul1)\" fontsize=10];\n  kgpd_Z0 -> kgpd_Mul1;\n  kgpd_Mulcst1 -> kgpd_Mul1;\n  kgpd_Mul1 -> kgpd_C0;\n\n  kgpd_output01 [shape=box label=\"kgpd_output01\" fontsize=10];\n  kgpd_Exp [shape=box style=\"filled,rounded\" color=orange label=\"Exp\n(kgpd_Exp)\" fontsize=10];\n  kgpd_C0 -> kgpd_Exp;\n  kgpd_Exp -> kgpd_output01;\n\n  gpr_Y0 [shape=box label=\"gpr_Y0\" fontsize=10];\n  gpr_MatMul [shape=box style=\"filled,rounded\" color=orange label=\"MatMul\n(gpr_MatMul)\" fontsize=10];\n  kgpd_output01 -> gpr_MatMul;\n  gpr_MatMulcst -> gpr_MatMul;\n  gpr_MatMul -> gpr_Y0;\n\n  gpr_C0 [shape=box label=\"gpr_C0\" fontsize=10];\n  gpr_Add [shape=box style=\"filled,rounded\" color=orange label=\"Add\n(gpr_Add)\" fontsize=10];\n  gpr_Y0 -> gpr_Add;\n  gpr_Addcst -> gpr_Add;\n  gpr_Add -> gpr_C0;\n\n  Re_Reshape [shape=box style=\"filled,rounded\" color=orange label=\"Reshape\n(Re_Reshape)\nallowzero=0\" fontsize=10];\n  gpr_C0 -> Re_Reshape;\n  Re_Reshapecst -> Re_Reshape;\n  Re_Reshape -> GPmean;\n}");
    document.getElementById('M9203a11fdc704ebf9afabe73ae27e24b').innerHTML = svgGraph; });

    </script>



.. code:: ipython3

    oinf = OnnxInference(model_def)
    oinf_cdist = OnnxInference(model_def_cdist)

.. code:: ipython3

    %timeit oinf.run({'X': X_test})


.. parsed-literal::
    4.24 ms ± 274 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)


.. code:: ipython3

    %timeit oinf_cdist.run({'X': X_test})


.. parsed-literal::
    414 µs ± 15 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)


.. code:: ipython3

    oinfrt = OnnxInference(model_def, runtime="onnxruntime1")
    oinfrt_cdist = OnnxInference(model_def_cdist)

.. code:: ipython3

    %timeit oinfrt_cdist.run({'X': X_test})


.. parsed-literal::
    345 µs ± 26.8 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)


It is 10 times faster for this dataset so it is worth it. For bigger
datasets, we should expect a lower gain but still significant.
