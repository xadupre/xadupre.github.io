
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "gyexamples/plot_opml_random_forest_cls_multi.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_gyexamples_plot_opml_random_forest_cls_multi.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_gyexamples_plot_opml_random_forest_cls_multi.py:


.. _l-example-tree-ensemble-cls-bench-multi:

Benchmark Random Forests, Tree Ensemble, Multi-Classification
=============================================================

The script compares different implementations for the operator
TreeEnsembleRegressor for a multi-regression. It replicates
the benchmark :ref:`l-example-tree-ensemble-reg-bench`
for multi-classification.

.. contents::
    :local:

Import
++++++

.. GENERATED FROM PYTHON SOURCE LINES 18-34

.. code-block:: default

    import warnings
    from time import perf_counter as time
    from multiprocessing import cpu_count
    import numpy
    from numpy.random import rand
    from numpy.testing import assert_almost_equal
    import pandas
    import matplotlib.pyplot as plt
    from sklearn import config_context
    from sklearn.ensemble import RandomForestClassifier
    from sklearn.utils._testing import ignore_warnings
    from skl2onnx import convert_sklearn
    from skl2onnx.common.data_types import FloatTensorType
    from onnxruntime import InferenceSession
    from mlprodict.onnxrt import OnnxInference








.. GENERATED FROM PYTHON SOURCE LINES 35-36

Available optimisation on this machine.

.. GENERATED FROM PYTHON SOURCE LINES 36-41

.. code-block:: default


    from mlprodict.testing.experimental_c_impl.experimental_c import code_optimisation
    print(code_optimisation())






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    AVX-omp=8




.. GENERATED FROM PYTHON SOURCE LINES 42-44

Versions
++++++++

.. GENERATED FROM PYTHON SOURCE LINES 44-69

.. code-block:: default



    def version():
        from datetime import datetime
        import sklearn
        import numpy
        import onnx
        import onnxruntime
        import skl2onnx
        import mlprodict
        df = pandas.DataFrame([
            {"name": "date", "version": str(datetime.now())},
            {"name": "numpy", "version": numpy.__version__},
            {"name": "scikit-learn", "version": sklearn.__version__},
            {"name": "onnx", "version": onnx.__version__},
            {"name": "onnxruntime", "version": onnxruntime.__version__},
            {"name": "skl2onnx", "version": skl2onnx.__version__},
            {"name": "mlprodict", "version": mlprodict.__version__},
        ])
        return df


    version()







.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }

        .dataframe tbody tr th {
            vertical-align: top;
        }

        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>name</th>
          <th>version</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>date</td>
          <td>2022-03-10 09:54:22.848125</td>
        </tr>
        <tr>
          <th>1</th>
          <td>numpy</td>
          <td>1.21.5</td>
        </tr>
        <tr>
          <th>2</th>
          <td>scikit-learn</td>
          <td>1.0.2</td>
        </tr>
        <tr>
          <th>3</th>
          <td>onnx</td>
          <td>1.11.0</td>
        </tr>
        <tr>
          <th>4</th>
          <td>onnxruntime</td>
          <td>1.10.91</td>
        </tr>
        <tr>
          <th>5</th>
          <td>skl2onnx</td>
          <td>1.11</td>
        </tr>
        <tr>
          <th>6</th>
          <td>mlprodict</td>
          <td>0.8.1747</td>
        </tr>
      </tbody>
    </table>
    </div>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 70-72

Implementations to benchmark
++++++++++++++++++++++++++++

.. GENERATED FROM PYTHON SOURCE LINES 72-113

.. code-block:: default


    def fcts_model(X, y, max_depth, n_estimators, n_jobs):
        "RandomForestClassifier."
        rf = RandomForestClassifier(max_depth=max_depth, n_estimators=n_estimators,
                                    n_jobs=n_jobs)
        rf.fit(X, y)

        initial_types = [('X', FloatTensorType([None, X.shape[1]]))]
        onx = convert_sklearn(rf, initial_types=initial_types,
                              options={id(rf): {'zipmap': False}})
        sess = InferenceSession(onx.SerializeToString())
        outputs = [o.name for o in sess.get_outputs()]
        oinf = OnnxInference(onx, runtime="python")
        oinf.sequence_[0].ops_._init(numpy.float32, 1)
        name = outputs[1]
        oinf2 = OnnxInference(onx, runtime="python")
        oinf2.sequence_[0].ops_._init(numpy.float32, 2)
        oinf3 = OnnxInference(onx, runtime="python")
        oinf3.sequence_[0].ops_._init(numpy.float32, 3)

        def predict_skl_predict(X, model=rf):
            return rf.predict_proba(X)

        def predict_onnxrt_predict(X, sess=sess):
            return sess.run(outputs[:1], {'X': X})[0]

        def predict_onnx_inference(X, oinf=oinf):
            return oinf.run({'X': X})[name]

        def predict_onnx_inference2(X, oinf2=oinf2):
            return oinf2.run({'X': X})[name]

        def predict_onnx_inference3(X, oinf3=oinf3):
            return oinf3.run({'X': X})[name]

        return {'predict': (
            predict_skl_predict, predict_onnxrt_predict,
            predict_onnx_inference, predict_onnx_inference2,
            predict_onnx_inference3)}









.. GENERATED FROM PYTHON SOURCE LINES 114-116

Benchmarks
++++++++++

.. GENERATED FROM PYTHON SOURCE LINES 116-237

.. code-block:: default


    def allow_configuration(**kwargs):
        return True


    def bench(n_obs, n_features, max_depths, n_estimatorss, n_jobss,
              methods, repeat=10, verbose=False):
        res = []
        for nfeat in n_features:

            ntrain = 50000
            X_train = numpy.empty((ntrain, nfeat)).astype(numpy.float32)
            X_train[:, :] = rand(ntrain, nfeat)[:, :]
            eps = rand(ntrain) - 0.5
            y_train_f = X_train.sum(axis=1) + eps
            y_train = (y_train_f > 12).astype(numpy.int64)
            y_train[y_train_f > 15] = 2
            y_train[y_train_f < 10] = 3

            for n_jobs in n_jobss:
                for max_depth in max_depths:
                    for n_estimators in n_estimatorss:
                        fcts = fcts_model(X_train, y_train,
                                          max_depth, n_estimators, n_jobs)

                        for n in n_obs:
                            for method in methods:

                                fct1, fct2, fct3, fct4, fct5 = fcts[method]

                                if not allow_configuration(
                                        n=n, nfeat=nfeat, max_depth=max_depth,
                                        n_estimator=n_estimators, n_jobs=n_jobs,
                                        method=method):
                                    continue

                                obs = dict(n_obs=n, nfeat=nfeat,
                                           max_depth=max_depth,
                                           n_estimators=n_estimators,
                                           method=method,
                                           n_jobs=n_jobs)

                                # creates different inputs to avoid caching
                                Xs = []
                                for r in range(repeat):
                                    x = numpy.empty((n, nfeat))
                                    x[:, :] = rand(n, nfeat)[:, :]
                                    Xs.append(x.astype(numpy.float32))

                                # measures the baseline
                                with config_context(assume_finite=True):
                                    st = time()
                                    repeated = 0
                                    for X in Xs:
                                        p1 = fct1(X)
                                        repeated += 1
                                        if time() - st >= 1:
                                            break  # stops if longer than a second
                                    end = time()
                                    obs["time_skl"] = (end - st) / repeated

                                # measures the new implementation
                                st = time()
                                r2 = 0
                                for X in Xs:
                                    p2 = fct2(X)
                                    r2 += 1
                                    if r2 >= repeated:
                                        break
                                end = time()
                                obs["time_ort"] = (end - st) / r2

                                # measures the other new implementation
                                st = time()
                                r2 = 0
                                for X in Xs:
                                    p2 = fct3(X)
                                    r2 += 1
                                    if r2 >= repeated:
                                        break
                                end = time()
                                obs["time_mlprodict"] = (end - st) / r2

                                # measures the other new implementation 2
                                st = time()
                                r2 = 0
                                for X in Xs:
                                    p2 = fct4(X)
                                    r2 += 1
                                    if r2 >= repeated:
                                        break
                                end = time()
                                obs["time_mlprodict2"] = (end - st) / r2

                                # measures the other new implementation 3
                                st = time()
                                r2 = 0
                                for X in Xs:
                                    p2 = fct5(X)
                                    r2 += 1
                                    if r2 >= repeated:
                                        break
                                end = time()
                                obs["time_mlprodict3"] = (end - st) / r2

                                # final
                                res.append(obs)
                                if verbose and (len(res) % 1 == 0 or n >= 10000):
                                    print("bench", len(res), ":", obs)

                                # checks that both produce the same outputs
                                if n <= 10000:
                                    if len(p1.shape) == 1 and len(p2.shape) == 2:
                                        p2 = p2.ravel()
                                    try:
                                        assert_almost_equal(
                                            p1.ravel(), p2.ravel(), decimal=5)
                                    except AssertionError as e:
                                        warnings.warn(str(e))
        return res








.. GENERATED FROM PYTHON SOURCE LINES 238-240

Graphs
++++++

.. GENERATED FROM PYTHON SOURCE LINES 240-308

.. code-block:: default



    def plot_rf_models(dfr):

        def autolabel(ax, rects):
            for rect in rects:
                height = rect.get_height()
                ax.annotate('%1.1fx' % height,
                            xy=(rect.get_x() + rect.get_width() / 2, height),
                            xytext=(0, 3),  # 3 points vertical offset
                            textcoords="offset points",
                            ha='center', va='bottom',
                            fontsize=8)

        engines = [_.split('_')[-1] for _ in dfr.columns if _.startswith("time_")]
        engines = [_ for _ in engines if _ != 'skl']
        for engine in engines:
            dfr["speedup_%s" % engine] = dfr["time_skl"] / dfr["time_%s" % engine]
        print(dfr.tail().T)

        ncols = 4
        fig, axs = plt.subplots(len(engines), ncols, figsize=(
            14, 4 * len(engines)), sharey=True)

        row = 0
        for row, engine in enumerate(engines):
            pos = 0
            name = "RandomForestClassifier - %s" % engine
            for max_depth in sorted(set(dfr.max_depth)):
                for nf in sorted(set(dfr.nfeat)):
                    for est in sorted(set(dfr.n_estimators)):
                        for n_jobs in sorted(set(dfr.n_jobs)):
                            sub = dfr[(dfr.max_depth == max_depth) &
                                      (dfr.nfeat == nf) &
                                      (dfr.n_estimators == est) &
                                      (dfr.n_jobs == n_jobs)]
                            ax = axs[row, pos]
                            labels = sub.n_obs
                            means = sub["speedup_%s" % engine]

                            x = numpy.arange(len(labels))
                            width = 0.90

                            rects1 = ax.bar(x, means, width, label='Speedup')
                            if pos == 0:
                                ax.set_yscale('log')
                                ax.set_ylim([0.1, max(dfr["speedup_%s" % engine])])

                            if pos == 0:
                                ax.set_ylabel('Speedup')
                            ax.set_title(
                                '%s\ndepth %d - %d features\n %d estimators '
                                '%d jobs' % (name, max_depth, nf, est, n_jobs))
                            if row == len(engines) - 1:
                                ax.set_xlabel('batch size')
                            ax.set_xticks(x)
                            ax.set_xticklabels(labels)
                            autolabel(ax, rects1)
                            for tick in ax.xaxis.get_major_ticks():
                                tick.label.set_fontsize(8)
                            for tick in ax.yaxis.get_major_ticks():
                                tick.label.set_fontsize(8)
                            pos += 1

        fig.tight_layout()
        return fig, ax









.. GENERATED FROM PYTHON SOURCE LINES 309-311

Run benchs
++++++++++

.. GENERATED FROM PYTHON SOURCE LINES 311-340

.. code-block:: default


    @ignore_warnings(category=FutureWarning)
    def run_bench(repeat=100, verbose=False):
        n_obs = [1, 10, 100, 1000, 10000]
        methods = ['predict']
        n_features = [30]
        max_depths = [6, 8, 10, 12]
        n_estimatorss = [100]
        n_jobss = [cpu_count()]

        start = time()
        results = bench(n_obs, n_features, max_depths, n_estimatorss, n_jobss,
                        methods, repeat=repeat, verbose=verbose)
        end = time()

        results_df = pandas.DataFrame(results)
        print("Total time = %0.3f sec cpu=%d\n" % (end - start, cpu_count()))

        # plot the results
        return results_df


    name = "plot_random_forest_cls_multi"
    df = run_bench(verbose=True)
    df.to_csv("%s.csv" % name, index=False)
    df.to_excel("%s.xlsx" % name, index=False)
    fig, ax = plot_rf_models(df)
    fig.savefig("%s.png" % name)
    plt.show()



.. image-sg:: /gyexamples/images/sphx_glr_plot_opml_random_forest_cls_multi_001.png
   :alt: RandomForestClassifier - ort depth 6 - 30 features  100 estimators 8 jobs, RandomForestClassifier - ort depth 8 - 30 features  100 estimators 8 jobs, RandomForestClassifier - ort depth 10 - 30 features  100 estimators 8 jobs, RandomForestClassifier - ort depth 12 - 30 features  100 estimators 8 jobs, RandomForestClassifier - mlprodict depth 6 - 30 features  100 estimators 8 jobs, RandomForestClassifier - mlprodict depth 8 - 30 features  100 estimators 8 jobs, RandomForestClassifier - mlprodict depth 10 - 30 features  100 estimators 8 jobs, RandomForestClassifier - mlprodict depth 12 - 30 features  100 estimators 8 jobs, RandomForestClassifier - mlprodict2 depth 6 - 30 features  100 estimators 8 jobs, RandomForestClassifier - mlprodict2 depth 8 - 30 features  100 estimators 8 jobs, RandomForestClassifier - mlprodict2 depth 10 - 30 features  100 estimators 8 jobs, RandomForestClassifier - mlprodict2 depth 12 - 30 features  100 estimators 8 jobs, RandomForestClassifier - mlprodict3 depth 6 - 30 features  100 estimators 8 jobs, RandomForestClassifier - mlprodict3 depth 8 - 30 features  100 estimators 8 jobs, RandomForestClassifier - mlprodict3 depth 10 - 30 features  100 estimators 8 jobs, RandomForestClassifier - mlprodict3 depth 12 - 30 features  100 estimators 8 jobs
   :srcset: /gyexamples/images/sphx_glr_plot_opml_random_forest_cls_multi_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    bench 1 : {'n_obs': 1, 'nfeat': 30, 'max_depth': 6, 'n_estimators': 100, 'method': 'predict', 'n_jobs': 8, 'time_skl': 0.061066043946672886, 'time_ort': 0.00034011056756272037, 'time_mlprodict': 0.00010688712491708644, 'time_mlprodict2': 0.00012462454683640425, 'time_mlprodict3': 9.969605461639516e-05}
    bench 2 : {'n_obs': 10, 'nfeat': 30, 'max_depth': 6, 'n_estimators': 100, 'method': 'predict', 'n_jobs': 8, 'time_skl': 0.06343627732712775, 'time_ort': 0.0005025997525081038, 'time_mlprodict': 0.000581271480768919, 'time_mlprodict2': 0.00047146255383268, 'time_mlprodict3': 0.00035439449129626155}
    bench 3 : {'n_obs': 100, 'nfeat': 30, 'max_depth': 6, 'n_estimators': 100, 'method': 'predict', 'n_jobs': 8, 'time_skl': 0.06841407734900713, 'time_ort': 0.0005077907194693883, 'time_mlprodict': 0.0057105702037612595, 'time_mlprodict2': 0.0017776596049467722, 'time_mlprodict3': 0.00032173066089550656}
    bench 4 : {'n_obs': 1000, 'nfeat': 30, 'max_depth': 6, 'n_estimators': 100, 'method': 'predict', 'n_jobs': 8, 'time_skl': 0.1086305908858776, 'time_ort': 0.003461424075067043, 'time_mlprodict': 0.017985825706273318, 'time_mlprodict2': 0.016469659470021724, 'time_mlprodict3': 0.002068026550114155}
    bench 5 : {'n_obs': 10000, 'nfeat': 30, 'max_depth': 6, 'n_estimators': 100, 'method': 'predict', 'n_jobs': 8, 'time_skl': 0.1474550999701023, 'time_ort': 0.035067615498389514, 'time_mlprodict': 0.14003085664340428, 'time_mlprodict2': 0.16225130244025163, 'time_mlprodict3': 0.01958167858953987}
    bench 6 : {'n_obs': 1, 'nfeat': 30, 'max_depth': 8, 'n_estimators': 100, 'method': 'predict', 'n_jobs': 8, 'time_skl': 0.06094714467797209, 'time_ort': 9.923833696281209e-05, 'time_mlprodict': 0.003270719036021653, 'time_mlprodict2': 0.00015873834490776062, 'time_mlprodict3': 0.00010201718439074124}
    bench 7 : {'n_obs': 10, 'nfeat': 30, 'max_depth': 8, 'n_estimators': 100, 'method': 'predict', 'n_jobs': 8, 'time_skl': 0.06337202672148123, 'time_ort': 0.0009160448680631816, 'time_mlprodict': 0.0010338493157178164, 'time_mlprodict2': 0.0010187719017267227, 'time_mlprodict3': 0.0003330521285533905}
    bench 8 : {'n_obs': 100, 'nfeat': 30, 'max_depth': 8, 'n_estimators': 100, 'method': 'predict', 'n_jobs': 8, 'time_skl': 0.07025178372859955, 'time_ort': 0.001087537407875061, 'time_mlprodict': 0.005342840030789375, 'time_mlprodict2': 0.0017818562065561613, 'time_mlprodict3': 0.0005849326029419899}
    bench 9 : {'n_obs': 1000, 'nfeat': 30, 'max_depth': 8, 'n_estimators': 100, 'method': 'predict', 'n_jobs': 8, 'time_skl': 0.11057451870292426, 'time_ort': 0.005081353336572647, 'time_mlprodict': 0.01900232518091798, 'time_mlprodict2': 0.013583028223365545, 'time_mlprodict3': 0.0029519874602556228}
    bench 10 : {'n_obs': 10000, 'nfeat': 30, 'max_depth': 8, 'n_estimators': 100, 'method': 'predict', 'n_jobs': 8, 'time_skl': 0.14802611113658973, 'time_ort': 0.055390900533114164, 'time_mlprodict': 0.1620085034519434, 'time_mlprodict2': 0.16017174813896418, 'time_mlprodict3': 0.025479831865855625}
    bench 11 : {'n_obs': 1, 'nfeat': 30, 'max_depth': 10, 'n_estimators': 100, 'method': 'predict', 'n_jobs': 8, 'time_skl': 0.061031464322963185, 'time_ort': 0.00013581093619851505, 'time_mlprodict': 0.004149201161721174, 'time_mlprodict2': 0.00020915899864014457, 'time_mlprodict3': 0.00010264128008309533}
    bench 12 : {'n_obs': 10, 'nfeat': 30, 'max_depth': 10, 'n_estimators': 100, 'method': 'predict', 'n_jobs': 8, 'time_skl': 0.06553702993551269, 'time_ort': 0.0010712363291531801, 'time_mlprodict': 0.001157473016064614, 'time_mlprodict2': 0.0013353467802517116, 'time_mlprodict3': 0.0008869701996445656}
    bench 13 : {'n_obs': 100, 'nfeat': 30, 'max_depth': 10, 'n_estimators': 100, 'method': 'predict', 'n_jobs': 8, 'time_skl': 0.07925970451189922, 'time_ort': 0.0018408370849031669, 'time_mlprodict': 0.006713447375939443, 'time_mlprodict2': 0.0023189344658301426, 'time_mlprodict3': 0.0009329079721982663}
    bench 14 : {'n_obs': 1000, 'nfeat': 30, 'max_depth': 10, 'n_estimators': 100, 'method': 'predict', 'n_jobs': 8, 'time_skl': 0.11200813545535009, 'time_ort': 0.007949582094119655, 'time_mlprodict': 0.022380766044888232, 'time_mlprodict2': 0.02079858568807443, 'time_mlprodict3': 0.004338502780430847}
    bench 15 : {'n_obs': 10000, 'nfeat': 30, 'max_depth': 10, 'n_estimators': 100, 'method': 'predict', 'n_jobs': 8, 'time_skl': 0.15028540763471807, 'time_ort': 0.060595392382570674, 'time_mlprodict': 0.19347136614045926, 'time_mlprodict2': 0.20676943114293472, 'time_mlprodict3': 0.03385879072759833}
    bench 16 : {'n_obs': 1, 'nfeat': 30, 'max_depth': 12, 'n_estimators': 100, 'method': 'predict', 'n_jobs': 8, 'time_skl': 0.0611362479188863, 'time_ort': 0.00027589423253255734, 'time_mlprodict': 0.0035827970132231712, 'time_mlprodict2': 0.0002588113660321516, 'time_mlprodict3': 0.00011624297236695009}
    bench 17 : {'n_obs': 10, 'nfeat': 30, 'max_depth': 12, 'n_estimators': 100, 'method': 'predict', 'n_jobs': 8, 'time_skl': 0.06743813020487627, 'time_ort': 0.0013207622493306796, 'time_mlprodict': 0.0014297305916746458, 'time_mlprodict2': 0.001731506735086441, 'time_mlprodict3': 0.001550291913251082}
    bench 18 : {'n_obs': 100, 'nfeat': 30, 'max_depth': 12, 'n_estimators': 100, 'method': 'predict', 'n_jobs': 8, 'time_skl': 0.08137485327628943, 'time_ort': 0.001989781713256469, 'time_mlprodict': 0.006109796679363801, 'time_mlprodict2': 0.002883652511697549, 'time_mlprodict3': 0.0012997019892701735}
    bench 19 : {'n_obs': 1000, 'nfeat': 30, 'max_depth': 12, 'n_estimators': 100, 'method': 'predict', 'n_jobs': 8, 'time_skl': 0.11378940701898602, 'time_ort': 0.011791856752501594, 'time_mlprodict': 0.0254625729802582, 'time_mlprodict2': 0.02593166588081254, 'time_mlprodict3': 0.006136060795850224}
    bench 20 : {'n_obs': 10000, 'nfeat': 30, 'max_depth': 12, 'n_estimators': 100, 'method': 'predict', 'n_jobs': 8, 'time_skl': 0.1536321887480361, 'time_ort': 0.09125976344304425, 'time_mlprodict': 0.21969728158520802, 'time_mlprodict2': 0.25922714666064295, 'time_mlprodict3': 0.04711872325944049}
    Total time = 279.099 sec cpu=8

                                15         16         17         18        19
    n_obs                        1         10        100       1000     10000
    nfeat                       30         30         30         30        30
    max_depth                   12         12         12         12        12
    n_estimators               100        100        100        100       100
    method                 predict    predict    predict    predict   predict
    n_jobs                       8          8          8          8         8
    time_skl              0.061136   0.067438   0.081375   0.113789  0.153632
    time_ort              0.000276   0.001321    0.00199   0.011792   0.09126
    time_mlprodict        0.003583    0.00143    0.00611   0.025463  0.219697
    time_mlprodict2       0.000259   0.001732   0.002884   0.025932  0.259227
    time_mlprodict3       0.000116    0.00155     0.0013   0.006136  0.047119
    speedup_ort         221.593063  51.060007  40.896372   9.649829   1.68346
    speedup_mlprodict    17.063832  47.168418   13.31875   4.468889   0.69929
    speedup_mlprodict2  236.219332  38.947657  28.219369   4.388048  0.592655
    speedup_mlprodict3  525.935002  43.500279  62.610394  18.544374  3.260534





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 4 minutes  57.172 seconds)


.. _sphx_glr_download_gyexamples_plot_opml_random_forest_cls_multi.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_opml_random_forest_cls_multi.py <plot_opml_random_forest_cls_multi.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_opml_random_forest_cls_multi.ipynb <plot_opml_random_forest_cls_multi.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
