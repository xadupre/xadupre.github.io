
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Loop &#8212; ONNX 0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/basic_mod.css?v=0.7.0-1" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sample.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <script src="../_static/js/petite-vue.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Loop - 13 vs 16" href="text_diff_Loop_13_16.html" />
    <link rel="prev" title="LogSoftmax - 1 vs 11" href="text_diff_LogSoftmax_1_11.html" /> 
  </head><body>

<div id="top_nav">
    

    <nav>
        <p id="toggle_sidebar">
            <a href="#" title="Toggle sidebar">|||</a>
        </p>
        <h1><a href="../index.html" title="Go to homepage">ONNX 0.1 documentation</a></h1>

        <a id="mode_toggle" href="#" @click.prevent="handleClick" :title="mode">
    <template v-if="mode == 'light'">
        <svg width="100%" height="100%" viewBox="0 0 79 80" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="mode_light"><rect id="Bounds" x="0" y="-0" width="78.623" height="79.049" style="fill:none;"/><circle cx="39.311" cy="39.524" r="15.734" style="fill:#fff;"/><g id="beams"><g id="beam"><path id="beam1" serif:id="beam" d="M44.212,4.901c0,-2.705 -2.196,-4.901 -4.901,-4.901c-2.704,-0 -4.9,2.196 -4.9,4.901l-0,9.614c-0,2.705 2.196,4.901 4.9,4.901c2.705,0 4.901,-2.196 4.901,-4.901l0,-9.614Z" style="fill:#fff;"/></g><g id="beam2" serif:id="beam"><path id="beam3" serif:id="beam" d="M67.48,18.073c1.913,-1.912 1.913,-5.018 0,-6.931c-1.912,-1.912 -5.018,-1.912 -6.931,0l-6.798,6.799c-1.912,1.912 -1.912,5.018 0,6.931c1.913,1.912 5.018,1.912 6.931,-0l6.798,-6.799Z" style="fill:#fff;"/></g><g id="beam4" serif:id="beam"><path id="beam5" serif:id="beam" d="M25.728,61.108c1.912,-1.913 1.912,-5.018 -0,-6.931c-1.913,-1.913 -5.019,-1.913 -6.931,-0l-6.799,6.798c-1.912,1.913 -1.912,5.019 0,6.931c1.913,1.913 5.019,1.913 6.931,0l6.799,-6.798Z" style="fill:#fff;"/></g><g id="beam6" serif:id="beam"><path id="beam7" serif:id="beam" d="M60.682,54.177c-1.913,-1.913 -5.018,-1.913 -6.931,-0c-1.912,1.913 -1.912,5.018 0,6.931l6.798,6.798c1.913,1.913 5.019,1.913 6.931,0c1.913,-1.912 1.913,-5.018 0,-6.931l-6.798,-6.798Z" style="fill:#fff;"/></g><g id="beam8" serif:id="beam"><path id="beam9" serif:id="beam" d="M4.901,34.623c-2.705,0 -4.901,2.196 -4.901,4.901c0,2.705 2.196,4.901 4.901,4.901l9.614,0c2.705,0 4.901,-2.196 4.901,-4.901c0,-2.705 -2.196,-4.901 -4.901,-4.901l-9.614,0Z" style="fill:#fff;"/></g><g id="beam10" serif:id="beam"><path id="beam11" serif:id="beam" d="M44.212,64.534c0,-2.705 -2.196,-4.901 -4.901,-4.901c-2.704,-0 -4.9,2.196 -4.9,4.901l-0,9.614c-0,2.705 2.196,4.901 4.9,4.901c2.705,-0 4.901,-2.196 4.901,-4.901l0,-9.614Z" style="fill:#fff;"/></g><g id="beam12" serif:id="beam"><path id="beam13" serif:id="beam" d="M18.929,11.142c-1.912,-1.912 -5.018,-1.912 -6.931,0c-1.912,1.913 -1.912,5.019 0,6.931l6.799,6.799c1.912,1.912 5.018,1.912 6.931,-0c1.912,-1.913 1.912,-5.019 -0,-6.931l-6.799,-6.799Z" style="fill:#fff;"/></g><g id="beam14" serif:id="beam"><path id="beam15" serif:id="beam" d="M64.108,34.623c-2.705,0 -4.901,2.196 -4.901,4.901c-0,2.705 2.196,4.901 4.901,4.901l9.614,0c2.705,0 4.901,-2.196 4.901,-4.901c-0,-2.705 -2.196,-4.901 -4.901,-4.901l-9.614,0Z" style="fill:#fff;"/></g></g></g></svg>
    </template>

    <template v-if="mode == 'dark'">
        <svg width="100%" height="100%" viewBox="0 0 79 80" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="mode_dark"><rect id="Bounds" x="0" y="-0" width="78.623" height="79.049" style="fill:none;"/><circle cx="39.311" cy="39.524" r="15.734" style="fill:#fff;"/><g id="beams"><g id="beam"><path id="beam1" serif:id="beam" d="M44.212,14.515c0,-2.705 -2.196,-4.901 -4.901,-4.901c-2.704,0 -4.901,2.196 -4.901,4.901c0,2.705 2.197,4.901 4.901,4.901c2.705,0 4.901,-2.196 4.901,-4.901Z" style="fill:#fff;"/></g><g id="beam2" serif:id="beam"><path id="beam3" serif:id="beam" d="M60.662,24.892c1.902,-1.902 1.902,-4.99 0,-6.892l-0.04,-0.039c-1.901,-1.902 -4.989,-1.902 -6.891,-0c-1.901,1.901 -1.901,4.989 0,6.891l0.04,0.04c1.902,1.901 4.989,1.901 6.891,-0Z" style="fill:#fff;"/></g><g id="beam4" serif:id="beam"><path id="beam5" serif:id="beam" d="M25.732,61.103c1.91,-1.91 1.91,-5.011 0,-6.921l-0.009,-0.01c-1.91,-1.91 -5.012,-1.91 -6.921,-0c-1.91,1.91 -1.91,5.011 -0,6.921l0.01,0.01c1.909,1.91 5.011,1.91 6.92,-0Z" style="fill:#fff;"/></g><g id="beam6" serif:id="beam"><path id="beam7" serif:id="beam" d="M60.672,54.167c-1.907,-1.907 -5.004,-1.907 -6.911,0l-0.02,0.02c-1.907,1.907 -1.907,5.004 0,6.911c1.907,1.907 5.004,1.907 6.911,-0l0.02,-0.02c1.907,-1.907 1.907,-5.004 0,-6.911Z" style="fill:#fff;"/></g><g id="beam8" serif:id="beam"><path id="beam9" serif:id="beam" d="M14.52,34.623c-2.702,0 -4.896,2.194 -4.896,4.896l0,0.01c0,2.702 2.194,4.896 4.896,4.896c2.702,0 4.896,-2.194 4.896,-4.896l-0,-0.01c-0,-2.702 -2.194,-4.896 -4.896,-4.896Z" style="fill:#fff;"/></g><g id="beam10" serif:id="beam"><path id="beam11" serif:id="beam" d="M44.212,64.534c0,-2.705 -2.196,-4.901 -4.901,-4.901c-2.704,-0 -4.901,2.196 -4.901,4.901c0,2.704 2.197,4.9 4.901,4.9c2.705,0 4.901,-2.196 4.901,-4.9Z" style="fill:#fff;"/></g><g id="beam12" serif:id="beam"><path id="beam13" serif:id="beam" d="M25.73,17.943c-1.911,-1.911 -5.015,-1.911 -6.926,0l-0.005,0.005c-1.911,1.911 -1.911,5.015 0,6.926c1.911,1.911 5.015,1.911 6.926,0l0.005,-0.005c1.911,-1.911 1.911,-5.014 -0,-6.926Z" style="fill:#fff;"/></g><g id="beam14" serif:id="beam"><path id="beam15" serif:id="beam" d="M64.098,34.623c-2.699,0 -4.891,2.192 -4.891,4.892l-0,0.019c-0,2.699 2.192,4.891 4.891,4.891c2.7,0 4.892,-2.192 4.892,-4.891l0,-0.019c0,-2.7 -2.192,-4.892 -4.892,-4.892Z" style="fill:#fff;"/></g></g></g></svg>
    </template>

    <template v-if="mode == 'darkest'">
        <svg width="100%" height="100%" viewBox="0 0 79 80" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="mode_darkest"><rect id="Bounds" x="0" y="-0" width="78.623" height="79.049" style="fill:none;"/><path d="M39.315,23.791c8.684,-0 15.734,7.05 15.734,15.733c0,8.684 -7.05,15.734 -15.734,15.734c-8.683,0 -15.733,-7.05 -15.733,-15.734c-0,-8.683 7.05,-15.733 15.733,-15.733Zm0,4.737c6.069,0 10.997,4.927 10.997,10.996c-0,6.069 -4.928,10.996 -10.997,10.996c-6.068,0 -10.996,-4.927 -10.996,-10.996c0,-6.069 4.928,-10.996 10.996,-10.996Z" style="fill:#fff;"/><g id="beams"><g id="beam"><path id="beam1" serif:id="beam" d="M44.216,14.515c0,-2.705 -2.196,-4.901 -4.901,-4.901c-2.704,0 -4.9,2.196 -4.9,4.901c-0,2.705 2.196,4.901 4.9,4.901c2.705,0 4.901,-2.196 4.901,-4.901Z" style="fill:#fff;"/></g><g id="beam2" serif:id="beam"><path id="beam3" serif:id="beam" d="M60.666,24.892c1.902,-1.902 1.902,-4.99 0,-6.892l-0.04,-0.039c-1.901,-1.902 -4.989,-1.902 -6.891,-0c-1.901,1.901 -1.901,4.989 0,6.891l0.04,0.04c1.902,1.901 4.99,1.901 6.891,-0Z" style="fill:#fff;"/></g><g id="beam4" serif:id="beam"><path id="beam5" serif:id="beam" d="M25.737,61.103c1.909,-1.91 1.909,-5.011 -0,-6.921l-0.01,-0.01c-1.91,-1.91 -5.011,-1.91 -6.921,-0c-1.91,1.91 -1.91,5.011 -0,6.921l0.01,0.01c1.91,1.91 5.011,1.91 6.921,-0Z" style="fill:#fff;"/></g><g id="beam6" serif:id="beam"><path id="beam7" serif:id="beam" d="M60.676,54.167c-1.907,-1.907 -5.004,-1.907 -6.911,0l-0.02,0.02c-1.907,1.907 -1.907,5.004 0,6.911c1.907,1.907 5.004,1.907 6.911,-0l0.02,-0.02c1.907,-1.907 1.907,-5.004 0,-6.911Z" style="fill:#fff;"/></g><g id="beam8" serif:id="beam"><path id="beam9" serif:id="beam" d="M14.524,34.623c-2.702,0 -4.896,2.194 -4.896,4.896l0,0.01c0,2.702 2.194,4.896 4.896,4.896c2.702,0 4.896,-2.194 4.896,-4.896l0,-0.01c0,-2.702 -2.194,-4.896 -4.896,-4.896Z" style="fill:#fff;"/></g><g id="beam10" serif:id="beam"><path id="beam11" serif:id="beam" d="M44.216,64.534c0,-2.705 -2.196,-4.901 -4.901,-4.901c-2.704,-0 -4.9,2.196 -4.9,4.901c-0,2.704 2.196,4.9 4.9,4.9c2.705,0 4.901,-2.196 4.901,-4.9Z" style="fill:#fff;"/></g><g id="beam12" serif:id="beam"><path id="beam13" serif:id="beam" d="M25.734,17.943c-1.911,-1.911 -5.015,-1.911 -6.926,0l-0.005,0.005c-1.911,1.911 -1.911,5.015 0,6.926c1.911,1.911 5.015,1.911 6.926,0l0.005,-0.005c1.911,-1.911 1.911,-5.014 0,-6.926Z" style="fill:#fff;"/></g><g id="beam14" serif:id="beam"><path id="beam15" serif:id="beam" d="M64.103,34.623c-2.7,0 -4.892,2.192 -4.892,4.892l-0,0.019c-0,2.699 2.192,4.891 4.892,4.891c2.699,0 4.891,-2.192 4.891,-4.891l0,-0.019c0,-2.7 -2.192,-4.892 -4.891,-4.892Z" style="fill:#fff;"/></g></g></g></svg>
    </template>
</a>

<script>
(function() {
    const LOCAL_STORAGE_KEY = 'piccoloThemeMode'

    var initialMode = localStorage.getItem(LOCAL_STORAGE_KEY)

    if (initialMode) {
        // Make sure the value in local storage is valid
        if (['light', 'dark', 'darkest'].indexOf(initialMode) == -1) {
            initialMode = 'light'
            localStorage.setItem(LOCAL_STORAGE_KEY, initialMode)
        }
    } else {
        // Check if the client prefers dark mode
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            initialMode = 'dark'
        } else {
            initialMode = 'light'
        }
        localStorage.setItem(LOCAL_STORAGE_KEY, initialMode)
    }

    document.documentElement.dataset.mode = initialMode

    PetiteVue.createApp({
        'mode': initialMode,
        handleClick() {
            let currentMode = this.mode

            if (currentMode == 'light') {
                this.mode = 'dark'
            } else if (currentMode == 'dark') {
                this.mode = 'darkest'
            } else if (currentMode == 'darkest') {
                this.mode = 'light'
            }

            document.documentElement.dataset.mode = this.mode
            localStorage.setItem(LOCAL_STORAGE_KEY, this.mode)

            console.log(this.mode)
        }
    }).mount('#mode_toggle')
})()
</script>
            <p class="mobile_search_link">
                <a href="../search.html" title="Search">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 65 64" fill-rule="evenodd" stroke-linejoin="round" stroke-miterlimit="2">
                        <path d="M14.873 40.009c-2.315-3.943-3.642-8.532-3.642-13.429C11.231 11.91 23.141 0 37.811 0s26.58 11.91 26.58 26.58-11.91 26.58-26.58 26.58a26.44 26.44 0 0 1-14.277-4.161L9.739 62.794a3.12 3.12 0 0 1-4.413 0L.913 58.382c-1.217-1.218-1.217-3.196 0-4.413l13.96-13.96zM37.811 8.054c10.225 0 18.526 8.301 18.526 18.526s-8.301 18.526-18.526 18.526-18.526-8.301-18.526-18.526S27.586 8.054 37.811 8.054z" fill="#fff" />
                    </svg>
                </a>
            </p>
        

        <div class="searchbox_wrapper">
            
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
    </nav>
</div>

    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">ONNX operators</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../expect.html">Function expect</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Abs.html">Abs</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Acos.html">Acos</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Acosh.html">Acosh</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Add.html">Add</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__And.html">And</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__ArgMax.html">ArgMax</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__ArgMin.html">ArgMin</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Asin.html">Asin</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Asinh.html">Asinh</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Atan.html">Atan</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Atanh.html">Atanh</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__AveragePool.html">AveragePool</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__BatchNormalization.html">BatchNormalization</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Bernoulli.html">Bernoulli</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__BitShift.html">BitShift</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__BlackmanWindow.html">BlackmanWindow</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Cast.html">Cast</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__CastLike.html">CastLike</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Ceil.html">Ceil</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Celu.html">Celu</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__CenterCropPad.html">CenterCropPad</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Clip.html">Clip</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Col2Im.html">Col2Im</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Compress.html">Compress</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Concat.html">Concat</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__ConcatFromSequence.html">ConcatFromSequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Constant.html">Constant</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__ConstantOfShape.html">ConstantOfShape</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Conv.html">Conv</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__ConvInteger.html">ConvInteger</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__ConvTranspose.html">ConvTranspose</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Cos.html">Cos</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Cosh.html">Cosh</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__CumSum.html">CumSum</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__DFT.html">DFT</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__DepthToSpace.html">DepthToSpace</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__DequantizeLinear.html">DequantizeLinear</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Det.html">Det</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Div.html">Div</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Dropout.html">Dropout</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__DynamicQuantizeLinear.html">DynamicQuantizeLinear</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Einsum.html">Einsum</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Elu.html">Elu</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Equal.html">Equal</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Erf.html">Erf</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Exp.html">Exp</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Expand.html">Expand</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__EyeLike.html">EyeLike</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Flatten.html">Flatten</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Floor.html">Floor</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__GRU.html">GRU</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Gather.html">Gather</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__GatherElements.html">GatherElements</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__GatherND.html">GatherND</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Gemm.html">Gemm</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__GlobalAveragePool.html">GlobalAveragePool</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__GlobalLpPool.html">GlobalLpPool</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__GlobalMaxPool.html">GlobalMaxPool</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Greater.html">Greater</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__GreaterOrEqual.html">GreaterOrEqual</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__GridSample.html">GridSample</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__HammingWindow.html">HammingWindow</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__HannWindow.html">HannWindow</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__HardSigmoid.html">HardSigmoid</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__HardSwish.html">HardSwish</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Hardmax.html">Hardmax</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Identity.html">Identity</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__If.html">If</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__InstanceNormalization.html">InstanceNormalization</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__IsInf.html">IsInf</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__IsNaN.html">IsNaN</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__LRN.html">LRN</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__LSTM.html">LSTM</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__LayerNormalization.html">LayerNormalization</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__LeakyRelu.html">LeakyRelu</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Less.html">Less</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__LessOrEqual.html">LessOrEqual</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Log.html">Log</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__LogSoftmax.html">LogSoftmax</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Loop</a><ul>
<li class="toctree-l3"><a class="reference internal" href="text_diff_Loop_13_16.html">Loop - 13 vs 16</a></li>
<li class="toctree-l3"><a class="reference internal" href="text_diff_Loop_11_13.html">Loop - 11 vs 13</a></li>
<li class="toctree-l3"><a class="reference internal" href="text_diff_Loop_1_11.html">Loop - 1 vs 11</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="onnx__LpNormalization.html">LpNormalization</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__LpPool.html">LpPool</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__MatMul.html">MatMul</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__MatMulInteger.html">MatMulInteger</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Max.html">Max</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__MaxPool.html">MaxPool</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__MaxRoiPool.html">MaxRoiPool</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__MaxUnpool.html">MaxUnpool</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Mean.html">Mean</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__MeanVarianceNormalization.html">MeanVarianceNormalization</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__MelWeightMatrix.html">MelWeightMatrix</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Min.html">Min</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Mish.html">Mish</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Mod.html">Mod</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Mul.html">Mul</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Multinomial.html">Multinomial</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Neg.html">Neg</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__NegativeLogLikelihoodLoss.html">NegativeLogLikelihoodLoss</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__NonMaxSuppression.html">NonMaxSuppression</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__NonZero.html">NonZero</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Not.html">Not</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__OneHot.html">OneHot</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Optional.html">Optional</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__OptionalGetElement.html">OptionalGetElement</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__OptionalHasElement.html">OptionalHasElement</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Or.html">Or</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__PRelu.html">PRelu</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Pad.html">Pad</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Pow.html">Pow</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__QLinearConv.html">QLinearConv</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__QLinearMatMul.html">QLinearMatMul</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__QuantizeLinear.html">QuantizeLinear</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__RNN.html">RNN</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__RandomNormal.html">RandomNormal</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__RandomNormalLike.html">RandomNormalLike</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__RandomUniform.html">RandomUniform</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__RandomUniformLike.html">RandomUniformLike</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Range.html">Range</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Reciprocal.html">Reciprocal</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__ReduceL1.html">ReduceL1</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__ReduceL2.html">ReduceL2</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__ReduceLogSum.html">ReduceLogSum</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__ReduceLogSumExp.html">ReduceLogSumExp</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__ReduceMax.html">ReduceMax</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__ReduceMean.html">ReduceMean</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__ReduceMin.html">ReduceMin</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__ReduceProd.html">ReduceProd</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__ReduceSum.html">ReduceSum</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__ReduceSumSquare.html">ReduceSumSquare</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Relu.html">Relu</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Reshape.html">Reshape</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Resize.html">Resize</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__ReverseSequence.html">ReverseSequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__RoiAlign.html">RoiAlign</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Round.html">Round</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__STFT.html">STFT</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Scan.html">Scan</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Scatter.html">Scatter</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__ScatterElements.html">ScatterElements</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__ScatterND.html">ScatterND</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Selu.html">Selu</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__SequenceAt.html">SequenceAt</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__SequenceConstruct.html">SequenceConstruct</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__SequenceEmpty.html">SequenceEmpty</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__SequenceErase.html">SequenceErase</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__SequenceInsert.html">SequenceInsert</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__SequenceLength.html">SequenceLength</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__SequenceMap.html">SequenceMap</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Shape.html">Shape</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Shrink.html">Shrink</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Sigmoid.html">Sigmoid</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Sign.html">Sign</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Sin.html">Sin</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Sinh.html">Sinh</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Size.html">Size</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Slice.html">Slice</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Softmax.html">Softmax</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__SoftmaxCrossEntropyLoss.html">SoftmaxCrossEntropyLoss</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Softplus.html">Softplus</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Softsign.html">Softsign</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__SpaceToDepth.html">SpaceToDepth</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Split.html">Split</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__SplitToSequence.html">SplitToSequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Sqrt.html">Sqrt</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Squeeze.html">Squeeze</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__StringNormalizer.html">StringNormalizer</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Sub.html">Sub</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Sum.html">Sum</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Tan.html">Tan</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Tanh.html">Tanh</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__TfIdfVectorizer.html">TfIdfVectorizer</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__ThresholdedRelu.html">ThresholdedRelu</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Tile.html">Tile</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__TopK.html">TopK</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Transpose.html">Transpose</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Trilu.html">Trilu</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Unique.html">Unique</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Unsqueeze.html">Unsqueeze</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Upsample.html">Upsample</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Where.html">Where</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx__Xor.html">Xor</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx_aionnxml_ArrayFeatureExtractor.html">ai.onnx.ml - ArrayFeatureExtractor</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx_aionnxml_Binarizer.html">ai.onnx.ml - Binarizer</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx_aionnxml_CastMap.html">ai.onnx.ml - CastMap</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx_aionnxml_CategoryMapper.html">ai.onnx.ml - CategoryMapper</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx_aionnxml_DictVectorizer.html">ai.onnx.ml - DictVectorizer</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx_aionnxml_FeatureVectorizer.html">ai.onnx.ml - FeatureVectorizer</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx_aionnxml_Imputer.html">ai.onnx.ml - Imputer</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx_aionnxml_LabelEncoder.html">ai.onnx.ml - LabelEncoder</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx_aionnxml_LinearClassifier.html">ai.onnx.ml - LinearClassifier</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx_aionnxml_LinearRegressor.html">ai.onnx.ml - LinearRegressor</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx_aionnxml_Normalizer.html">ai.onnx.ml - Normalizer</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx_aionnxml_OneHotEncoder.html">ai.onnx.ml - OneHotEncoder</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx_aionnxml_SVMClassifier.html">ai.onnx.ml - SVMClassifier</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx_aionnxml_SVMRegressor.html">ai.onnx.ml - SVMRegressor</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx_aionnxml_Scaler.html">ai.onnx.ml - Scaler</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx_aionnxml_TreeEnsembleClassifier.html">ai.onnx.ml - TreeEnsembleClassifier</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx_aionnxml_TreeEnsembleRegressor.html">ai.onnx.ml - TreeEnsembleRegressor</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx_aionnxml_ZipMap.html">ai.onnx.ml - ZipMap</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx_aionnxpreviewtraining_Adagrad.html">ai.onnx.preview.training - Adagrad</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx_aionnxpreviewtraining_Adam.html">ai.onnx.preview.training - Adam</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx_aionnxpreviewtraining_Gradient.html">ai.onnx.preview.training - Gradient</a></li>
<li class="toctree-l2"><a class="reference internal" href="onnx_aionnxpreviewtraining_Momentum.html">ai.onnx.preview.training - Momentum</a></li>
<li class="toctree-l2"><a class="reference internal" href="table_main.html">operator table for domain main</a></li>
<li class="toctree-l2"><a class="reference internal" href="table_ai_onnx_ml.html">operator table for domain ai.onnx.ml</a></li>
<li class="toctree-l2"><a class="reference internal" href="table_ai_onnx_preview_training.html">operator table for domain ai.onnx.preview.training</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../onnx_python/index.html">onnx API Overview</a></li>
</ul>

        </div>
      </div>


    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="loop">
<span id="l-onnx-doc-loop"></span><h1>Loop<a class="headerlink" href="#loop" title="Permalink to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#loop-16" id="id40">Loop - 16</a></p></li>
<li><p><a class="reference internal" href="#loop-13" id="id41">Loop - 13</a></p></li>
<li><p><a class="reference internal" href="#loop-11" id="id42">Loop - 11</a></p></li>
<li><p><a class="reference internal" href="#loop-1" id="id43">Loop - 1</a></p></li>
</ul>
</nav>
<section id="loop-16">
<span id="l-onnx-op-loop-16"></span><h2><a class="toc-backref" href="#id40" role="doc-backlink">Loop - 16</a><a class="headerlink" href="#loop-16" title="Permalink to this heading">¶</a></h2>
<p><strong>Version</strong></p>
<ul class="simple">
<li><p><strong>name</strong>: <a class="reference external" href="https://github.com/onnx/onnx/blob/main/docs/Operators.md#Loop">Loop (GitHub)</a></p></li>
<li><p><strong>domain</strong>: <strong>main</strong></p></li>
<li><p><strong>since_version</strong>: <strong>16</strong></p></li>
<li><p><strong>function</strong>: False</p></li>
<li><p><strong>support_level</strong>: SupportType.COMMON</p></li>
<li><p><strong>shape inference</strong>: True</p></li>
</ul>
<p>This version of the operator has been available
<strong>since version 16</strong>.</p>
<p><strong>Summary</strong></p>
<p>Generic Looping construct. This loop has multiple termination conditions:</p>
<ol class="arabic simple">
<li><p>Trip count. Iteration count specified at runtime. Set by
specifying the input M. Optional. Set to empty string to omit.
Note that a static trip count (specified at graph construction time) can be
specified by passing in a constant node for input M.</p></li>
<li><p>Loop termination condition. This is an input to the op that determines
whether to run the first iteration and also a loop-carried dependency for
the body graph. The body graph must yield a value for the condition variable,
whether this input is provided or not.</p></li>
</ol>
<p>This table summarizes the operating modes of this operator with equivalent
C-style code:</p>
<blockquote>
<div><p>Operator inputs defined as (max_trip_count, condition_var).</p>
<dl>
<dt>input (“”, “”):</dt><dd><dl class="simple">
<dt>for (int i=0; ; ++i) {</dt><dd><p>cond = … // Note this value is ignored, but is required in the body</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>input (“”, cond) // Note this is analogous to a while loop</dt><dd><p>bool cond = …;
for (int i=0; cond; ++i) {</p>
<blockquote>
<div><p>cond = …;</p>
</div></blockquote>
<p>}</p>
</dd>
<dt>input (“”, 1) // Note this is analogous to a do-while loop</dt><dd><p>bool cond = true
for (int i=0; cond; ++i) {</p>
<blockquote>
<div><p>cond = …;</p>
</div></blockquote>
<p>}</p>
</dd>
<dt>input (trip_count, “”) // Note this is analogous to a for loop</dt><dd><p>int trip_count = …
for (int i=0; i &lt; trip_count; ++i) {</p>
<blockquote>
<div><p>cond = …; // ignored</p>
</div></blockquote>
<p>}</p>
</dd>
<dt>input (trip_count, cond)</dt><dd><p>int trip_count = …;
bool cond = …;
for (int i=0; i &lt; trip_count &amp;&amp; cond; ++i) {</p>
<blockquote>
<div><p>cond = …;</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<p><em>Sample usage - cond as well as trip count</em></p>
<blockquote>
<div><dl class="simple">
<dt>graph predict-net {</dt><dd><p>%a = Constant[value = &lt;Scalar Tensor [3]&gt;]()
%b = Constant[value = &lt;Scalar Tensor [6]&gt;]()
%keepgoing = Constant[value = &lt;Scalar Tensor [1]&gt;]()
%max_trip_count = Constant[value = &lt;Scalar Tensor [10]&gt;]()
%keepgoing_out, %b_out, %user_defined_vals = Loop[body = &lt;graph body-net&gt;](%max_trip_count, %keepgoing, %b)
return</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>graph body-net (</dt><dd><p>%i[INT32, scalar]           // iteration number
%keepgoing_in[BOOL, scalar] // incoming loop-termination-condition; not used
%b_in[INT32, scalar]        // incoming value of loop-carried-dependency b</p>
</dd>
<dt>) {</dt><dd><p>%my_local = Add(%a, %b_in)
%b_out = Sub(%a, %b_in) // outgoing value of loop-carried-dependency b
%keepgoing_out = Greater(%my_local, %b_out) // outgoing loop-termination-condition
%user_defined_val = Add(%b_in, %b_in) // scan-output value to be accumulated
return %keepgoing_out, %b_out, %user_defined_val</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p><em>Sample equivalent C code</em></p>
<blockquote>
<div><dl>
<dt>{</dt><dd><p>/* User-defined code (enclosing scope) <em>/
int a = 3, b = 6;
bool keepgoing = true; // Analogous to input cond
/</em> End user-defined code <a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
<p>/* Implicitly-defined code <em>/
const int max_trip_count = 10; // Analogous to input M
int user_defined_vals[]; // Imagine this is resizable
/</em> End implicitly-defined code <em>/
/</em> initialize loop-carried variables and scan-output variables <a href="#id3"><span class="problematic" id="id4">*</span></a>/
bool keepgoing_out = keepgoing
int b_out = b</p>
<dl>
<dt>for (int i=0; i &lt; max_trip_count &amp;&amp; keepgoing_out; ++i) {</dt><dd><dl class="simple">
<dt>/* Implicitly-defined code: bind actual parameter values</dt><dd><p>to formal parameter variables of loop-body <a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
</dl>
<p>bool keepgoing_in = keepgoing_out;
bool b_in = b_out;</p>
<p>/* User-defined code (loop body) <em>/
int my_local = a + b_in; // Reading value “a” from the enclosing scope is fine
b_out = a - b_in;
keepgoing_out = my_local &gt; b_out;
user_defined_val = b_in + b_in; // b_in and b_out are different variables
/</em> End user-defined code <a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
<p>/* Implicitly defined-code <a href="#id9"><span class="problematic" id="id10">*</span></a>/
user_defined_vals[i] = user_defined_val // accumulate scan-output values</p>
</dd>
</dl>
<p>}
// int t = my_local; // Can’t do this. my_local is not accessible here.</p>
<p>// The values below are bound to the output variables of the loop and therefore accessible
// b_out; user_defined_vals; keepgoing_out;</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>There are several things of note in this code snippet:</p>
<ol class="arabic simple">
<li><p>Values from the enclosing scope (i.e. variable “a” here) are in scope and can
be referenced in the inputs of the loop.</p></li>
<li><p>Any values computed in the loop body that needs to be used in a subsequent
iteration or after the loop are modelled using a pair of variables in the loop-body,
consisting of an input variable (eg., b_in) and an output variable (eg., b_out).
These are referred to as loop-carried dependences. The loop operation node
supplies the input value of the input variable for the first iteration, and
returns the output value of the output variable produced by the final
iteration.</p></li>
<li><p>Scan_output variables are used to implicitly concatenate values computed across
all the iterations. In the above example, the value of user_defined_val computed
over all iterations are concatenated and returned as the value of user_defined_vals
after the loop.</p></li>
<li><p>Values created in the body cannot be accessed in the enclosing scope,
except using the mechanism described above.</p></li>
</ol>
<p>Note that the semantics of this op support “diagonal” or “wavefront” execution.
(See Step 3 here for an example:
<a class="reference external" href="https://devblogs.nvidia.com/optimizing-recurrent-neural-networks-cudnn-5/">https://devblogs.nvidia.com/optimizing-recurrent-neural-networks-cudnn-5/</a>).
Frontends should emit multi-layer RNNs as a series of While operators (with
time being the inner looping dimension), with each successive layer consuming
the scan_outputs from the previous layer, possibly going through several
point-wise operators (e.g. dropout, residual connections, linear layer).</p>
<p>The input/output of subgraph (produced by loop node) matching is based on order instead of name. The implementation will figure out the names based on this order.</p>
<p><strong>Attributes</strong></p>
<ul class="simple">
<li><p><strong>body</strong> (required):
The graph run each iteration. It has 2+N inputs: (iteration_num,
condition, loop carried dependencies…). It has 1+N+K outputs:
(condition, loop carried dependencies…, scan_outputs…). Each
scan_output is created by concatenating the value of the specified
output value at the end of each iteration of the loop. It is an
error if the dimensions or data type of these scan_outputs change
across loop iterations.</p></li>
</ul>
<p><strong>Inputs</strong></p>
<p>Between 2 and 2147483647 inputs.</p>
<ul class="simple">
<li><p><strong>M</strong> (optional, heterogeneous) - <strong>I</strong>:
A maximum trip-count for the loop specified at runtime. Optional.
Pass empty string to skip.</p></li>
<li><p><strong>cond</strong> (optional, heterogeneous) - <strong>B</strong>:
A boolean termination condition. Optional. Pass empty string to
skip.</p></li>
<li><p><strong>v_initial</strong> (variadic) - <strong>V</strong>:
The initial values of any loop-carried dependencies (values that
change across loop iterations)</p></li>
</ul>
<p><strong>Outputs</strong></p>
<p>Between 1 and 2147483647 outputs.</p>
<ul class="simple">
<li><p><strong>v_final_and_scan_outputs</strong> (variadic) - <strong>V</strong>:
Final N loop carried dependency values then K scan_outputs. Scan
outputs must be Tensors.</p></li>
</ul>
<p><strong>Type Constraints</strong></p>
<ul class="simple">
<li><p><strong>V</strong> in (
optional(seq(tensor(bfloat16))),
optional(seq(tensor(bool))),
optional(seq(tensor(complex128))),
optional(seq(tensor(complex64))),
optional(seq(tensor(double))),
optional(seq(tensor(float))),
optional(seq(tensor(float16))),
optional(seq(tensor(int16))),
optional(seq(tensor(int32))),
optional(seq(tensor(int64))),
optional(seq(tensor(int8))),
optional(seq(tensor(string))),
optional(seq(tensor(uint16))),
optional(seq(tensor(uint32))),
optional(seq(tensor(uint64))),
optional(seq(tensor(uint8))),
optional(tensor(bfloat16)),
optional(tensor(bool)),
optional(tensor(complex128)),
optional(tensor(complex64)),
optional(tensor(double)),
optional(tensor(float)),
optional(tensor(float16)),
optional(tensor(int16)),
optional(tensor(int32)),
optional(tensor(int64)),
optional(tensor(int8)),
optional(tensor(string)),
optional(tensor(uint16)),
optional(tensor(uint32)),
optional(tensor(uint64)),
optional(tensor(uint8)),
seq(tensor(bfloat16)),
seq(tensor(bool)),
seq(tensor(complex128)),
seq(tensor(complex64)),
seq(tensor(double)),
seq(tensor(float)),
seq(tensor(float16)),
seq(tensor(int16)),
seq(tensor(int32)),
seq(tensor(int64)),
seq(tensor(int8)),
seq(tensor(string)),
seq(tensor(uint16)),
seq(tensor(uint32)),
seq(tensor(uint64)),
seq(tensor(uint8)),
tensor(bfloat16),
tensor(bool),
tensor(complex128),
tensor(complex64),
tensor(double),
tensor(float),
tensor(float16),
tensor(int16),
tensor(int32),
tensor(int64),
tensor(int8),
tensor(string),
tensor(uint16),
tensor(uint32),
tensor(uint64),
tensor(uint8)
):
All Tensor, Sequence(Tensor), Optional(Tensor), and
Optional(Sequence(Tensor)) types</p></li>
<li><p><strong>I</strong> in (
tensor(int64)
):
tensor of int64, which should be a scalar.</p></li>
<li><p><strong>B</strong> in (
tensor(bool)
):
tensor of bool, which should be a scalar.</p></li>
</ul>
<p><strong>Examples</strong></p>
<p><strong>_loop_11</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">onnx</span>

<span class="c1"># Given a tensor x of values [x1, ..., xN], and initial tensor y</span>
<span class="c1"># sum up its elements using a scan</span>
<span class="c1"># returning the final state (y+x1+x2+...+xN) as well the scan_output</span>
<span class="c1"># [y+x1, y+x1+x2, ..., y+x1+x2+...+xN]</span>

<span class="n">y_in</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_tensor_value_info</span><span class="p">(</span><span class="s2">&quot;y_in&quot;</span><span class="p">,</span> <span class="n">onnx</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">y_out</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_tensor_value_info</span><span class="p">(</span><span class="s2">&quot;y_out&quot;</span><span class="p">,</span> <span class="n">onnx</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">scan_out</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_tensor_value_info</span><span class="p">(</span>
    <span class="s2">&quot;scan_out&quot;</span><span class="p">,</span> <span class="n">onnx</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="p">)</span>
<span class="n">cond_in</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_tensor_value_info</span><span class="p">(</span>
    <span class="s2">&quot;cond_in&quot;</span><span class="p">,</span> <span class="n">onnx</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">BOOL</span><span class="p">,</span> <span class="p">[]</span>
<span class="p">)</span>
<span class="n">cond_out</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_tensor_value_info</span><span class="p">(</span>
    <span class="s2">&quot;cond_out&quot;</span><span class="p">,</span> <span class="n">onnx</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">BOOL</span><span class="p">,</span> <span class="p">[]</span>
<span class="p">)</span>
<span class="n">iter_count</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_tensor_value_info</span><span class="p">(</span>
    <span class="s2">&quot;iter_count&quot;</span><span class="p">,</span> <span class="n">onnx</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">INT64</span><span class="p">,</span> <span class="p">[]</span>
<span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="n">x_const_node</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
    <span class="s2">&quot;Constant&quot;</span><span class="p">,</span>
    <span class="n">inputs</span><span class="o">=</span><span class="p">[],</span>
    <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">],</span>
    <span class="n">value</span><span class="o">=</span><span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_tensor</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s2">&quot;const_tensor_x&quot;</span><span class="p">,</span>
        <span class="n">data_type</span><span class="o">=</span><span class="n">onnx</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">,</span>
        <span class="n">dims</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
        <span class="n">vals</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span>
    <span class="p">),</span>
<span class="p">)</span>

<span class="n">one_const_node</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
    <span class="s2">&quot;Constant&quot;</span><span class="p">,</span>
    <span class="n">inputs</span><span class="o">=</span><span class="p">[],</span>
    <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;one&quot;</span><span class="p">],</span>
    <span class="n">value</span><span class="o">=</span><span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_tensor</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s2">&quot;const_tensor_one&quot;</span><span class="p">,</span>
        <span class="n">data_type</span><span class="o">=</span><span class="n">onnx</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">INT64</span><span class="p">,</span>
        <span class="n">dims</span><span class="o">=</span><span class="p">(),</span>
        <span class="n">vals</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="p">),</span>
<span class="p">)</span>

<span class="n">i_add_node</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
    <span class="s2">&quot;Add&quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;iter_count&quot;</span><span class="p">,</span> <span class="s2">&quot;one&quot;</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;end&quot;</span><span class="p">]</span>
<span class="p">)</span>

<span class="n">start_unsqueeze_node</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
    <span class="s2">&quot;Unsqueeze&quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;iter_count&quot;</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;slice_start&quot;</span><span class="p">],</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">)</span>

<span class="n">end_unsqueeze_node</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
    <span class="s2">&quot;Unsqueeze&quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;end&quot;</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;slice_end&quot;</span><span class="p">],</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">)</span>

<span class="n">slice_node</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
    <span class="s2">&quot;Slice&quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;slice_start&quot;</span><span class="p">,</span> <span class="s2">&quot;slice_end&quot;</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;slice_out&quot;</span><span class="p">]</span>
<span class="p">)</span>

<span class="n">y_add_node</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
    <span class="s2">&quot;Add&quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;y_in&quot;</span><span class="p">,</span> <span class="s2">&quot;slice_out&quot;</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;y_out&quot;</span><span class="p">]</span>
<span class="p">)</span>

<span class="n">identity_node</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
    <span class="s2">&quot;Identity&quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;cond_in&quot;</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;cond_out&quot;</span><span class="p">]</span>
<span class="p">)</span>

<span class="n">scan_identity_node</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
    <span class="s2">&quot;Identity&quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;y_out&quot;</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;scan_out&quot;</span><span class="p">]</span>
<span class="p">)</span>

<span class="n">loop_body</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_graph</span><span class="p">(</span>
    <span class="p">[</span>
        <span class="n">identity_node</span><span class="p">,</span>
        <span class="n">x_const_node</span><span class="p">,</span>
        <span class="n">one_const_node</span><span class="p">,</span>
        <span class="n">i_add_node</span><span class="p">,</span>
        <span class="n">start_unsqueeze_node</span><span class="p">,</span>
        <span class="n">end_unsqueeze_node</span><span class="p">,</span>
        <span class="n">slice_node</span><span class="p">,</span>
        <span class="n">y_add_node</span><span class="p">,</span>
        <span class="n">scan_identity_node</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="s2">&quot;loop_body&quot;</span><span class="p">,</span>
    <span class="p">[</span><span class="n">iter_count</span><span class="p">,</span> <span class="n">cond_in</span><span class="p">,</span> <span class="n">y_in</span><span class="p">],</span>
    <span class="p">[</span><span class="n">cond_out</span><span class="p">,</span> <span class="n">y_out</span><span class="p">,</span> <span class="n">scan_out</span><span class="p">],</span>
<span class="p">)</span>

<span class="n">node</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
    <span class="s2">&quot;Loop&quot;</span><span class="p">,</span>
    <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;trip_count&quot;</span><span class="p">,</span> <span class="s2">&quot;cond&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">],</span>
    <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;res_y&quot;</span><span class="p">,</span> <span class="s2">&quot;res_scan&quot;</span><span class="p">],</span>
    <span class="n">body</span><span class="o">=</span><span class="n">loop_body</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">trip_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
<span class="n">res_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">13</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
<span class="n">res_scan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">13</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">expect</span><span class="p">(</span>
    <span class="n">node</span><span class="p">,</span>
    <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">trip_count</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span>
    <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="n">res_y</span><span class="p">,</span> <span class="n">res_scan</span><span class="p">],</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;test_loop11&quot;</span><span class="p">,</span>
    <span class="n">opset_imports</span><span class="o">=</span><span class="p">[</span><span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_opsetid</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="mi">11</span><span class="p">)],</span>
<span class="p">)</span>
</pre></div>
</div>
<p><strong>_loop_13</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">onnx</span>

<span class="c1"># Given a tensor x of values [x1, ..., xN],</span>
<span class="c1"># Return a sequence of tensors of</span>
<span class="c1">#   [[x1], [x1, x2], ..., [x1, ..., xN]]</span>

<span class="n">seq_in</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_tensor_sequence_value_info</span><span class="p">(</span>
    <span class="s2">&quot;seq_in&quot;</span><span class="p">,</span> <span class="n">onnx</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">,</span> <span class="kc">None</span>
<span class="p">)</span>
<span class="n">seq_out</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_tensor_sequence_value_info</span><span class="p">(</span>
    <span class="s2">&quot;seq_out&quot;</span><span class="p">,</span> <span class="n">onnx</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">,</span> <span class="kc">None</span>
<span class="p">)</span>
<span class="n">cond_in</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_tensor_value_info</span><span class="p">(</span>
    <span class="s2">&quot;cond_in&quot;</span><span class="p">,</span> <span class="n">onnx</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">BOOL</span><span class="p">,</span> <span class="p">[]</span>
<span class="p">)</span>
<span class="n">cond_out</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_tensor_value_info</span><span class="p">(</span>
    <span class="s2">&quot;cond_out&quot;</span><span class="p">,</span> <span class="n">onnx</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">BOOL</span><span class="p">,</span> <span class="p">[]</span>
<span class="p">)</span>
<span class="n">iter_count</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_tensor_value_info</span><span class="p">(</span>
    <span class="s2">&quot;iter_count&quot;</span><span class="p">,</span> <span class="n">onnx</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">INT64</span><span class="p">,</span> <span class="p">[]</span>
<span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="n">x_const_node</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
    <span class="s2">&quot;Constant&quot;</span><span class="p">,</span>
    <span class="n">inputs</span><span class="o">=</span><span class="p">[],</span>
    <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">],</span>
    <span class="n">value</span><span class="o">=</span><span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_tensor</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s2">&quot;const_tensor_x&quot;</span><span class="p">,</span>
        <span class="n">data_type</span><span class="o">=</span><span class="n">onnx</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">,</span>
        <span class="n">dims</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
        <span class="n">vals</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span>
    <span class="p">),</span>
<span class="p">)</span>

<span class="n">one_const_node</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
    <span class="s2">&quot;Constant&quot;</span><span class="p">,</span>
    <span class="n">inputs</span><span class="o">=</span><span class="p">[],</span>
    <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;one&quot;</span><span class="p">],</span>
    <span class="n">value</span><span class="o">=</span><span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_tensor</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s2">&quot;const_tensor_one&quot;</span><span class="p">,</span>
        <span class="n">data_type</span><span class="o">=</span><span class="n">onnx</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">INT64</span><span class="p">,</span>
        <span class="n">dims</span><span class="o">=</span><span class="p">(),</span>
        <span class="n">vals</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="p">),</span>
<span class="p">)</span>

<span class="n">zero_const_node</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
    <span class="s2">&quot;Constant&quot;</span><span class="p">,</span>
    <span class="n">inputs</span><span class="o">=</span><span class="p">[],</span>
    <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;slice_start&quot;</span><span class="p">],</span>
    <span class="n">value</span><span class="o">=</span><span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_tensor</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s2">&quot;const_tensor_zero&quot;</span><span class="p">,</span>
        <span class="n">data_type</span><span class="o">=</span><span class="n">onnx</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">INT64</span><span class="p">,</span>
        <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
        <span class="n">vals</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">),</span>
<span class="p">)</span>

<span class="n">axes_node</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
    <span class="s2">&quot;Constant&quot;</span><span class="p">,</span>
    <span class="n">inputs</span><span class="o">=</span><span class="p">[],</span>
    <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;axes&quot;</span><span class="p">],</span>
    <span class="n">value</span><span class="o">=</span><span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_tensor</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s2">&quot;const_tensor_axes&quot;</span><span class="p">,</span>
        <span class="n">data_type</span><span class="o">=</span><span class="n">onnx</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">INT64</span><span class="p">,</span>
        <span class="n">dims</span><span class="o">=</span><span class="p">(),</span>
        <span class="n">vals</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">),</span>
<span class="p">)</span>

<span class="n">add_node</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
    <span class="s2">&quot;Add&quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;iter_count&quot;</span><span class="p">,</span> <span class="s2">&quot;one&quot;</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;end&quot;</span><span class="p">]</span>
<span class="p">)</span>

<span class="n">end_unsqueeze_node</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
    <span class="s2">&quot;Unsqueeze&quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;end&quot;</span><span class="p">,</span> <span class="s2">&quot;axes&quot;</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;slice_end&quot;</span><span class="p">]</span>
<span class="p">)</span>

<span class="n">slice_node</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
    <span class="s2">&quot;Slice&quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;slice_start&quot;</span><span class="p">,</span> <span class="s2">&quot;slice_end&quot;</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;slice_out&quot;</span><span class="p">]</span>
<span class="p">)</span>

<span class="n">insert_node</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
    <span class="s2">&quot;SequenceInsert&quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;seq_in&quot;</span><span class="p">,</span> <span class="s2">&quot;slice_out&quot;</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;seq_out&quot;</span><span class="p">]</span>
<span class="p">)</span>

<span class="n">identity_node</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
    <span class="s2">&quot;Identity&quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;cond_in&quot;</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;cond_out&quot;</span><span class="p">]</span>
<span class="p">)</span>

<span class="n">loop_body</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_graph</span><span class="p">(</span>
    <span class="p">[</span>
        <span class="n">identity_node</span><span class="p">,</span>
        <span class="n">x_const_node</span><span class="p">,</span>
        <span class="n">one_const_node</span><span class="p">,</span>
        <span class="n">zero_const_node</span><span class="p">,</span>
        <span class="n">add_node</span><span class="p">,</span>
        <span class="n">axes_node</span><span class="p">,</span>
        <span class="n">end_unsqueeze_node</span><span class="p">,</span>
        <span class="n">slice_node</span><span class="p">,</span>
        <span class="n">insert_node</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="s2">&quot;loop_body&quot;</span><span class="p">,</span>
    <span class="p">[</span><span class="n">iter_count</span><span class="p">,</span> <span class="n">cond_in</span><span class="p">,</span> <span class="n">seq_in</span><span class="p">],</span>
    <span class="p">[</span><span class="n">cond_out</span><span class="p">,</span> <span class="n">seq_out</span><span class="p">],</span>
<span class="p">)</span>

<span class="n">node</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
    <span class="s2">&quot;Loop&quot;</span><span class="p">,</span>
    <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;trip_count&quot;</span><span class="p">,</span> <span class="s2">&quot;cond&quot;</span><span class="p">,</span> <span class="s2">&quot;seq_empty&quot;</span><span class="p">],</span>
    <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;seq_res&quot;</span><span class="p">],</span>
    <span class="n">body</span><span class="o">=</span><span class="n">loop_body</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">trip_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
<span class="n">seq_empty</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">seq_res</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[:</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span>
<span class="n">cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
<span class="n">expect</span><span class="p">(</span>
    <span class="n">node</span><span class="p">,</span>
    <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">trip_count</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">seq_empty</span><span class="p">],</span>
    <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="n">seq_res</span><span class="p">],</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;test_loop13_seq&quot;</span><span class="p">,</span>
    <span class="n">opset_imports</span><span class="o">=</span><span class="p">[</span><span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_opsetid</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="mi">13</span><span class="p">)],</span>
    <span class="n">input_type_protos</span><span class="o">=</span><span class="p">[</span>
        <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_tensor_type_proto</span><span class="p">(</span>
            <span class="n">onnx</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">INT64</span><span class="p">,</span> <span class="n">trip_count</span><span class="o">.</span><span class="n">shape</span>
        <span class="p">),</span>
        <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_tensor_type_proto</span><span class="p">(</span><span class="n">onnx</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">BOOL</span><span class="p">,</span> <span class="n">cond</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
        <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_sequence_type_proto</span><span class="p">(</span>
            <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_tensor_type_proto</span><span class="p">(</span><span class="n">onnx</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">,</span> <span class="p">[])</span>
        <span class="p">),</span>
    <span class="p">],</span>
<span class="p">)</span>
</pre></div>
</div>
<p><strong>_loop_16_none</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">onnx</span>

<span class="c1"># Given a tensor sequence of values [x1, ..., xN], and an initial optional sequence of tensors [x0],</span>
<span class="c1"># Return a concatenated sequence of tensors of</span>
<span class="c1">#   [x0, [x1], [x1, x2], ..., [x1, ..., xN]]</span>

<span class="n">ten_in_tp</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_tensor_type_proto</span><span class="p">(</span><span class="n">onnx</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">,</span> <span class="p">[])</span>
<span class="n">seq_in_tp</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_sequence_type_proto</span><span class="p">(</span><span class="n">ten_in_tp</span><span class="p">)</span>
<span class="n">opt_in_tp</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_optional_type_proto</span><span class="p">(</span><span class="n">seq_in_tp</span><span class="p">)</span>
<span class="n">opt_in</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_value_info</span><span class="p">(</span><span class="s2">&quot;opt_seq_in&quot;</span><span class="p">,</span> <span class="n">opt_in_tp</span><span class="p">)</span>
<span class="n">seq_out</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_tensor_sequence_value_info</span><span class="p">(</span>
    <span class="s2">&quot;seq_out&quot;</span><span class="p">,</span> <span class="n">onnx</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">,</span> <span class="p">[]</span>
<span class="p">)</span>
<span class="n">cond_in</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_tensor_value_info</span><span class="p">(</span>
    <span class="s2">&quot;cond_in&quot;</span><span class="p">,</span> <span class="n">onnx</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">BOOL</span><span class="p">,</span> <span class="p">[]</span>
<span class="p">)</span>
<span class="n">cond_out</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_tensor_value_info</span><span class="p">(</span>
    <span class="s2">&quot;cond_out&quot;</span><span class="p">,</span> <span class="n">onnx</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">BOOL</span><span class="p">,</span> <span class="p">[]</span>
<span class="p">)</span>
<span class="n">iter_count</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_tensor_value_info</span><span class="p">(</span>
    <span class="s2">&quot;iter_count&quot;</span><span class="p">,</span> <span class="n">onnx</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">INT64</span><span class="p">,</span> <span class="p">[]</span>
<span class="p">)</span>

<span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="n">optional_has_elem_node</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
    <span class="s2">&quot;OptionalHasElement&quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;opt_seq_in&quot;</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;optional_has_elem&quot;</span><span class="p">]</span>
<span class="p">)</span>

<span class="n">optional_is_none</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
    <span class="s2">&quot;Not&quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;optional_has_elem&quot;</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;optional_is_none&quot;</span><span class="p">]</span>
<span class="p">)</span>

<span class="n">optional_get_elem</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
    <span class="s2">&quot;OptionalGetElement&quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;opt_seq_in&quot;</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;seq_in&quot;</span><span class="p">]</span>
<span class="p">)</span>

<span class="n">constant_in</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
    <span class="s2">&quot;Constant&quot;</span><span class="p">,</span>
    <span class="n">inputs</span><span class="o">=</span><span class="p">[],</span>
    <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;constant_in&quot;</span><span class="p">],</span>
    <span class="n">value</span><span class="o">=</span><span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_tensor</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s2">&quot;const_tensor&quot;</span><span class="p">,</span> <span class="n">data_type</span><span class="o">=</span><span class="n">onnx</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(),</span> <span class="n">vals</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="p">),</span>
<span class="p">)</span>

<span class="n">seq_const_in</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
    <span class="s2">&quot;SequenceConstruct&quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;constant_in&quot;</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;init_seq_in&quot;</span><span class="p">]</span>
<span class="p">)</span>

<span class="n">then_seq_out</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_tensor_sequence_value_info</span><span class="p">(</span>
    <span class="s2">&quot;init_seq_in&quot;</span><span class="p">,</span> <span class="n">onnx</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">,</span> <span class="p">[]</span>
<span class="p">)</span>
<span class="n">then_body</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_graph</span><span class="p">(</span>
    <span class="p">[</span><span class="n">constant_in</span><span class="p">,</span> <span class="n">seq_const_in</span><span class="p">],</span> <span class="s2">&quot;then_body&quot;</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[</span><span class="n">then_seq_out</span><span class="p">]</span>
<span class="p">)</span>

<span class="n">else_seq_out</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_tensor_sequence_value_info</span><span class="p">(</span>
    <span class="s2">&quot;seq_in&quot;</span><span class="p">,</span> <span class="n">onnx</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">,</span> <span class="p">[]</span>
<span class="p">)</span>
<span class="n">else_body</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_graph</span><span class="p">(</span>
    <span class="p">[</span><span class="n">optional_get_elem</span><span class="p">],</span> <span class="s2">&quot;else_body&quot;</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[</span><span class="n">else_seq_out</span><span class="p">]</span>
<span class="p">)</span>

<span class="n">if_node</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
    <span class="s2">&quot;If&quot;</span><span class="p">,</span>
    <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;optional_is_none&quot;</span><span class="p">],</span>
    <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;sequence&quot;</span><span class="p">],</span>
    <span class="n">then_branch</span><span class="o">=</span><span class="n">then_body</span><span class="p">,</span>
    <span class="n">else_branch</span><span class="o">=</span><span class="n">else_body</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">x_const_node</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
    <span class="s2">&quot;Constant&quot;</span><span class="p">,</span>
    <span class="n">inputs</span><span class="o">=</span><span class="p">[],</span>
    <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">],</span>
    <span class="n">value</span><span class="o">=</span><span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_tensor</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s2">&quot;const_tensor_x&quot;</span><span class="p">,</span>
        <span class="n">data_type</span><span class="o">=</span><span class="n">onnx</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">,</span>
        <span class="n">dims</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
        <span class="n">vals</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span>
    <span class="p">),</span>
<span class="p">)</span>

<span class="n">one_const_node</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
    <span class="s2">&quot;Constant&quot;</span><span class="p">,</span>
    <span class="n">inputs</span><span class="o">=</span><span class="p">[],</span>
    <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;one&quot;</span><span class="p">],</span>
    <span class="n">value</span><span class="o">=</span><span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_tensor</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s2">&quot;const_tensor_one&quot;</span><span class="p">,</span>
        <span class="n">data_type</span><span class="o">=</span><span class="n">onnx</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">INT64</span><span class="p">,</span>
        <span class="n">dims</span><span class="o">=</span><span class="p">(),</span>
        <span class="n">vals</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="p">),</span>
<span class="p">)</span>

<span class="n">zero_const_node</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
    <span class="s2">&quot;Constant&quot;</span><span class="p">,</span>
    <span class="n">inputs</span><span class="o">=</span><span class="p">[],</span>
    <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;slice_start&quot;</span><span class="p">],</span>
    <span class="n">value</span><span class="o">=</span><span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_tensor</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s2">&quot;const_tensor_zero&quot;</span><span class="p">,</span>
        <span class="n">data_type</span><span class="o">=</span><span class="n">onnx</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">INT64</span><span class="p">,</span>
        <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
        <span class="n">vals</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">),</span>
<span class="p">)</span>

<span class="n">axes_node</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
    <span class="s2">&quot;Constant&quot;</span><span class="p">,</span>
    <span class="n">inputs</span><span class="o">=</span><span class="p">[],</span>
    <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;axes&quot;</span><span class="p">],</span>
    <span class="n">value</span><span class="o">=</span><span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_tensor</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s2">&quot;const_tensor_axes&quot;</span><span class="p">,</span>
        <span class="n">data_type</span><span class="o">=</span><span class="n">onnx</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">INT64</span><span class="p">,</span>
        <span class="n">dims</span><span class="o">=</span><span class="p">(),</span>
        <span class="n">vals</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">),</span>
<span class="p">)</span>

<span class="n">add_node</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
    <span class="s2">&quot;Add&quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;iter_count&quot;</span><span class="p">,</span> <span class="s2">&quot;one&quot;</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;end&quot;</span><span class="p">]</span>
<span class="p">)</span>

<span class="n">end_unsqueeze_node</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
    <span class="s2">&quot;Unsqueeze&quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;end&quot;</span><span class="p">,</span> <span class="s2">&quot;axes&quot;</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;slice_end&quot;</span><span class="p">]</span>
<span class="p">)</span>

<span class="n">slice_node</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
    <span class="s2">&quot;Slice&quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;slice_start&quot;</span><span class="p">,</span> <span class="s2">&quot;slice_end&quot;</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;slice_out&quot;</span><span class="p">]</span>
<span class="p">)</span>

<span class="n">insert_node</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
    <span class="s2">&quot;SequenceInsert&quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;sequence&quot;</span><span class="p">,</span> <span class="s2">&quot;slice_out&quot;</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;seq_out&quot;</span><span class="p">]</span>
<span class="p">)</span>

<span class="n">identity_node</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
    <span class="s2">&quot;Identity&quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;cond_in&quot;</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;cond_out&quot;</span><span class="p">]</span>
<span class="p">)</span>

<span class="n">loop_body</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_graph</span><span class="p">(</span>
    <span class="p">[</span>
        <span class="n">identity_node</span><span class="p">,</span>
        <span class="n">optional_has_elem_node</span><span class="p">,</span>
        <span class="n">optional_is_none</span><span class="p">,</span>
        <span class="n">if_node</span><span class="p">,</span>
        <span class="n">x_const_node</span><span class="p">,</span>
        <span class="n">one_const_node</span><span class="p">,</span>
        <span class="n">zero_const_node</span><span class="p">,</span>
        <span class="n">add_node</span><span class="p">,</span>
        <span class="n">axes_node</span><span class="p">,</span>
        <span class="n">end_unsqueeze_node</span><span class="p">,</span>
        <span class="n">slice_node</span><span class="p">,</span>
        <span class="n">insert_node</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="s2">&quot;loop_body&quot;</span><span class="p">,</span>
    <span class="p">[</span><span class="n">iter_count</span><span class="p">,</span> <span class="n">cond_in</span><span class="p">,</span> <span class="n">opt_in</span><span class="p">],</span>
    <span class="p">[</span><span class="n">cond_out</span><span class="p">,</span> <span class="n">seq_out</span><span class="p">],</span>
<span class="p">)</span>

<span class="n">node</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
    <span class="s2">&quot;Loop&quot;</span><span class="p">,</span>
    <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;trip_count&quot;</span><span class="p">,</span> <span class="s2">&quot;cond&quot;</span><span class="p">,</span> <span class="s2">&quot;opt_seq&quot;</span><span class="p">],</span>
    <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;seq_res&quot;</span><span class="p">],</span>
    <span class="n">body</span><span class="o">=</span><span class="n">loop_body</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">trip_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
<span class="n">cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
<span class="n">seq_res</span> <span class="o">=</span> <span class="n">compute_loop_outputs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="n">x0</span><span class="p">],</span> <span class="n">trip_count</span><span class="p">)</span>
<span class="n">opt_seq_in</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x0</span><span class="p">]</span>
<span class="n">expect</span><span class="p">(</span>
    <span class="n">node</span><span class="p">,</span>
    <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">trip_count</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">opt_seq_in</span><span class="p">],</span>
    <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="n">seq_res</span><span class="p">],</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;test_loop16_seq_none&quot;</span><span class="p">,</span>
    <span class="n">opset_imports</span><span class="o">=</span><span class="p">[</span><span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_opsetid</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="mi">16</span><span class="p">)],</span>
    <span class="n">input_type_protos</span><span class="o">=</span><span class="p">[</span>
        <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_tensor_type_proto</span><span class="p">(</span>
            <span class="n">onnx</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">INT64</span><span class="p">,</span> <span class="n">trip_count</span><span class="o">.</span><span class="n">shape</span>
        <span class="p">),</span>
        <span class="n">onnx</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">make_tensor_type_proto</span><span class="p">(</span><span class="n">onnx</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">BOOL</span><span class="p">,</span> <span class="n">cond</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
        <span class="n">opt_in_tp</span><span class="p">,</span>
    <span class="p">],</span>
<span class="p">)</span>
</pre></div>
</div>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="text_diff_Loop_13_16.html">Loop - 13 vs 16</a></li>
</ul>
</div>
</section>
<section id="loop-13">
<span id="l-onnx-op-loop-13"></span><h2><a class="toc-backref" href="#id41" role="doc-backlink">Loop - 13</a><a class="headerlink" href="#loop-13" title="Permalink to this heading">¶</a></h2>
<p><strong>Version</strong></p>
<ul class="simple">
<li><p><strong>name</strong>: <a class="reference external" href="https://github.com/onnx/onnx/blob/main/docs/Operators.md#Loop">Loop (GitHub)</a></p></li>
<li><p><strong>domain</strong>: <strong>main</strong></p></li>
<li><p><strong>since_version</strong>: <strong>13</strong></p></li>
<li><p><strong>function</strong>: False</p></li>
<li><p><strong>support_level</strong>: SupportType.COMMON</p></li>
<li><p><strong>shape inference</strong>: True</p></li>
</ul>
<p>This version of the operator has been available
<strong>since version 13</strong>.</p>
<p><strong>Summary</strong></p>
<p>Generic Looping construct. This loop has multiple termination conditions:</p>
<ol class="arabic simple">
<li><p>Trip count. Iteration count specified at runtime. Set by
specifying the input M. Optional. Set to empty string to omit.
Note that a static trip count (specified at graph construction time) can be
specified by passing in a constant node for input M.</p></li>
<li><p>Loop termination condition. This is an input to the op that determines
whether to run the first iteration and also a loop-carried dependency for
the body graph. The body graph must yield a value for the condition variable,
whether this input is provided or not.</p></li>
</ol>
<p>This table summarizes the operating modes of this operator with equivalent
C-style code:</p>
<blockquote>
<div><p>Operator inputs defined as (max_trip_count, condition_var).</p>
<dl>
<dt>input (“”, “”):</dt><dd><dl class="simple">
<dt>for (int i=0; ; ++i) {</dt><dd><p>cond = … // Note this value is ignored, but is required in the body</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>input (“”, cond) // Note this is analogous to a while loop</dt><dd><p>bool cond = …;
for (int i=0; cond; ++i) {</p>
<blockquote>
<div><p>cond = …;</p>
</div></blockquote>
<p>}</p>
</dd>
<dt>input (“”, 1) // Note this is analogous to a do-while loop</dt><dd><p>bool cond = true
for (int i=0; cond; ++i) {</p>
<blockquote>
<div><p>cond = …;</p>
</div></blockquote>
<p>}</p>
</dd>
<dt>input (trip_count, “”) // Note this is analogous to a for loop</dt><dd><p>int trip_count = …
for (int i=0; i &lt; trip_count; ++i) {</p>
<blockquote>
<div><p>cond = …; // ignored</p>
</div></blockquote>
<p>}</p>
</dd>
<dt>input (trip_count, cond)</dt><dd><p>int trip_count = …;
bool cond = …;
for (int i=0; i &lt; trip_count &amp;&amp; cond; ++i) {</p>
<blockquote>
<div><p>cond = …;</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<p><em>Sample usage - cond as well as trip count</em></p>
<blockquote>
<div><dl class="simple">
<dt>graph predict-net {</dt><dd><p>%a = Constant[value = &lt;Scalar Tensor [3]&gt;]()
%b = Constant[value = &lt;Scalar Tensor [6]&gt;]()
%keepgoing = Constant[value = &lt;Scalar Tensor [1]&gt;]()
%max_trip_count = Constant[value = &lt;Scalar Tensor [10]&gt;]()
%keepgoing_out, %b_out, %user_defined_vals = Loop[body = &lt;graph body-net&gt;](%max_trip_count, %keepgoing, %b)
return</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>graph body-net (</dt><dd><p>%i[INT32, scalar]           // iteration number
%keepgoing_in[BOOL, scalar] // incoming loop-termination-condition; not used
%b_in[INT32, scalar]        // incoming value of loop-carried-dependency b</p>
</dd>
<dt>) {</dt><dd><p>%my_local = Add(%a, %b_in)
%b_out = Sub(%a, %b_in) // outgoing value of loop-carried-dependency b
%keepgoing_out = Greater(%my_local, %b_out) // outgoing loop-termination-condition
%user_defined_val = Add(%b_in, %b_in) // scan-output value to be accumulated
return %keepgoing_out, %b_out, %user_defined_val</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p><em>Sample equivalent C code</em></p>
<blockquote>
<div><dl>
<dt>{</dt><dd><p>/* User-defined code (enclosing scope) <em>/
int a = 3, b = 6;
bool keepgoing = true; // Analogous to input cond
/</em> End user-defined code <a href="#id12"><span class="problematic" id="id13">*</span></a>/</p>
<p>/* Implicitly-defined code <em>/
const int max_trip_count = 10; // Analogous to input M
int user_defined_vals[]; // Imagine this is resizable
/</em> End implicitly-defined code <em>/
/</em> initialize loop-carried variables and scan-output variables <a href="#id14"><span class="problematic" id="id15">*</span></a>/
bool keepgoing_out = keepgoing
int b_out = b</p>
<dl>
<dt>for (int i=0; i &lt; max_trip_count &amp;&amp; keepgoing_out; ++i) {</dt><dd><dl class="simple">
<dt>/* Implicitly-defined code: bind actual parameter values</dt><dd><p>to formal parameter variables of loop-body <a href="#id16"><span class="problematic" id="id17">*</span></a>/</p>
</dd>
</dl>
<p>bool keepgoing_in = keepgoing_out;
bool b_in = b_out;</p>
<p>/* User-defined code (loop body) <em>/
int my_local = a + b_in; // Reading value “a” from the enclosing scope is fine
b_out = a - b_in;
keepgoing_out = my_local &gt; b_out;
user_defined_val = b_in + b_in; // b_in and b_out are different variables
/</em> End user-defined code <a href="#id18"><span class="problematic" id="id19">*</span></a>/</p>
<p>/* Implicitly defined-code <a href="#id20"><span class="problematic" id="id21">*</span></a>/
user_defined_vals[i] = user_defined_val // accumulate scan-output values</p>
</dd>
</dl>
<p>}
// int t = my_local; // Can’t do this. my_local is not accessible here.</p>
<p>// The values below are bound to the output variables of the loop and therefore accessible
// b_out; user_defined_vals; keepgoing_out;</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>There are several things of note in this code snippet:</p>
<ol class="arabic simple">
<li><p>Values from the enclosing scope (i.e. variable “a” here) are in scope and can
be referenced in the inputs of the loop.</p></li>
<li><p>Any values computed in the loop body that needs to be used in a subsequent
iteration or after the loop are modelled using a pair of variables in the loop-body,
consisting of an input variable (eg., b_in) and an output variable (eg., b_out).
These are referred to as loop-carried dependences. The loop operation node
supplies the input value of the input variable for the first iteration, and
returns the output value of the output variable produced by the final
iteration.</p></li>
<li><p>Scan_output variables are used to implicitly concatenate values computed across
all the iterations. In the above example, the value of user_defined_val computed
over all iterations are concatenated and returned as the value of user_defined_vals
after the loop.</p></li>
<li><p>Values created in the body cannot be accessed in the enclosing scope,
except using the mechanism described above.</p></li>
</ol>
<p>Note that the semantics of this op support “diagonal” or “wavefront” execution.
(See Step 3 here for an example:
<a class="reference external" href="https://devblogs.nvidia.com/optimizing-recurrent-neural-networks-cudnn-5/">https://devblogs.nvidia.com/optimizing-recurrent-neural-networks-cudnn-5/</a>).
Frontends should emit multi-layer RNNs as a series of While operators (with
time being the inner looping dimension), with each successive layer consuming
the scan_outputs from the previous layer, possibly going through several
point-wise operators (e.g. dropout, residual connections, linear layer).</p>
<p>The input/output of subgraph (produced by loop node) matching is based on order instead of name. The implementation will figure out the names based on this order.</p>
<p><strong>Attributes</strong></p>
<ul class="simple">
<li><p><strong>body</strong> (required):
The graph run each iteration. It has 2+N inputs: (iteration_num,
condition, loop carried dependencies…). It has 1+N+K outputs:
(condition, loop carried dependencies…, scan_outputs…). Each
scan_output is created by concatenating the value of the specified
output value at the end of each iteration of the loop. It is an
error if the dimensions or data type of these scan_outputs change
across loop iterations.</p></li>
</ul>
<p><strong>Inputs</strong></p>
<p>Between 2 and 2147483647 inputs.</p>
<ul class="simple">
<li><p><strong>M</strong> (optional, heterogeneous) - <strong>I</strong>:
A maximum trip-count for the loop specified at runtime. Optional.
Pass empty string to skip.</p></li>
<li><p><strong>cond</strong> (optional, heterogeneous) - <strong>B</strong>:
A boolean termination condition. Optional. Pass empty string to
skip.</p></li>
<li><p><strong>v_initial</strong> (variadic) - <strong>V</strong>:
The initial values of any loop-carried dependencies (values that
change across loop iterations)</p></li>
</ul>
<p><strong>Outputs</strong></p>
<p>Between 1 and 2147483647 outputs.</p>
<ul class="simple">
<li><p><strong>v_final_and_scan_outputs</strong> (variadic) - <strong>V</strong>:
Final N loop carried dependency values then K scan_outputs. Scan
outputs must be Tensors.</p></li>
</ul>
<p><strong>Type Constraints</strong></p>
<ul class="simple">
<li><p><strong>V</strong> in (
seq(tensor(bool)),
seq(tensor(complex128)),
seq(tensor(complex64)),
seq(tensor(double)),
seq(tensor(float)),
seq(tensor(float16)),
seq(tensor(int16)),
seq(tensor(int32)),
seq(tensor(int64)),
seq(tensor(int8)),
seq(tensor(string)),
seq(tensor(uint16)),
seq(tensor(uint32)),
seq(tensor(uint64)),
seq(tensor(uint8)),
tensor(bool),
tensor(complex128),
tensor(complex64),
tensor(double),
tensor(float),
tensor(float16),
tensor(int16),
tensor(int32),
tensor(int64),
tensor(int8),
tensor(string),
tensor(uint16),
tensor(uint32),
tensor(uint64),
tensor(uint8)
):
All Tensor and Sequence types</p></li>
<li><p><strong>I</strong> in (
tensor(int64)
):
tensor of int64, which should be a scalar.</p></li>
<li><p><strong>B</strong> in (
tensor(bool)
):
tensor of bool, which should be a scalar.</p></li>
</ul>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="text_diff_Loop_11_13.html">Loop - 11 vs 13</a></li>
</ul>
</div>
</section>
<section id="loop-11">
<span id="l-onnx-op-loop-11"></span><h2><a class="toc-backref" href="#id42" role="doc-backlink">Loop - 11</a><a class="headerlink" href="#loop-11" title="Permalink to this heading">¶</a></h2>
<p><strong>Version</strong></p>
<ul class="simple">
<li><p><strong>name</strong>: <a class="reference external" href="https://github.com/onnx/onnx/blob/main/docs/Operators.md#Loop">Loop (GitHub)</a></p></li>
<li><p><strong>domain</strong>: <strong>main</strong></p></li>
<li><p><strong>since_version</strong>: <strong>11</strong></p></li>
<li><p><strong>function</strong>: False</p></li>
<li><p><strong>support_level</strong>: SupportType.COMMON</p></li>
<li><p><strong>shape inference</strong>: True</p></li>
</ul>
<p>This version of the operator has been available
<strong>since version 11</strong>.</p>
<p><strong>Summary</strong></p>
<p>Generic Looping construct. This loop has multiple termination conditions:</p>
<ol class="arabic simple">
<li><p>Trip count. Iteration count specified at runtime. Set by
specifying the input M. Optional. Set to empty string to omit.
Note that a static trip count (specified at graph construction time) can be
specified by passing in a constant node for input M.</p></li>
<li><p>Loop termination condition. This is an input to the op that determines
whether to run the first iteration and also a loop-carried dependency for
the body graph. The body graph must yield a value for the condition variable,
whether this input is provided or not.</p></li>
</ol>
<p>This table summarizes the operating modes of this operator with equivalent
C-style code:</p>
<blockquote>
<div><p>Operator inputs defined as (max_trip_count, condition_var).</p>
<dl>
<dt>input (“”, “”):</dt><dd><dl class="simple">
<dt>for (int i=0; ; ++i) {</dt><dd><p>cond = … // Note this value is ignored, but is required in the body</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>input (“”, cond) // Note this is analogous to a while loop</dt><dd><p>bool cond = …;
for (int i=0; cond; ++i) {</p>
<blockquote>
<div><p>cond = …;</p>
</div></blockquote>
<p>}</p>
</dd>
<dt>input (“”, 1) // Note this is analogous to a do-while loop</dt><dd><p>bool cond = true
for (int i=0; cond; ++i) {</p>
<blockquote>
<div><p>cond = …;</p>
</div></blockquote>
<p>}</p>
</dd>
<dt>input (trip_count, “”) // Note this is analogous to a for loop</dt><dd><p>int trip_count = …
for (int i=0; i &lt; trip_count; ++i) {</p>
<blockquote>
<div><p>cond = …; // ignored</p>
</div></blockquote>
<p>}</p>
</dd>
<dt>input (trip_count, cond)</dt><dd><p>int trip_count = …;
bool cond = …;
for (int i=0; i &lt; trip_count &amp;&amp; cond; ++i) {</p>
<blockquote>
<div><p>cond = …;</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<p><em>Sample usage - cond as well as trip count</em></p>
<blockquote>
<div><dl class="simple">
<dt>graph predict-net {</dt><dd><p>%a = Constant[value = &lt;Scalar Tensor [3]&gt;]()
%b = Constant[value = &lt;Scalar Tensor [6]&gt;]()
%keepgoing = Constant[value = &lt;Scalar Tensor [1]&gt;]()
%max_trip_count = Constant[value = &lt;Scalar Tensor [10]&gt;]()
%keepgoing_out, %b_out, %user_defined_vals = Loop[body = &lt;graph body-net&gt;](%max_trip_count, %keepgoing, %b)
return</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>graph body-net (</dt><dd><p>%i[INT32, scalar]           // iteration number
%keepgoing_in[BOOL, scalar] // incoming loop-termination-condition; not used
%b_in[INT32, scalar]        // incoming value of loop-carried-dependency b</p>
</dd>
<dt>) {</dt><dd><p>%my_local = Add(%a, %b_in)
%b_out = Sub(%a, %b_in) // outgoing value of loop-carried-dependency b
%keepgoing_out = Greater(%my_local, %b_out) // outgoing loop-termination-condition
%user_defined_val = Add(%b_in, %b_in) // scan-output value to be accumulated
return %keepgoing_out, %b_out, %user_defined_val</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p><em>Sample equivalent C code</em></p>
<blockquote>
<div><dl>
<dt>{</dt><dd><p>/* User-defined code (enclosing scope) <em>/
int a = 3, b = 6;
bool keepgoing = true; // Analogous to input cond
/</em> End user-defined code <a href="#id23"><span class="problematic" id="id24">*</span></a>/</p>
<p>/* Implicitly-defined code <em>/
const int max_trip_count = 10; // Analogous to input M
int user_defined_vals[]; // Imagine this is resizable
/</em> End implicitly-defined code <em>/
/</em> initialize loop-carried variables and scan-output variables <a href="#id25"><span class="problematic" id="id26">*</span></a>/
bool keepgoing_out = keepgoing
int b_out = b</p>
<dl>
<dt>for (int i=0; i &lt; max_trip_count &amp;&amp; keepgoing_out; ++i) {</dt><dd><dl class="simple">
<dt>/* Implicitly-defined code: bind actual parameter values</dt><dd><p>to formal parameter variables of loop-body <a href="#id27"><span class="problematic" id="id28">*</span></a>/</p>
</dd>
</dl>
<p>bool keepgoing_in = keepgoing_out;
bool b_in = b_out;</p>
<p>/* User-defined code (loop body) <em>/
int my_local = a + b_in; // Reading value “a” from the enclosing scope is fine
b_out = a - b_in;
keepgoing_out = my_local &gt; b_out;
user_defined_val = b_in + b_in; // b_in and b_out are different variables
/</em> End user-defined code <a href="#id29"><span class="problematic" id="id30">*</span></a>/</p>
<p>/* Implicitly defined-code <a href="#id31"><span class="problematic" id="id32">*</span></a>/
user_defined_vals[i] = user_defined_val // accumulate scan-output values</p>
</dd>
</dl>
<p>}
// int t = my_local; // Can’t do this. my_local is not accessible here.</p>
<p>// The values below are bound to the output variables of the loop and therefore accessible
// b_out; user_defined_vals; keepgoing_out;</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>There are several things of note in this code snippet:</p>
<ol class="arabic simple">
<li><p>Values from the enclosing scope (i.e. variable “a” here) are in scope and can
be referenced in the inputs of the loop.</p></li>
<li><p>Any values computed in the loop body that needs to be used in a subsequent
iteration or after the loop are modelled using a pair of variables in the loop-body,
consisting of an input variable (eg., b_in) and an output variable (eg., b_out).
These are referred to as loop-carried dependences. The loop operation node
supplies the input value of the input variable for the first iteration, and
returns the output value of the output variable produced by the final
iteration.</p></li>
<li><p>Scan_output variables are used to implicitly concatenate values computed across
all the iterations. In the above example, the value of user_defined_val computed
over all iterations are concatenated and returned as the value of user_defined_vals
after the loop.</p></li>
<li><p>Values created in the body cannot be accessed in the enclosing scope,
except using the mechanism described above.</p></li>
</ol>
<p>Note that the semantics of this op support “diagonal” or “wavefront” execution.
(See Step 3 here for an example:
<a class="reference external" href="https://devblogs.nvidia.com/optimizing-recurrent-neural-networks-cudnn-5/">https://devblogs.nvidia.com/optimizing-recurrent-neural-networks-cudnn-5/</a>).
Frontends should emit multi-layer RNNs as a series of While operators (with
time being the inner looping dimension), with each successive layer consuming
the scan_outputs from the previous layer, possibly going through several
point-wise operators (e.g. dropout, residual connections, linear layer).</p>
<p><strong>Attributes</strong></p>
<ul class="simple">
<li><p><strong>body</strong> (required):
The graph run each iteration. It has 2+N inputs: (iteration_num,
condition, loop carried dependencies…). It has 1+N+K outputs:
(condition, loop carried dependencies…, scan_outputs…). Each
scan_output is created by concatenating the value of the specified
output value at the end of each iteration of the loop. It is an
error if the dimensions or data type of these scan_outputs change
across loop iterations.</p></li>
</ul>
<p><strong>Inputs</strong></p>
<p>Between 2 and 2147483647 inputs.</p>
<ul class="simple">
<li><p><strong>M</strong> (optional, heterogeneous) - <strong>I</strong>:
A maximum trip-count for the loop specified at runtime. Optional.
Pass empty string to skip.</p></li>
<li><p><strong>cond</strong> (optional, heterogeneous) - <strong>B</strong>:
A boolean termination condition. Optional. Pass empty string to
skip.</p></li>
<li><p><strong>v_initial</strong> (variadic) - <strong>V</strong>:
The initial values of any loop-carried dependencies (values that
change across loop iterations)</p></li>
</ul>
<p><strong>Outputs</strong></p>
<p>Between 1 and 2147483647 outputs.</p>
<ul class="simple">
<li><p><strong>v_final_and_scan_outputs</strong> (variadic) - <strong>V</strong>:
Final N loop carried dependency values then K scan_outputs</p></li>
</ul>
<p><strong>Type Constraints</strong></p>
<ul class="simple">
<li><p><strong>V</strong> in (
tensor(bool),
tensor(complex128),
tensor(complex64),
tensor(double),
tensor(float),
tensor(float16),
tensor(int16),
tensor(int32),
tensor(int64),
tensor(int8),
tensor(string),
tensor(uint16),
tensor(uint32),
tensor(uint64),
tensor(uint8)
):
All Tensor types</p></li>
<li><p><strong>I</strong> in (
tensor(int64)
):
tensor of int64, which should be a scalar.</p></li>
<li><p><strong>B</strong> in (
tensor(bool)
):
tensor of bool, which should be a scalar.</p></li>
</ul>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="text_diff_Loop_1_11.html">Loop - 1 vs 11</a></li>
</ul>
</div>
</section>
<section id="loop-1">
<span id="l-onnx-op-loop-1"></span><h2><a class="toc-backref" href="#id43" role="doc-backlink">Loop - 1</a><a class="headerlink" href="#loop-1" title="Permalink to this heading">¶</a></h2>
<p><strong>Version</strong></p>
<ul class="simple">
<li><p><strong>name</strong>: <a class="reference external" href="https://github.com/onnx/onnx/blob/main/docs/Operators.md#Loop">Loop (GitHub)</a></p></li>
<li><p><strong>domain</strong>: <strong>main</strong></p></li>
<li><p><strong>since_version</strong>: <strong>1</strong></p></li>
<li><p><strong>function</strong>: False</p></li>
<li><p><strong>support_level</strong>: SupportType.COMMON</p></li>
<li><p><strong>shape inference</strong>: True</p></li>
</ul>
<p>This version of the operator has been available
<strong>since version 1</strong>.</p>
<p><strong>Summary</strong></p>
<p>Generic Looping construct. This loop has multiple termination conditions:</p>
<ol class="arabic simple">
<li><p>Trip count. Iteration count specified at runtime. Set by
specifying the input M. Optional. Set to empty string to omit.
Note that a static trip count (specified at graph construction time) can be
specified by passing in a constant node for input M.</p></li>
<li><p>Loop termination condition. This is an input to the op that determines
whether to run the first iteration and also a loop-carried dependency for
the body graph. The body graph must yield a value for the condition variable,
whether this input is provided or not.</p></li>
</ol>
<p>This table summarizes the operating modes of this operator with equivalent
C-style code:</p>
<blockquote>
<div><p>Operator inputs defined as (max_trip_count, condition_var).</p>
<dl>
<dt>input (“”, “”):</dt><dd><dl class="simple">
<dt>for (int i=0; ; ++i) {</dt><dd><p>cond = … // Note this value is ignored, but is required in the body</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>input (“”, cond) // Note this is analogous to a while loop</dt><dd><p>bool cond = …;
for (int i=0; cond; ++i) {</p>
<blockquote>
<div><p>cond = …;</p>
</div></blockquote>
<p>}</p>
</dd>
<dt>input (“”, 1) // Note this is analogous to a do-while loop</dt><dd><p>bool cond = true
for (int i=0; cond; ++i) {</p>
<blockquote>
<div><p>cond = …;</p>
</div></blockquote>
<p>}</p>
</dd>
<dt>input (trip_count, “”) // Note this is analogous to a for loop</dt><dd><p>int trip_count = …
for (int i=0; i &lt; trip_count; ++i) {</p>
<blockquote>
<div><p>cond = …; // ignored</p>
</div></blockquote>
<p>}</p>
</dd>
<dt>input (trip_count, cond)</dt><dd><p>int trip_count = …;
bool cond = …;
for (int i=0; i &lt; trip_count &amp;&amp; cond; ++i) {</p>
<blockquote>
<div><p>cond = …;</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<p><em>Sample usage - cond as well as trip count</em></p>
<blockquote>
<div><dl class="simple">
<dt>graph predict-net {</dt><dd><p>%a = Constant[value = &lt;Scalar Tensor [3]&gt;]()
%b = Constant[value = &lt;Scalar Tensor [6]&gt;]()
%keepgoing = Constant[value = &lt;Scalar Tensor [1]&gt;]()
%max_trip_count = Constant[value = &lt;Scalar Tensor [10]&gt;]()
%keepgoing_out, %b_out, %user_defined_vals = Loop[body = &lt;graph body-net&gt;](%max_trip_count, %keepgoing, %b)
return</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>graph body-net (</dt><dd><p>%i[INT32, scalar]
%keepgoing[BOOL, scalar]
%b[INT32, scalar]</p>
</dd>
<dt>) {</dt><dd><p>%my_local = Add(%a, %b)
%b_out = Sub(%a, %b)
%keepgoing_out = Greater(%my_local, %b_out)
%user_defined_vals = Add(%b, %b)
return %keepgoing_out, %b_out, %user_defined_vals</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p><em>Sample equivalent C code</em></p>
<blockquote>
<div><dl>
<dt>{</dt><dd><p>/* User-defined code (enclosing scope) <em>/
int a = 3, b = 6;
bool keepgoing = true; // Analogous to input cond
/</em> End user-defined code <a href="#id34"><span class="problematic" id="id35">*</span></a>/</p>
<p>/* Implicitly-defined code <em>/
const int max_trip_count = 10; // Analogous to input M
int user_defined_vals[]; // Imagine this is resizable
/</em> End implicitly-defined code <a href="#id36"><span class="problematic" id="id37">*</span></a>/
for (int i=0; i &lt; max_trip_count &amp;&amp; keepgoing; ++i) {</p>
<blockquote>
<div><p>/* User-defined code (loop body) <em>/
int my_local = a + b; // Reading values in the enclosing scope is fine
b = a - b; // writes fine if we specify b as a loop-carried dependency
keepgoing = my_local &gt; b; // keepgoing is a loop-carried dependency
user_defined_vals[i] = b + b;
/</em> End user-defined code <a href="#id38"><span class="problematic" id="id39">*</span></a>/</p>
</div></blockquote>
<p>}
// my_local = 123; // Can’t do this. my_local was defined in the body</p>
<p>// These below values are live-out from the loop and therefore accessible
b_out; user_defined_vals; keepgoing_out;</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>There are several things of note in this code snippet:</p>
<ol class="arabic simple">
<li><p>Values from the enclosing scope (i.e. variable a here) are in scope and can
be referenced in the inputs of the loop.</p></li>
<li><p>Any variables which you wish to make available in the enclosing scope (i.e.
the variables b and keepgoing) must be declared as either loop-carried
dependencies (both at the op inputs and output and at the body net input and
output) or scan_outputs.</p></li>
<li><p>Values created in the body cannot be accessed in the enclosing scope.</p></li>
</ol>
<p>Note that the semantics of this op support “diagonal” or “wavefront” execution.
(See Step 3 here for an example:
<a class="reference external" href="https://devblogs.nvidia.com/optimizing-recurrent-neural-networks-cudnn-5/">https://devblogs.nvidia.com/optimizing-recurrent-neural-networks-cudnn-5/</a>).
Frontends should emit multi-layer RNNs as a series of While operators (with
time being the inner looping dimension), with each successive layer consuming
the scan_outputs from the previous layer, possibly going through several
point-wise operators (e.g. dropout, residual connections, linear layer).</p>
<p><strong>Attributes</strong></p>
<ul class="simple">
<li><p><strong>body</strong> (required):
The graph run each iteration. It has 2+N inputs: (iteration_num,
condition, loop carried dependencies…). It has 1+N+K outputs:
(condition, loop carried dependencies…, scan_outputs…). Each
scan_output is created by concatenating the value of the specified
output value at the end of each iteration of the loop. It is an
error if the dimensions or data type of these scan_outputs change
across loop iterations.</p></li>
</ul>
<p><strong>Inputs</strong></p>
<p>Between 3 and 2147483647 inputs.</p>
<ul class="simple">
<li><p><strong>M</strong> (optional, heterogeneous) - <strong>I</strong>:
A maximum trip-count for the loop specified at runtime. Optional.
Pass empty string to skip.</p></li>
<li><p><strong>cond</strong> (optional, heterogeneous) - <strong>B</strong>:
A boolean termination condition. Optional. Pass empty string to
skip.</p></li>
<li><p><strong>v_initial</strong> (variadic) - <strong>V</strong>:
The initial values of any loop-carried dependencies (values that
change across loop iterations)</p></li>
</ul>
<p><strong>Outputs</strong></p>
<p>Between 1 and 2147483647 outputs.</p>
<ul class="simple">
<li><p><strong>v_final_and_scan_outputs</strong> (variadic) - <strong>V</strong>:
Final N loop carried dependency values then K scan_outputs</p></li>
</ul>
<p><strong>Type Constraints</strong></p>
<ul class="simple">
<li><p><strong>V</strong> in (
tensor(bool),
tensor(complex128),
tensor(complex64),
tensor(double),
tensor(float),
tensor(float16),
tensor(int16),
tensor(int32),
tensor(int64),
tensor(int8),
tensor(string),
tensor(uint16),
tensor(uint32),
tensor(uint64),
tensor(uint8)
):
All Tensor types</p></li>
<li><p><strong>I</strong> in (
tensor(int64)
):
tensor of int64, which should be a scalar.</p></li>
<li><p><strong>B</strong> in (
tensor(bool)
):
tensor of bool, which should be a scalar.</p></li>
</ul>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
    
        <div id="show_right_sidebar">
            <p><a class="toggle_right_sidebar" href="#"><span class="icon"><</span><span>Page contents<span></a></p>
        </div>

        <div id="right_sidebar">
            <p><a class="toggle_right_sidebar" href="#"><span class="icon">></span><span>Page contents:<span></a></p>
            <div class="page_toc">
                <ul>
<li><a class="reference internal" href="#">Loop</a><ul>
<li><a class="reference internal" href="#loop-16">Loop - 16</a></li>
<li><a class="reference internal" href="#loop-13">Loop - 13</a></li>
<li><a class="reference internal" href="#loop-11">Loop - 11</a></li>
<li><a class="reference internal" href="#loop-1">Loop - 1</a></li>
</ul>
</li>
</ul>

            </div>
        </div>
    

      <div class="clearer"></div>
    </div>
    <div class="button_nav_wrapper">
        <div class="button_nav">
            <div class="left">
                
                <a href="text_diff_LogSoftmax_1_11.html">
                    <span class="icon"><</span><span>LogSoftmax - 1 vs 11</span></a>
                
            </div>

            <div class="right">
                
                    <a href="text_diff_Loop_13_16.html"><span>Loop - 13 vs 16</span><span class="icon">></span></a>
                
            </div>
        </div>
    </div>


    <div class="footer" role="contentinfo">
        &#169; Copyright 2022.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.1.1.
    </div>

<p id="theme_credit">Styled using the <a href="https://github.com/piccolo-orm/piccolo_theme">Piccolo Theme</a></p>
  </body>
</html>