Resize - 10 vs 11
=================

Next section compares an older to a newer version of the same operator 
after both definition are converted into markdown text.
Green means an addition to the newer version, red means a deletion.
Anything else is unchanged.

.. raw:: html


    <div id="div_Resize_4"></div>
    <link rel="stylesheet" type="text/css" href="../_static/diff2html.min.css" />
    <script type="text/javascript" src="../_static/diff2html-ui.min.js"></script>
    <script>
    const diffString = `
    --- a/Resize10
    +++ b/Resize11
    @@ -1 +1 @@
    - Resize the input tensor.
    + Resize the input tensor. In general, it calculates every value in the output tensor as a weighted average of neighborhood (a.k.a. sampling locations) in the input tensor.
      Each dimension value of the output tensor is:
    -   output_dimension = floor(input_dimension * scale).
    +   output_dimension = floor(input_dimension * (roi_end - roi_start) * scale) if input \&amp;#34;sizes\&amp;#34; is not specified.
  
      **Attributes**
  
    + * **coordinate_transformation_mode**:
    +    This attribute describes how to transform the coordinate in the
    +   resized tensor to the coordinate in the original tensor. &amp;lt;br/&amp;gt;  The
    +   coordinate of each dimension is transformed individually. Let&amp;#39;s
    +   describe a case using axis x as an example. Denote x_resized as the
    +   coordinate of axis x in the resized tensor, x_original as the
    +   coordinate of axis x in the original tensor, length_original as the
    +   length of the original tensor in axis x, length_resized as the
    +   length of the resized tensor in axis x, roi_x = (start_x, end_x) of
    +   the axis x in input &amp;#34;roi&amp;#34;, scale = length_resized / length_original,
    +   &amp;lt;br/&amp;gt;  if coordinate_transformation_mode is &amp;#34;half_pixel&amp;#34;, &amp;lt;br/&amp;gt;
    +   x_original = (x_resized + 0.5) / scale - 0.5, &amp;lt;br/&amp;gt;  if
    +   coordinate_transformation_mode is &amp;#34;pytorch_half_pixel&amp;#34;, &amp;lt;br/&amp;gt;
    +   x_original = length_resized &amp;gt; 1 ? (x_resized + 0.5) / scale - 0.5 :
    +   0, &amp;lt;br/&amp;gt;  if coordinate_transformation_mode is &amp;#34;align_corners&amp;#34;,
    +   &amp;lt;br/&amp;gt; x_original = x_resized * (length_original - 1) /
    +   (length_resized - 1), &amp;lt;br/&amp;gt;  if coordinate_transformation_mode is
    +   &amp;#34;asymmetric&amp;#34;, &amp;lt;br/&amp;gt; x_original = x_resized / scale, &amp;lt;br/&amp;gt;  if
    +   coordinate_transformation_mode is &amp;#34;tf_half_pixel_for_nn&amp;#34;, &amp;lt;br/&amp;gt;
    +   x_original = (x_resized + 0.5) / scale, &amp;lt;br/&amp;gt;  if
    +   coordinate_transformation_mode is &amp;#34;tf_crop_and_resize&amp;#34;, &amp;lt;br/&amp;gt;
    +   x_original = length_resized &amp;gt; 1 ? start_x * (length_original - 1) +
    +   x_resized * (end_x - start_x) * (length_original - 1) /
    +   (length_resized - 1) : 0.5 * (start_x + end_x) * (length_original -
    +   1).
    + * **cubic_coeff_a**:
    +   The coefficient &amp;#39;a&amp;#39; used in cubic interpolation. Two common choice
    +   are -0.5 (in some cases of TensorFlow) and -0.75 (in PyTorch). Check
    +   out Equation (4) in https://ieeexplore.ieee.org/document/1163711 for
    +   the details. This attribute is valid only if &amp;#34;mode&amp;#34; is &amp;#34;cubic&amp;#34;.
    + * **exclude_outside**:
    +   If set to 1, the weight of sampling locations outside the tensor
    +   will be set to 0 and the weight will be renormalized so that their
    +   sum is 1.0. The default value is 0.
    + * **extrapolation_value**:
    +   When coordinate_transformation_mode is &amp;#34;tf_crop_and_resize&amp;#34; and
    +   x_original is outside the range [0, length_original - 1], this value
    +   is used as the corresponding output value. Default is 0.0f.
      * **mode**:
    -   Two interpolation modes: nearest (default), and linear (including
    ?    ^^                                         ----       ^ - ^^^^^^
    +   Three interpolation modes: nearest (default), linear and cubic. The
    ?    ^^^^                                                ^^^^^^^  ^^^^^
    -   bilinear, trilinear, etc)
    +   &amp;#34;linear&amp;#34; mode includes linear interpolation for 1D tensor and
    +   N-linear interpolation for N-D tensor (for example, bilinear
    +   interpolation for 2D tensor). The &amp;#34;cubic&amp;#34; mode includes cubic
    +   interpolation for 1D tensor and N-cubic interpolation for N-D tensor
    +   (for example, bicubic interpolation for 2D tensor).
    + * **nearest_mode**:
    +   Four modes: round_prefer_floor (default, as known as round half
    +   down), round_prefer_ceil (as known as round half up), floor, ceil.
    +   Only used by nearest interpolation. It indicates how to get
    +   &amp;#34;nearest&amp;#34; pixel in input tensor from x_original, so this attribute
    +   is valid only if &amp;#34;mode&amp;#34; is &amp;#34;nearest&amp;#34;.
  
      **Inputs**
  
    + Between 3 and 4 inputs.
    + 
    - * **X** (heterogeneous) - **T**:
    + * **X** (heterogeneous) - **T1**:
    ?                              +
        N-D tensor
    + * **roi** (heterogeneous) - **T2**:
    +   1-D tensor given as [start1, ..., startN, end1, ..., endN], where N
    +   is the rank of X. The RoIs&amp;#39; coordinates are normalized in the
    +   coordinate system of the input image. It only takes effect when
    +   coordinate_transformation_mode is &amp;#34;tf_crop_and_resize&amp;#34;
      * **scales** (heterogeneous) - **tensor(float)**:
        The scale array along each dimension. It takes value greater than 0.
        If it&amp;#39;s less than 1, it&amp;#39;s sampling down, otherwise, it&amp;#39;s upsampling.
        The number of elements of &amp;#39;scales&amp;#39; should be the same as the rank of
    -   input &amp;#39;X&amp;#39;.
    +   input &amp;#39;X&amp;#39;. If &amp;#39;size&amp;#39; is needed, the user must set &amp;#39;scales&amp;#39; to an
    +   empty tensor.
    + * **sizes** (optional, heterogeneous) - **tensor(int64)**:
    +   The size of the output tensor. The number of elements of &amp;#39;sizes&amp;#39;
    +   should be the same as the rank of input &amp;#39;X&amp;#39;. May only be set if
    +   &amp;#39;scales&amp;#39; is set to an empty tensor.
  
      **Outputs**
  
    - * **Y** (heterogeneous) - **T**:
    + * **Y** (heterogeneous) - **T1**:
    ?                              +
        N-D tensor after resizing
  
      **Type Constraints**
  
    - * **T** in (
    + * **T1** in (
    ?      +
        tensor(bool),
        tensor(complex128),
        tensor(complex64),
        tensor(double),
        tensor(float),
        tensor(float16),
        tensor(int16),
        tensor(int32),
        tensor(int64),
        tensor(int8),
        tensor(string),
        tensor(uint16),
        tensor(uint32),
        tensor(uint64),
        tensor(uint8)
        ):
    -   Constrain input &amp;#39;X&amp;#39; and output &amp;#39;Y&amp;#39; to all tensor types.+   Constrain input &amp;#39;X&amp;#39; and output &amp;#39;Y&amp;#39; to all tensor types.
    ?                                                                          +
    + * **T2** in (
    +   tensor(double),
    +   tensor(float),
    +   tensor(float16)
    +   ):
    +   Constrain roi type to float or double.
    `;

    document.addEventListener('DOMContentLoaded', function () {
    var targetElement = document.getElementById('div_Resize_4');
    var configuration = {
        drawFileList: true,
        fileListToggle: false,
        fileListStartVisible: false,
        fileContentToggle: false,
        matching: 'lines',
        outputFormat: 'line-by-line',
        synchronisedScroll: true,
        highlight: true,
        renderNothingWhenEmpty: false,
    };
    var diff2htmlUi = new Diff2HtmlUI(targetElement, diffString, configuration);
    diff2htmlUi.draw();
    diff2htmlUi.highlightCode();
    });
    </script>