Cast - 9 vs 13
==============

Next section compares an older to a newer version of the same operator 
after both definition are converted into markdown text.
Green means an addition to the newer version, red means a deletion.
Anything else is unchanged.

.. raw:: html


    <div id="div_Cast_2"></div>
    <link rel="stylesheet" type="text/css" href="../_static/diff2html.min.css" />
    <script type="text/javascript" src="../_static/diff2html-ui.min.js"></script>
    <script>
    const diffString = `
    --- a/Cast9
    +++ b/Cast13
    @@ -1 +1 @@
      The operator casts the elements of a given input tensor to a data type
      specified by the &amp;#39;to&amp;#39; argument and returns an output tensor of the same size in
      the converted type. The &amp;#39;to&amp;#39; argument must be one of the data types specified
      in the &amp;#39;DataType&amp;#39; enum field in the TensorProto message.
  
      Casting from string tensor in plain (e.g., &amp;#34;3.14&amp;#34; and &amp;#34;1000&amp;#34;) and scientific numeric representations
      (e.g., &amp;#34;1e-5&amp;#34; and &amp;#34;1E8&amp;#34;) to float types is supported. For example, converting string &amp;#34;100.5&amp;#34; to an integer may
      result 100. There are some string literals reserved for special floating-point values;
      &amp;#34;+INF&amp;#34; (and &amp;#34;INF&amp;#34;), &amp;#34;-INF&amp;#34;, and &amp;#34;NaN&amp;#34; are positive infinity, negative infinity, and not-a-number, respectively.
      Any string which can exactly match &amp;#34;+INF&amp;#34; in a case-insensitive way would be mapped to positive infinite. Similarly,
      this case-insensitive rule is applied to &amp;#34;INF&amp;#34; and &amp;#34;NaN&amp;#34;. When casting from numeric tensors
      to string tensors, plain floating-point representation (such as &amp;#34;314.15926&amp;#34;) would be used.
      Converting non-numerical-literal string such as &amp;#34;Hello World!&amp;#34; is an undefined behavior. Cases
      of converting string representing floating-point arithmetic value, such as &amp;#34;2.718&amp;#34;, to INT is an undefined behavior.
  
      Conversion from a numerical type to any numerical type is always allowed.
      User must be aware of precision loss and value change caused by range difference between two types.
      For example, a 64-bit float 3.1415926459 may be round to a 32-bit float 3.141592. Similarly, converting
      an integer 36 to Boolean may produce 1 because we truncate bits which can&amp;#39;t be stored in the targeted type.
    + 
    + In more detail, the conversion among numerical types should follow these rules:
    + 
    + * Casting from floating point to:
    +   * floating point: +/- infinity if OOR (out of range).
    +   * fixed point: undefined if OOR.
    +   * bool: +/- 0.0 to False; all else to True.
    + * Casting from fixed point to:
    +   * floating point: +/- infinity if OOR. (+ infinity in the case of uint)
    +   * fixed point: when OOR, discard higher bits and reinterpret (with respect to two&amp;#39;s complement representation for
    + signed types). For example, 200 (int16) -&amp;gt; -56 (int8).
    +   * bool: zero to False; nonzero to True.
    + * Casting from bool to:
    +   * floating point: {1.0, 0.0}.
    +   * fixed point: {1, 0}.
    +   * bool: no change.
  
      **Attributes**
  
      * **to** (required):
        The data type to which the elements of the input tensor are cast.
        Strictly must be one of the types from DataType enum in TensorProto
  
      **Inputs**
  
      * **input** (heterogeneous) - **T1**:
        Input tensor to be cast.
  
      **Outputs**
  
      * **output** (heterogeneous) - **T2**:
        Output tensor with the same shape as input with type specified by
        the &amp;#39;to&amp;#39; argument
  
      **Type Constraints**
  
      * **T1** in (
    +   tensor(bfloat16),
        tensor(bool),
        tensor(double),
        tensor(float),
        tensor(float16),
        tensor(int16),
        tensor(int32),
        tensor(int64),
        tensor(int8),
        tensor(string),
        tensor(uint16),
        tensor(uint32),
        tensor(uint64),
        tensor(uint8)
        ):
        Constrain input types. Casting from complex is not supported.
      * **T2** in (
    +   tensor(bfloat16),
        tensor(bool),
        tensor(double),
        tensor(float),
        tensor(float16),
        tensor(int16),
        tensor(int32),
        tensor(int64),
        tensor(int8),
        tensor(string),
        tensor(uint16),
        tensor(uint32),
        tensor(uint64),
        tensor(uint8)
        ):
        Constrain output types. Casting to complex is not supported.
    `;

    document.addEventListener('DOMContentLoaded', function () {
    var targetElement = document.getElementById('div_Cast_2');
    var configuration = {
        drawFileList: true,
        fileListToggle: false,
        fileListStartVisible: false,
        fileContentToggle: false,
        matching: 'lines',
        outputFormat: 'line-by-line',
        synchronisedScroll: true,
        highlight: true,
        renderNothingWhenEmpty: false,
    };
    var diff2htmlUi = new Diff2HtmlUI(targetElement, diffString, configuration);
    diff2htmlUi.draw();
    diff2htmlUi.highlightCode();
    });
    </script>