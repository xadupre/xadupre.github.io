
.. _l-onnx-doc-Mod:

===
Mod
===

.. contents::
    :local:


.. _l-onnx-op-mod-13:

Mod - 13
========

**Version**

* **name**: `Mod (GitHub) <https://github.com/onnx/onnx/blob/main/docs/Operators.md#Mod>`_
* **domain**: **main**
* **since_version**: **13**
* **function**: False
* **support_level**: SupportType.COMMON
* **shape inference**: True

This version of the operator has been available
**since version 13**.

**Summary**

Performs element-wise binary modulus (with Numpy-style broadcasting support).
  The sign of the remainder is the same as that of the Divisor.

  Mod operator can also behave like C fmod() or numpy.fmod. In this case, the sign of the remainder however, will be the same as the Dividend
  (in contrast to integer mod). To force a behavior like numpy.fmod() an 'fmod' Attribute is provided.
  This attribute is set to 0 by default causing the behavior to be like integer mod.
  Setting this attribute to 1 causes the remainder to be calculated similar to that of numpy.fmod().

  If the input type is floating point, then `fmod` attribute must be set to 1.

  In case of dividend being zero, the results will be platform dependent.

This operator supports **multidirectional (i.e., Numpy-style) broadcasting**; for more details please check `Broadcasting in ONNX <https://github.com/onnx/onnx/blob/master/docs/Broadcasting.md>`_.

**Attributes**

* **fmod**:
  Whether the operator should behave like fmod (default=0 meaning it
  will do integer mods); Set this to 1 to force fmod treatment

**Inputs**

* **A** (heterogeneous) - **T**:
  Dividend tensor
* **B** (heterogeneous) - **T**:
  Divisor tensor

**Outputs**

* **C** (heterogeneous) - **T**:
  Remainder tensor

**Type Constraints**

* **T** in (
  tensor(bfloat16),
  tensor(double),
  tensor(float),
  tensor(float16),
  tensor(int16),
  tensor(int32),
  tensor(int64),
  tensor(int8),
  tensor(uint16),
  tensor(uint32),
  tensor(uint64),
  tensor(uint8)
  ):
  Constrain input and output types to high-precision numeric tensors.

**Examples**

**_mod_mixed_sign_float64**

::

    node = onnx.helper.make_node("Mod", inputs=["x", "y"], outputs=["z"], fmod=1)

    x = np.array([-4.3, 7.2, 5.0, 4.3, -7.2, 8.0]).astype(np.float64)
    y = np.array([2.1, -3.4, 8.0, -2.1, 3.4, 5.0]).astype(np.float64)
    z = np.fmod(x, y)  # expected output [-0.1,  0.4,  5. ,  0.1, -0.4,  3.]
    expect(node, inputs=[x, y], outputs=[z], name="test_mod_mixed_sign_float64")

**_mod_mixed_sign_float32**

::

    node = onnx.helper.make_node("Mod", inputs=["x", "y"], outputs=["z"], fmod=1)

    x = np.array([-4.3, 7.2, 5.0, 4.3, -7.2, 8.0]).astype(np.float32)
    y = np.array([2.1, -3.4, 8.0, -2.1, 3.4, 5.0]).astype(np.float32)
    z = np.fmod(
        x, y
    )  # expected output [-0.10000038, 0.39999962, 5. , 0.10000038, -0.39999962, 3.]
    expect(node, inputs=[x, y], outputs=[z], name="test_mod_mixed_sign_float32")

**_mod_mixed_sign_float16**

::

    node = onnx.helper.make_node("Mod", inputs=["x", "y"], outputs=["z"], fmod=1)

    x = np.array([-4.3, 7.2, 5.0, 4.3, -7.2, 8.0]).astype(np.float16)
    y = np.array([2.1, -3.4, 8.0, -2.1, 3.4, 5.0]).astype(np.float16)
    z = np.fmod(
        x, y
    )  # expected output [-0.10156, 0.3984 , 5. , 0.10156, -0.3984 ,  3.]
    expect(node, inputs=[x, y], outputs=[z], name="test_mod_mixed_sign_float16")

**_mod_mixed_sign_int64**

::

    node = onnx.helper.make_node(
        "Mod",
        inputs=["x", "y"],
        outputs=["z"],
    )

    x = np.array([-4, 7, 5, 4, -7, 8]).astype(np.int64)
    y = np.array([2, -3, 8, -2, 3, 5]).astype(np.int64)
    z = np.mod(x, y)  # expected output [ 0, -2,  5,  0,  2,  3]
    expect(node, inputs=[x, y], outputs=[z], name="test_mod_mixed_sign_int64")

**_mod_mixed_sign_int32**

::

    node = onnx.helper.make_node(
        "Mod",
        inputs=["x", "y"],
        outputs=["z"],
    )

    x = np.array([-4, 7, 5, 4, -7, 8]).astype(np.int32)
    y = np.array([2, -3, 8, -2, 3, 5]).astype(np.int32)
    z = np.mod(x, y)  # expected output [ 0, -2,  5,  0,  2,  3]
    expect(node, inputs=[x, y], outputs=[z], name="test_mod_mixed_sign_int32")

**_mod_mixed_sign_int16**

::

    node = onnx.helper.make_node(
        "Mod",
        inputs=["x", "y"],
        outputs=["z"],
    )

    x = np.array([-4, 7, 5, 4, -7, 8]).astype(np.int16)
    y = np.array([2, -3, 8, -2, 3, 5]).astype(np.int16)
    z = np.mod(x, y)  # expected output [ 0, -2,  5,  0,  2,  3]
    expect(node, inputs=[x, y], outputs=[z], name="test_mod_mixed_sign_int16")

**_mod_mixed_sign_int8**

::

    node = onnx.helper.make_node(
        "Mod",
        inputs=["x", "y"],
        outputs=["z"],
    )

    x = np.array([-4, 7, 5, 4, -7, 8]).astype(np.int8)
    y = np.array([2, -3, 8, -2, 3, 5]).astype(np.int8)
    z = np.mod(x, y)  # expected output [ 0, -2,  5,  0,  2,  3]
    expect(node, inputs=[x, y], outputs=[z], name="test_mod_mixed_sign_int8")

**_mod_uint8**

::

    node = onnx.helper.make_node(
        "Mod",
        inputs=["x", "y"],
        outputs=["z"],
    )

    x = np.array([4, 7, 5]).astype(np.uint8)
    y = np.array([2, 3, 8]).astype(np.uint8)
    z = np.mod(x, y)  # expected output [0, 1, 5]
    expect(node, inputs=[x, y], outputs=[z], name="test_mod_uint8")

**_mod_uint16**

::

    node = onnx.helper.make_node(
        "Mod",
        inputs=["x", "y"],
        outputs=["z"],
    )

    x = np.array([4, 7, 5]).astype(np.uint16)
    y = np.array([2, 3, 8]).astype(np.uint16)
    z = np.mod(x, y)  # expected output [0, 1, 5]
    expect(node, inputs=[x, y], outputs=[z], name="test_mod_uint16")

**_mod_uint32**

::

    node = onnx.helper.make_node(
        "Mod",
        inputs=["x", "y"],
        outputs=["z"],
    )

    x = np.array([4, 7, 5]).astype(np.uint32)
    y = np.array([2, 3, 8]).astype(np.uint32)
    z = np.mod(x, y)  # expected output [0, 1, 5]
    expect(node, inputs=[x, y], outputs=[z], name="test_mod_uint32")

**_mod_uint64**

::

    node = onnx.helper.make_node(
        "Mod",
        inputs=["x", "y"],
        outputs=["z"],
    )

    x = np.array([4, 7, 5]).astype(np.uint64)
    y = np.array([2, 3, 8]).astype(np.uint64)
    z = np.mod(x, y)  # expected output [0, 1, 5]
    expect(node, inputs=[x, y], outputs=[z], name="test_mod_uint64")

**_mod_int64_fmod**

::

    node = onnx.helper.make_node("Mod", inputs=["x", "y"], outputs=["z"], fmod=1)

    x = np.array([-4, 7, 5, 4, -7, 8]).astype(np.int64)
    y = np.array([2, -3, 8, -2, 3, 5]).astype(np.int64)
    z = np.fmod(x, y)  # expected output [ 0,  1,  5,  0, -1,  3]
    expect(node, inputs=[x, y], outputs=[z], name="test_mod_int64_fmod")

**_mod_broadcast**

::

    node = onnx.helper.make_node(
        "Mod",
        inputs=["x", "y"],
        outputs=["z"],
    )

    x = np.arange(0, 30).reshape([3, 2, 5]).astype(np.int32)
    y = np.array([7]).astype(np.int32)
    z = np.mod(x, y)
    #   array([[[0, 1, 2, 3, 4],
    #     [5, 6, 0, 1, 2]],

    #    [[3, 4, 5, 6, 0],
    #     [1, 2, 3, 4, 5]],

    #    [[6, 0, 1, 2, 3],
    #     [4, 5, 6, 0, 1]]], dtype=int32)
    expect(node, inputs=[x, y], outputs=[z], name="test_mod_broadcast")

**Differences**

.. raw:: html

        <table class="diff" id="difflib_chg_to132__top"
               cellspacing="0" cellpadding="0" rules="groups" >
            <colgroup></colgroup> <colgroup></colgroup> <colgroup></colgroup>
            <colgroup></colgroup> <colgroup></colgroup> <colgroup></colgroup>

            <tbody>
                <tr><td class="diff_next"><a href="#difflib_chg_to132__0">f</a></td><td class="diff_header" id="from132_1">1</td><td nowrap="nowrap">Performs&nbsp;element-wise&nbsp;binary&nbsp;modulus&nbsp;(with&nbsp;Numpy-style&nbsp;broadcasting&nbsp;support).</td><td class="diff_next"><a href="#difflib_chg_to132__0">f</a></td><td class="diff_header" id="to132_1">1</td><td nowrap="nowrap">Performs&nbsp;element-wise&nbsp;binary&nbsp;modulus&nbsp;(with&nbsp;Numpy-style&nbsp;broadcasting&nbsp;support).</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_2">2</td><td nowrap="nowrap">&nbsp;&nbsp;The&nbsp;sign&nbsp;of&nbsp;the&nbsp;remainder&nbsp;is&nbsp;the&nbsp;same&nbsp;as&nbsp;that&nbsp;of&nbsp;the&nbsp;Divisor.</td><td class="diff_next"></td><td class="diff_header" id="to132_2">2</td><td nowrap="nowrap">&nbsp;&nbsp;The&nbsp;sign&nbsp;of&nbsp;the&nbsp;remainder&nbsp;is&nbsp;the&nbsp;same&nbsp;as&nbsp;that&nbsp;of&nbsp;the&nbsp;Divisor.</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_3">3</td><td nowrap="nowrap"></td><td class="diff_next"></td><td class="diff_header" id="to132_3">3</td><td nowrap="nowrap"></td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_4">4</td><td nowrap="nowrap">&nbsp;&nbsp;Mod&nbsp;operator&nbsp;can&nbsp;also&nbsp;behave&nbsp;like&nbsp;C&nbsp;fmod()&nbsp;or&nbsp;numpy.fmod.&nbsp;In&nbsp;this&nbsp;case,&nbsp;the&nbsp;sign&nbsp;of&nbsp;the&nbsp;remainder&nbsp;however,&nbsp;will&nbsp;be&nbsp;the&nbsp;same&nbsp;as&nbsp;the&nbsp;Dividend</td><td class="diff_next"></td><td class="diff_header" id="to132_4">4</td><td nowrap="nowrap">&nbsp;&nbsp;Mod&nbsp;operator&nbsp;can&nbsp;also&nbsp;behave&nbsp;like&nbsp;C&nbsp;fmod()&nbsp;or&nbsp;numpy.fmod.&nbsp;In&nbsp;this&nbsp;case,&nbsp;the&nbsp;sign&nbsp;of&nbsp;the&nbsp;remainder&nbsp;however,&nbsp;will&nbsp;be&nbsp;the&nbsp;same&nbsp;as&nbsp;the&nbsp;Dividend</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_5">5</td><td nowrap="nowrap">&nbsp;&nbsp;(in&nbsp;contrast&nbsp;to&nbsp;integer&nbsp;mod).&nbsp;To&nbsp;force&nbsp;a&nbsp;behavior&nbsp;like&nbsp;numpy.fmod()&nbsp;an&nbsp;'fmod'&nbsp;Attribute&nbsp;is&nbsp;provided.</td><td class="diff_next"></td><td class="diff_header" id="to132_5">5</td><td nowrap="nowrap">&nbsp;&nbsp;(in&nbsp;contrast&nbsp;to&nbsp;integer&nbsp;mod).&nbsp;To&nbsp;force&nbsp;a&nbsp;behavior&nbsp;like&nbsp;numpy.fmod()&nbsp;an&nbsp;'fmod'&nbsp;Attribute&nbsp;is&nbsp;provided.</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_6">6</td><td nowrap="nowrap">&nbsp;&nbsp;This&nbsp;attribute&nbsp;is&nbsp;set&nbsp;to&nbsp;0&nbsp;by&nbsp;default&nbsp;causing&nbsp;the&nbsp;behavior&nbsp;to&nbsp;be&nbsp;like&nbsp;integer&nbsp;mod.</td><td class="diff_next"></td><td class="diff_header" id="to132_6">6</td><td nowrap="nowrap">&nbsp;&nbsp;This&nbsp;attribute&nbsp;is&nbsp;set&nbsp;to&nbsp;0&nbsp;by&nbsp;default&nbsp;causing&nbsp;the&nbsp;behavior&nbsp;to&nbsp;be&nbsp;like&nbsp;integer&nbsp;mod.</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_7">7</td><td nowrap="nowrap">&nbsp;&nbsp;Setting&nbsp;this&nbsp;attribute&nbsp;to&nbsp;1&nbsp;causes&nbsp;the&nbsp;remainder&nbsp;to&nbsp;be&nbsp;calculated&nbsp;similar&nbsp;to&nbsp;that&nbsp;of&nbsp;numpy.fmod().</td><td class="diff_next"></td><td class="diff_header" id="to132_7">7</td><td nowrap="nowrap">&nbsp;&nbsp;Setting&nbsp;this&nbsp;attribute&nbsp;to&nbsp;1&nbsp;causes&nbsp;the&nbsp;remainder&nbsp;to&nbsp;be&nbsp;calculated&nbsp;similar&nbsp;to&nbsp;that&nbsp;of&nbsp;numpy.fmod().</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_8">8</td><td nowrap="nowrap"></td><td class="diff_next"></td><td class="diff_header" id="to132_8">8</td><td nowrap="nowrap"></td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_9">9</td><td nowrap="nowrap">&nbsp;&nbsp;If&nbsp;the&nbsp;input&nbsp;type&nbsp;is&nbsp;floating&nbsp;point,&nbsp;then&nbsp;fmod&nbsp;attribute&nbsp;must&nbsp;be&nbsp;set&nbsp;to&nbsp;1.</td><td class="diff_next"></td><td class="diff_header" id="to132_9">9</td><td nowrap="nowrap">&nbsp;&nbsp;If&nbsp;the&nbsp;input&nbsp;type&nbsp;is&nbsp;floating&nbsp;point,&nbsp;then&nbsp;fmod&nbsp;attribute&nbsp;must&nbsp;be&nbsp;set&nbsp;to&nbsp;1.</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_10">10</td><td nowrap="nowrap"></td><td class="diff_next"></td><td class="diff_header" id="to132_10">10</td><td nowrap="nowrap"></td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_11">11</td><td nowrap="nowrap">&nbsp;&nbsp;In&nbsp;case&nbsp;of&nbsp;dividend&nbsp;being&nbsp;zero,&nbsp;the&nbsp;results&nbsp;will&nbsp;be&nbsp;platform&nbsp;dependent.</td><td class="diff_next"></td><td class="diff_header" id="to132_11">11</td><td nowrap="nowrap">&nbsp;&nbsp;In&nbsp;case&nbsp;of&nbsp;dividend&nbsp;being&nbsp;zero,&nbsp;the&nbsp;results&nbsp;will&nbsp;be&nbsp;platform&nbsp;dependent.</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_12">12</td><td nowrap="nowrap"></td><td class="diff_next"></td><td class="diff_header" id="to132_12">12</td><td nowrap="nowrap"></td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_13">13</td><td nowrap="nowrap">This&nbsp;operator&nbsp;supports&nbsp;**multidirectional&nbsp;(i.e.,&nbsp;Numpy-style)&nbsp;broadcasting**;&nbsp;for&nbsp;more&nbsp;details&nbsp;please&nbsp;check&nbsp;Broadcasting&nbsp;in&nbsp;ONNX&nbsp;&lt;https://github.com/onnx/onnx/blob/master/docs/Broadcasting.md&gt;_.</td><td class="diff_next"></td><td class="diff_header" id="to132_13">13</td><td nowrap="nowrap">This&nbsp;operator&nbsp;supports&nbsp;**multidirectional&nbsp;(i.e.,&nbsp;Numpy-style)&nbsp;broadcasting**;&nbsp;for&nbsp;more&nbsp;details&nbsp;please&nbsp;check&nbsp;Broadcasting&nbsp;in&nbsp;ONNX&nbsp;&lt;https://github.com/onnx/onnx/blob/master/docs/Broadcasting.md&gt;_.</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_14">14</td><td nowrap="nowrap"></td><td class="diff_next"></td><td class="diff_header" id="to132_14">14</td><td nowrap="nowrap"></td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_15">15</td><td nowrap="nowrap">**Attributes**</td><td class="diff_next"></td><td class="diff_header" id="to132_15">15</td><td nowrap="nowrap">**Attributes**</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_16">16</td><td nowrap="nowrap"></td><td class="diff_next"></td><td class="diff_header" id="to132_16">16</td><td nowrap="nowrap"></td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_17">17</td><td nowrap="nowrap">*&nbsp;**fmod**:</td><td class="diff_next"></td><td class="diff_header" id="to132_17">17</td><td nowrap="nowrap">*&nbsp;**fmod**:</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_18">18</td><td nowrap="nowrap">&nbsp;&nbsp;Whether&nbsp;the&nbsp;operator&nbsp;should&nbsp;behave&nbsp;like&nbsp;fmod&nbsp;(default=0&nbsp;meaning&nbsp;it</td><td class="diff_next"></td><td class="diff_header" id="to132_18">18</td><td nowrap="nowrap">&nbsp;&nbsp;Whether&nbsp;the&nbsp;operator&nbsp;should&nbsp;behave&nbsp;like&nbsp;fmod&nbsp;(default=0&nbsp;meaning&nbsp;it</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_19">19</td><td nowrap="nowrap">&nbsp;&nbsp;will&nbsp;do&nbsp;integer&nbsp;mods);&nbsp;Set&nbsp;this&nbsp;to&nbsp;1&nbsp;to&nbsp;force&nbsp;fmod&nbsp;treatment</td><td class="diff_next"></td><td class="diff_header" id="to132_19">19</td><td nowrap="nowrap">&nbsp;&nbsp;will&nbsp;do&nbsp;integer&nbsp;mods);&nbsp;Set&nbsp;this&nbsp;to&nbsp;1&nbsp;to&nbsp;force&nbsp;fmod&nbsp;treatment</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_20">20</td><td nowrap="nowrap"></td><td class="diff_next"></td><td class="diff_header" id="to132_20">20</td><td nowrap="nowrap"></td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_21">21</td><td nowrap="nowrap">**Inputs**</td><td class="diff_next"></td><td class="diff_header" id="to132_21">21</td><td nowrap="nowrap">**Inputs**</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_22">22</td><td nowrap="nowrap"></td><td class="diff_next"></td><td class="diff_header" id="to132_22">22</td><td nowrap="nowrap"></td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_23">23</td><td nowrap="nowrap">*&nbsp;**A**&nbsp;(heterogeneous)&nbsp;-&nbsp;**T**:</td><td class="diff_next"></td><td class="diff_header" id="to132_23">23</td><td nowrap="nowrap">*&nbsp;**A**&nbsp;(heterogeneous)&nbsp;-&nbsp;**T**:</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_24">24</td><td nowrap="nowrap">&nbsp;&nbsp;Dividend&nbsp;tensor</td><td class="diff_next"></td><td class="diff_header" id="to132_24">24</td><td nowrap="nowrap">&nbsp;&nbsp;Dividend&nbsp;tensor</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_25">25</td><td nowrap="nowrap">*&nbsp;**B**&nbsp;(heterogeneous)&nbsp;-&nbsp;**T**:</td><td class="diff_next"></td><td class="diff_header" id="to132_25">25</td><td nowrap="nowrap">*&nbsp;**B**&nbsp;(heterogeneous)&nbsp;-&nbsp;**T**:</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_26">26</td><td nowrap="nowrap">&nbsp;&nbsp;Divisor&nbsp;tensor</td><td class="diff_next"></td><td class="diff_header" id="to132_26">26</td><td nowrap="nowrap">&nbsp;&nbsp;Divisor&nbsp;tensor</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_27">27</td><td nowrap="nowrap"></td><td class="diff_next"></td><td class="diff_header" id="to132_27">27</td><td nowrap="nowrap"></td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_28">28</td><td nowrap="nowrap">**Outputs**</td><td class="diff_next"></td><td class="diff_header" id="to132_28">28</td><td nowrap="nowrap">**Outputs**</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_29">29</td><td nowrap="nowrap"></td><td class="diff_next"></td><td class="diff_header" id="to132_29">29</td><td nowrap="nowrap"></td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_30">30</td><td nowrap="nowrap">*&nbsp;**C**&nbsp;(heterogeneous)&nbsp;-&nbsp;**T**:</td><td class="diff_next"></td><td class="diff_header" id="to132_30">30</td><td nowrap="nowrap">*&nbsp;**C**&nbsp;(heterogeneous)&nbsp;-&nbsp;**T**:</td></tr>
                <tr><td class="diff_next" id="difflib_chg_to132__0"></td><td class="diff_header" id="from132_31">31</td><td nowrap="nowrap">&nbsp;&nbsp;Remainder&nbsp;tensor</td><td class="diff_next"></td><td class="diff_header" id="to132_31">31</td><td nowrap="nowrap">&nbsp;&nbsp;Remainder&nbsp;tensor</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_32">32</td><td nowrap="nowrap"></td><td class="diff_next"></td><td class="diff_header" id="to132_32">32</td><td nowrap="nowrap"></td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_33">33</td><td nowrap="nowrap">**Type&nbsp;Constraints**</td><td class="diff_next"></td><td class="diff_header" id="to132_33">33</td><td nowrap="nowrap">**Type&nbsp;Constraints**</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_34">34</td><td nowrap="nowrap"></td><td class="diff_next"></td><td class="diff_header" id="to132_34">34</td><td nowrap="nowrap"></td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_35">35</td><td nowrap="nowrap">*&nbsp;**T**&nbsp;in&nbsp;(</td><td class="diff_next"></td><td class="diff_header" id="to132_35">35</td><td nowrap="nowrap">*&nbsp;**T**&nbsp;in&nbsp;(</td></tr>
                <tr><td class="diff_next"><a href="#difflib_chg_to132__top">t</a></td><td class="diff_header"></td><td nowrap="nowrap"></td><td class="diff_next"><a href="#difflib_chg_to132__top">t</a></td><td class="diff_header" id="to132_36">36</td><td nowrap="nowrap"><span class="diff_add">&nbsp;&nbsp;tensor(bfloat16),</span></td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_36">36</td><td nowrap="nowrap">&nbsp;&nbsp;tensor(double),</td><td class="diff_next"></td><td class="diff_header" id="to132_37">37</td><td nowrap="nowrap">&nbsp;&nbsp;tensor(double),</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_37">37</td><td nowrap="nowrap">&nbsp;&nbsp;tensor(float),</td><td class="diff_next"></td><td class="diff_header" id="to132_38">38</td><td nowrap="nowrap">&nbsp;&nbsp;tensor(float),</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_38">38</td><td nowrap="nowrap">&nbsp;&nbsp;tensor(float16),</td><td class="diff_next"></td><td class="diff_header" id="to132_39">39</td><td nowrap="nowrap">&nbsp;&nbsp;tensor(float16),</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_39">39</td><td nowrap="nowrap">&nbsp;&nbsp;tensor(int16),</td><td class="diff_next"></td><td class="diff_header" id="to132_40">40</td><td nowrap="nowrap">&nbsp;&nbsp;tensor(int16),</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_40">40</td><td nowrap="nowrap">&nbsp;&nbsp;tensor(int32),</td><td class="diff_next"></td><td class="diff_header" id="to132_41">41</td><td nowrap="nowrap">&nbsp;&nbsp;tensor(int32),</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_41">41</td><td nowrap="nowrap">&nbsp;&nbsp;tensor(int64),</td><td class="diff_next"></td><td class="diff_header" id="to132_42">42</td><td nowrap="nowrap">&nbsp;&nbsp;tensor(int64),</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_42">42</td><td nowrap="nowrap">&nbsp;&nbsp;tensor(int8),</td><td class="diff_next"></td><td class="diff_header" id="to132_43">43</td><td nowrap="nowrap">&nbsp;&nbsp;tensor(int8),</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_43">43</td><td nowrap="nowrap">&nbsp;&nbsp;tensor(uint16),</td><td class="diff_next"></td><td class="diff_header" id="to132_44">44</td><td nowrap="nowrap">&nbsp;&nbsp;tensor(uint16),</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_44">44</td><td nowrap="nowrap">&nbsp;&nbsp;tensor(uint32),</td><td class="diff_next"></td><td class="diff_header" id="to132_45">45</td><td nowrap="nowrap">&nbsp;&nbsp;tensor(uint32),</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_45">45</td><td nowrap="nowrap">&nbsp;&nbsp;tensor(uint64),</td><td class="diff_next"></td><td class="diff_header" id="to132_46">46</td><td nowrap="nowrap">&nbsp;&nbsp;tensor(uint64),</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_46">46</td><td nowrap="nowrap">&nbsp;&nbsp;tensor(uint8)</td><td class="diff_next"></td><td class="diff_header" id="to132_47">47</td><td nowrap="nowrap">&nbsp;&nbsp;tensor(uint8)</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_47">47</td><td nowrap="nowrap">&nbsp;&nbsp;):</td><td class="diff_next"></td><td class="diff_header" id="to132_48">48</td><td nowrap="nowrap">&nbsp;&nbsp;):</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from132_48">48</td><td nowrap="nowrap">&nbsp;&nbsp;Constrain&nbsp;input&nbsp;and&nbsp;output&nbsp;types&nbsp;to&nbsp;high-precision&nbsp;numeric&nbsp;tensors.</td><td class="diff_next"></td><td class="diff_header" id="to132_49">49</td><td nowrap="nowrap">&nbsp;&nbsp;Constrain&nbsp;input&nbsp;and&nbsp;output&nbsp;types&nbsp;to&nbsp;high-precision&nbsp;numeric&nbsp;tensors.</td></tr>
            </tbody>
        </table>

.. _l-onnx-op-mod-10:

Mod - 10
========

**Version**

* **name**: `Mod (GitHub) <https://github.com/onnx/onnx/blob/main/docs/Operators.md#Mod>`_
* **domain**: **main**
* **since_version**: **10**
* **function**: False
* **support_level**: SupportType.COMMON
* **shape inference**: True

This version of the operator has been available
**since version 10**.

**Summary**

Performs element-wise binary modulus (with Numpy-style broadcasting support).
  The sign of the remainder is the same as that of the Divisor.

  Mod operator can also behave like C fmod() or numpy.fmod. In this case, the sign of the remainder however, will be the same as the Dividend
  (in contrast to integer mod). To force a behavior like numpy.fmod() an 'fmod' Attribute is provided.
  This attribute is set to 0 by default causing the behavior to be like integer mod.
  Setting this attribute to 1 causes the remainder to be calculated similar to that of numpy.fmod().

  If the input type is floating point, then `fmod` attribute must be set to 1.

  In case of dividend being zero, the results will be platform dependent.

This operator supports **multidirectional (i.e., Numpy-style) broadcasting**; for more details please check `Broadcasting in ONNX <https://github.com/onnx/onnx/blob/master/docs/Broadcasting.md>`_.

**Attributes**

* **fmod**:
  Whether the operator should behave like fmod (default=0 meaning it
  will do integer mods); Set this to 1 to force fmod treatment

**Inputs**

* **A** (heterogeneous) - **T**:
  Dividend tensor
* **B** (heterogeneous) - **T**:
  Divisor tensor

**Outputs**

* **C** (heterogeneous) - **T**:
  Remainder tensor

**Type Constraints**

* **T** in (
  tensor(double),
  tensor(float),
  tensor(float16),
  tensor(int16),
  tensor(int32),
  tensor(int64),
  tensor(int8),
  tensor(uint16),
  tensor(uint32),
  tensor(uint64),
  tensor(uint8)
  ):
  Constrain input and output types to high-precision numeric tensors.
