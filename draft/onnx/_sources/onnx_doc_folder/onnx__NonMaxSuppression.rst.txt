
.. _l-onnx-doc-NonMaxSuppression:

=================
NonMaxSuppression
=================

.. contents::
    :local:


.. _l-onnx-op-nonmaxsuppression-11:
NonMaxSuppression - 11
======================
**Version**
* **name**: `NonMaxSuppression (GitHub) <https://github.com/onnx/onnx/blob/main/docs/Operators.md#NonMaxSuppression>`_
* **domain**: **main**
* **since_version**: **11**
* **function**: False
* **support_level**: SupportType.COMMON
* **shape inference**: True

This version of the operator has been available
**since version 11**.

**Summary**

Filter out boxes that have high intersection-over-union (IOU) overlap with previously selected boxes.
Bounding boxes with score less than score_threshold are removed. Bounding box format is indicated by attribute center_point_box.
Note that this algorithm is agnostic to where the origin is in the coordinate system and more generally is invariant to
orthogonal transformations and translations of the coordinate system; thus translating or reflections of the coordinate system
result in the same boxes being selected by the algorithm.
The selected_indices output is a set of integers indexing into the input collection of bounding boxes representing the selected boxes.
The bounding box coordinates corresponding to the selected indices can then be obtained using the Gather or GatherND operation.

**Attributes**
* **center_point_box**:
  Integer indicate the format of the box data. The default is 0. 0 -
  the box data is supplied as [y1, x1, y2, x2] where (y1, x1) and (y2,
  x2) are the coordinates of any diagonal pair of box corners and the
  coordinates can be provided as normalized (i.e., lying in the
  interval [0, 1]) or absolute. Mostly used for TF models. 1 - the box
  data is supplied as [x_center, y_center, width, height]. Mostly used
  for Pytorch models.

**Inputs**
Between 2 and 5 inputs.

* **boxes** (heterogeneous) - **tensor(float)**:
  An input tensor with shape [num_batches, spatial_dimension, 4]. The
  single box data format is indicated by center_point_box.
* **scores** (heterogeneous) - **tensor(float)**:
  An input tensor with shape [num_batches, num_classes,
  spatial_dimension]
* **max_output_boxes_per_class** (optional, heterogeneous) - **tensor(int64)**:
  Integer representing the maximum number of boxes to be selected per
  batch per class. It is a scalar. Default to 0, which means no
  output.
* **iou_threshold** (optional, heterogeneous) - **tensor(float)**:
  Float representing the threshold for deciding whether boxes overlap
  too much with respect to IOU. It is scalar. Value range [0, 1].
  Default to 0.
* **score_threshold** (optional, heterogeneous) - **tensor(float)**:
  Float representing the threshold for deciding when to remove boxes
  based on score. It is a scalar.

**Outputs**

* **selected_indices** (heterogeneous) - **tensor(int64)**:
  selected indices from the boxes tensor. [num_selected_indices, 3],
  the selected index format is [batch_index, class_index, box_index].

**Examples**

**_nonmaxsuppression_suppress_by_IOU**
::
    node = onnx.helper.make_node(
        "NonMaxSuppression",
        inputs=[
            "boxes",
            "scores",
            "max_output_boxes_per_class",
            "iou_threshold",
            "score_threshold",
        ],
        outputs=["selected_indices"],
    )
    boxes = np.array(
        [
            [
                [0.0, 0.0, 1.0, 1.0],
                [0.0, 0.1, 1.0, 1.1],
                [0.0, -0.1, 1.0, 0.9],
                [0.0, 10.0, 1.0, 11.0],
                [0.0, 10.1, 1.0, 11.1],
                [0.0, 100.0, 1.0, 101.0],
            ]
        ]
    ).astype(np.float32)
    scores = np.array([[[0.9, 0.75, 0.6, 0.95, 0.5, 0.3]]]).astype(np.float32)
    max_output_boxes_per_class = np.array([3]).astype(np.int64)
    iou_threshold = np.array([0.5]).astype(np.float32)
    score_threshold = np.array([0.0]).astype(np.float32)
    selected_indices = np.array([[0, 0, 3], [0, 0, 0], [0, 0, 5]]).astype(np.int64)

    expect(
        node,
        inputs=[
            boxes,
            scores,
            max_output_boxes_per_class,
            iou_threshold,
            score_threshold,
        ],
        outputs=[selected_indices],
        name="test_nonmaxsuppression_suppress_by_IOU",
    )

**_nonmaxsuppression_suppress_by_IOU_and_scores**
::
    node = onnx.helper.make_node(
        "NonMaxSuppression",
        inputs=[
            "boxes",
            "scores",
            "max_output_boxes_per_class",
            "iou_threshold",
            "score_threshold",
        ],
        outputs=["selected_indices"],
    )
    boxes = np.array(
        [
            [
                [0.0, 0.0, 1.0, 1.0],
                [0.0, 0.1, 1.0, 1.1],
                [0.0, -0.1, 1.0, 0.9],
                [0.0, 10.0, 1.0, 11.0],
                [0.0, 10.1, 1.0, 11.1],
                [0.0, 100.0, 1.0, 101.0],
            ]
        ]
    ).astype(np.float32)
    scores = np.array([[[0.9, 0.75, 0.6, 0.95, 0.5, 0.3]]]).astype(np.float32)
    max_output_boxes_per_class = np.array([3]).astype(np.int64)
    iou_threshold = np.array([0.5]).astype(np.float32)
    score_threshold = np.array([0.4]).astype(np.float32)
    selected_indices = np.array([[0, 0, 3], [0, 0, 0]]).astype(np.int64)

    expect(
        node,
        inputs=[
            boxes,
            scores,
            max_output_boxes_per_class,
            iou_threshold,
            score_threshold,
        ],
        outputs=[selected_indices],
        name="test_nonmaxsuppression_suppress_by_IOU_and_scores",
    )

**_nonmaxsuppression_flipped_coordinates**
::
    node = onnx.helper.make_node(
        "NonMaxSuppression",
        inputs=[
            "boxes",
            "scores",
            "max_output_boxes_per_class",
            "iou_threshold",
            "score_threshold",
        ],
        outputs=["selected_indices"],
    )
    boxes = np.array(
        [
            [
                [1.0, 1.0, 0.0, 0.0],
                [0.0, 0.1, 1.0, 1.1],
                [0.0, 0.9, 1.0, -0.1],
                [0.0, 10.0, 1.0, 11.0],
                [1.0, 10.1, 0.0, 11.1],
                [1.0, 101.0, 0.0, 100.0],
            ]
        ]
    ).astype(np.float32)
    scores = np.array([[[0.9, 0.75, 0.6, 0.95, 0.5, 0.3]]]).astype(np.float32)
    max_output_boxes_per_class = np.array([3]).astype(np.int64)
    iou_threshold = np.array([0.5]).astype(np.float32)
    score_threshold = np.array([0.0]).astype(np.float32)
    selected_indices = np.array([[0, 0, 3], [0, 0, 0], [0, 0, 5]]).astype(np.int64)

    expect(
        node,
        inputs=[
            boxes,
            scores,
            max_output_boxes_per_class,
            iou_threshold,
            score_threshold,
        ],
        outputs=[selected_indices],
        name="test_nonmaxsuppression_flipped_coordinates",
    )

**_nonmaxsuppression_limit_output_size**
::
    node = onnx.helper.make_node(
        "NonMaxSuppression",
        inputs=[
            "boxes",
            "scores",
            "max_output_boxes_per_class",
            "iou_threshold",
            "score_threshold",
        ],
        outputs=["selected_indices"],
    )
    boxes = np.array(
        [
            [
                [0.0, 0.0, 1.0, 1.0],
                [0.0, 0.1, 1.0, 1.1],
                [0.0, -0.1, 1.0, 0.9],
                [0.0, 10.0, 1.0, 11.0],
                [0.0, 10.1, 1.0, 11.1],
                [0.0, 100.0, 1.0, 101.0],
            ]
        ]
    ).astype(np.float32)
    scores = np.array([[[0.9, 0.75, 0.6, 0.95, 0.5, 0.3]]]).astype(np.float32)
    max_output_boxes_per_class = np.array([2]).astype(np.int64)
    iou_threshold = np.array([0.5]).astype(np.float32)
    score_threshold = np.array([0.0]).astype(np.float32)
    selected_indices = np.array([[0, 0, 3], [0, 0, 0]]).astype(np.int64)

    expect(
        node,
        inputs=[
            boxes,
            scores,
            max_output_boxes_per_class,
            iou_threshold,
            score_threshold,
        ],
        outputs=[selected_indices],
        name="test_nonmaxsuppression_limit_output_size",
    )

**_nonmaxsuppression_single_box**
::
    node = onnx.helper.make_node(
        "NonMaxSuppression",
        inputs=[
            "boxes",
            "scores",
            "max_output_boxes_per_class",
            "iou_threshold",
            "score_threshold",
        ],
        outputs=["selected_indices"],
    )
    boxes = np.array([[[0.0, 0.0, 1.0, 1.0]]]).astype(np.float32)
    scores = np.array([[[0.9]]]).astype(np.float32)
    max_output_boxes_per_class = np.array([3]).astype(np.int64)
    iou_threshold = np.array([0.5]).astype(np.float32)
    score_threshold = np.array([0.0]).astype(np.float32)
    selected_indices = np.array([[0, 0, 0]]).astype(np.int64)

    expect(
        node,
        inputs=[
            boxes,
            scores,
            max_output_boxes_per_class,
            iou_threshold,
            score_threshold,
        ],
        outputs=[selected_indices],
        name="test_nonmaxsuppression_single_box",
    )

**_nonmaxsuppression_identical_boxes**
::
    node = onnx.helper.make_node(
        "NonMaxSuppression",
        inputs=[
            "boxes",
            "scores",
            "max_output_boxes_per_class",
            "iou_threshold",
            "score_threshold",
        ],
        outputs=["selected_indices"],
    )
    boxes = np.array(
        [
            [
                [0.0, 0.0, 1.0, 1.0],
                [0.0, 0.0, 1.0, 1.0],
                [0.0, 0.0, 1.0, 1.0],
                [0.0, 0.0, 1.0, 1.0],
                [0.0, 0.0, 1.0, 1.0],
                [0.0, 0.0, 1.0, 1.0],
                [0.0, 0.0, 1.0, 1.0],
                [0.0, 0.0, 1.0, 1.0],
                [0.0, 0.0, 1.0, 1.0],
                [0.0, 0.0, 1.0, 1.0],
            ]
        ]
    ).astype(np.float32)
    scores = np.array(
        [[[0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9]]]
    ).astype(np.float32)
    max_output_boxes_per_class = np.array([3]).astype(np.int64)
    iou_threshold = np.array([0.5]).astype(np.float32)
    score_threshold = np.array([0.0]).astype(np.float32)
    selected_indices = np.array([[0, 0, 0]]).astype(np.int64)

    expect(
        node,
        inputs=[
            boxes,
            scores,
            max_output_boxes_per_class,
            iou_threshold,
            score_threshold,
        ],
        outputs=[selected_indices],
        name="test_nonmaxsuppression_identical_boxes",
    )

**_nonmaxsuppression_center_point_box_format**
::
    node = onnx.helper.make_node(
        "NonMaxSuppression",
        inputs=[
            "boxes",
            "scores",
            "max_output_boxes_per_class",
            "iou_threshold",
            "score_threshold",
        ],
        outputs=["selected_indices"],
        center_point_box=1,
    )
    boxes = np.array(
        [
            [
                [0.5, 0.5, 1.0, 1.0],
                [0.5, 0.6, 1.0, 1.0],
                [0.5, 0.4, 1.0, 1.0],
                [0.5, 10.5, 1.0, 1.0],
                [0.5, 10.6, 1.0, 1.0],
                [0.5, 100.5, 1.0, 1.0],
            ]
        ]
    ).astype(np.float32)
    scores = np.array([[[0.9, 0.75, 0.6, 0.95, 0.5, 0.3]]]).astype(np.float32)
    max_output_boxes_per_class = np.array([3]).astype(np.int64)
    iou_threshold = np.array([0.5]).astype(np.float32)
    score_threshold = np.array([0.0]).astype(np.float32)
    selected_indices = np.array([[0, 0, 3], [0, 0, 0], [0, 0, 5]]).astype(np.int64)

    expect(
        node,
        inputs=[
            boxes,
            scores,
            max_output_boxes_per_class,
            iou_threshold,
            score_threshold,
        ],
        outputs=[selected_indices],
        name="test_nonmaxsuppression_center_point_box_format",
    )

**_nonmaxsuppression_two_classes**
::
    node = onnx.helper.make_node(
        "NonMaxSuppression",
        inputs=[
            "boxes",
            "scores",
            "max_output_boxes_per_class",
            "iou_threshold",
            "score_threshold",
        ],
        outputs=["selected_indices"],
    )
    boxes = np.array(
        [
            [
                [0.0, 0.0, 1.0, 1.0],
                [0.0, 0.1, 1.0, 1.1],
                [0.0, -0.1, 1.0, 0.9],
                [0.0, 10.0, 1.0, 11.0],
                [0.0, 10.1, 1.0, 11.1],
                [0.0, 100.0, 1.0, 101.0],
            ]
        ]
    ).astype(np.float32)
    scores = np.array(
        [[[0.9, 0.75, 0.6, 0.95, 0.5, 0.3], [0.9, 0.75, 0.6, 0.95, 0.5, 0.3]]]
    ).astype(np.float32)
    max_output_boxes_per_class = np.array([2]).astype(np.int64)
    iou_threshold = np.array([0.5]).astype(np.float32)
    score_threshold = np.array([0.0]).astype(np.float32)
    selected_indices = np.array(
        [[0, 0, 3], [0, 0, 0], [0, 1, 3], [0, 1, 0]]
    ).astype(np.int64)

    expect(
        node,
        inputs=[
            boxes,
            scores,
            max_output_boxes_per_class,
            iou_threshold,
            score_threshold,
        ],
        outputs=[selected_indices],
        name="test_nonmaxsuppression_two_classes",
    )

**_nonmaxsuppression_two_batches**
::
    node = onnx.helper.make_node(
        "NonMaxSuppression",
        inputs=[
            "boxes",
            "scores",
            "max_output_boxes_per_class",
            "iou_threshold",
            "score_threshold",
        ],
        outputs=["selected_indices"],
    )
    boxes = np.array(
        [
            [
                [0.0, 0.0, 1.0, 1.0],
                [0.0, 0.1, 1.0, 1.1],
                [0.0, -0.1, 1.0, 0.9],
                [0.0, 10.0, 1.0, 11.0],
                [0.0, 10.1, 1.0, 11.1],
                [0.0, 100.0, 1.0, 101.0],
            ],
            [
                [0.0, 0.0, 1.0, 1.0],
                [0.0, 0.1, 1.0, 1.1],
                [0.0, -0.1, 1.0, 0.9],
                [0.0, 10.0, 1.0, 11.0],
                [0.0, 10.1, 1.0, 11.1],
                [0.0, 100.0, 1.0, 101.0],
            ],
        ]
    ).astype(np.float32)
    scores = np.array(
        [[[0.9, 0.75, 0.6, 0.95, 0.5, 0.3]], [[0.9, 0.75, 0.6, 0.95, 0.5, 0.3]]]
    ).astype(np.float32)
    max_output_boxes_per_class = np.array([2]).astype(np.int64)
    iou_threshold = np.array([0.5]).astype(np.float32)
    score_threshold = np.array([0.0]).astype(np.float32)
    selected_indices = np.array(
        [[0, 0, 3], [0, 0, 0], [1, 0, 3], [1, 0, 0]]
    ).astype(np.int64)

    expect(
        node,
        inputs=[
            boxes,
            scores,
            max_output_boxes_per_class,
            iou_threshold,
            score_threshold,
        ],
        outputs=[selected_indices],
        name="test_nonmaxsuppression_two_batches",
    )

**Differences**

.. raw:: html

        <table class="diff" id="difflib_chg_to140__top"
               cellspacing="0" cellpadding="0" rules="groups" >
            <colgroup></colgroup> <colgroup></colgroup> <colgroup></colgroup>
            <colgroup></colgroup> <colgroup></colgroup> <colgroup></colgroup>

            <tbody>
                <tr><td class="diff_next"><a href="#difflib_chg_to140__top">t</a></td><td class="diff_header" id="from140_1">1</td><td nowrap="nowrap">Filter&nbsp;out&nbsp;boxes&nbsp;that&nbsp;have&nbsp;high&nbsp;intersection-over-union&nbsp;(IOU)&nbsp;overlap&nbsp;with&nbsp;previously&nbsp;selected&nbsp;boxes.</td><td class="diff_next"><a href="#difflib_chg_to140__top">t</a></td><td class="diff_header" id="to140_1">1</td><td nowrap="nowrap">Filter&nbsp;out&nbsp;boxes&nbsp;that&nbsp;have&nbsp;high&nbsp;intersection-over-union&nbsp;(IOU)&nbsp;overlap&nbsp;with&nbsp;previously&nbsp;selected&nbsp;boxes.</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_2">2</td><td nowrap="nowrap">Bounding&nbsp;boxes&nbsp;with&nbsp;score&nbsp;less&nbsp;than&nbsp;score_threshold&nbsp;are&nbsp;removed.&nbsp;Bounding&nbsp;box&nbsp;format&nbsp;is&nbsp;indicated&nbsp;by&nbsp;attribute&nbsp;center_point_box.</td><td class="diff_next"></td><td class="diff_header" id="to140_2">2</td><td nowrap="nowrap">Bounding&nbsp;boxes&nbsp;with&nbsp;score&nbsp;less&nbsp;than&nbsp;score_threshold&nbsp;are&nbsp;removed.&nbsp;Bounding&nbsp;box&nbsp;format&nbsp;is&nbsp;indicated&nbsp;by&nbsp;attribute&nbsp;center_point_box.</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_3">3</td><td nowrap="nowrap">Note&nbsp;that&nbsp;this&nbsp;algorithm&nbsp;is&nbsp;agnostic&nbsp;to&nbsp;where&nbsp;the&nbsp;origin&nbsp;is&nbsp;in&nbsp;the&nbsp;coordinate&nbsp;system&nbsp;and&nbsp;more&nbsp;generally&nbsp;is&nbsp;invariant&nbsp;to</td><td class="diff_next"></td><td class="diff_header" id="to140_3">3</td><td nowrap="nowrap">Note&nbsp;that&nbsp;this&nbsp;algorithm&nbsp;is&nbsp;agnostic&nbsp;to&nbsp;where&nbsp;the&nbsp;origin&nbsp;is&nbsp;in&nbsp;the&nbsp;coordinate&nbsp;system&nbsp;and&nbsp;more&nbsp;generally&nbsp;is&nbsp;invariant&nbsp;to</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_4">4</td><td nowrap="nowrap">orthogonal&nbsp;transformations&nbsp;and&nbsp;translations&nbsp;of&nbsp;the&nbsp;coordinate&nbsp;system;&nbsp;thus&nbsp;translating&nbsp;or&nbsp;reflections&nbsp;of&nbsp;the&nbsp;coordinate&nbsp;system</td><td class="diff_next"></td><td class="diff_header" id="to140_4">4</td><td nowrap="nowrap">orthogonal&nbsp;transformations&nbsp;and&nbsp;translations&nbsp;of&nbsp;the&nbsp;coordinate&nbsp;system;&nbsp;thus&nbsp;translating&nbsp;or&nbsp;reflections&nbsp;of&nbsp;the&nbsp;coordinate&nbsp;system</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_5">5</td><td nowrap="nowrap">result&nbsp;in&nbsp;the&nbsp;same&nbsp;boxes&nbsp;being&nbsp;selected&nbsp;by&nbsp;the&nbsp;algorithm.</td><td class="diff_next"></td><td class="diff_header" id="to140_5">5</td><td nowrap="nowrap">result&nbsp;in&nbsp;the&nbsp;same&nbsp;boxes&nbsp;being&nbsp;selected&nbsp;by&nbsp;the&nbsp;algorithm.</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_6">6</td><td nowrap="nowrap">The&nbsp;selected_indices&nbsp;output&nbsp;is&nbsp;a&nbsp;set&nbsp;of&nbsp;integers&nbsp;indexing&nbsp;into&nbsp;the&nbsp;input&nbsp;collection&nbsp;of&nbsp;bounding&nbsp;boxes&nbsp;representing&nbsp;the&nbsp;selected&nbsp;boxes.</td><td class="diff_next"></td><td class="diff_header" id="to140_6">6</td><td nowrap="nowrap">The&nbsp;selected_indices&nbsp;output&nbsp;is&nbsp;a&nbsp;set&nbsp;of&nbsp;integers&nbsp;indexing&nbsp;into&nbsp;the&nbsp;input&nbsp;collection&nbsp;of&nbsp;bounding&nbsp;boxes&nbsp;representing&nbsp;the&nbsp;selected&nbsp;boxes.</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_7">7</td><td nowrap="nowrap">The&nbsp;bounding&nbsp;box&nbsp;coordinates&nbsp;corresponding&nbsp;to&nbsp;the&nbsp;selected&nbsp;indices&nbsp;can&nbsp;then&nbsp;be&nbsp;obtained&nbsp;using&nbsp;the&nbsp;Gather&nbsp;or&nbsp;GatherND&nbsp;operation.</td><td class="diff_next"></td><td class="diff_header" id="to140_7">7</td><td nowrap="nowrap">The&nbsp;bounding&nbsp;box&nbsp;coordinates&nbsp;corresponding&nbsp;to&nbsp;the&nbsp;selected&nbsp;indices&nbsp;can&nbsp;then&nbsp;be&nbsp;obtained&nbsp;using&nbsp;the&nbsp;Gather&nbsp;or&nbsp;GatherND&nbsp;operation.</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_8">8</td><td nowrap="nowrap"></td><td class="diff_next"></td><td class="diff_header" id="to140_8">8</td><td nowrap="nowrap"></td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_9">9</td><td nowrap="nowrap">**Attributes**</td><td class="diff_next"></td><td class="diff_header" id="to140_9">9</td><td nowrap="nowrap">**Attributes**</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_10">10</td><td nowrap="nowrap">*&nbsp;**center_point_box**:</td><td class="diff_next"></td><td class="diff_header" id="to140_10">10</td><td nowrap="nowrap">*&nbsp;**center_point_box**:</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_11">11</td><td nowrap="nowrap">&nbsp;&nbsp;Integer&nbsp;indicate&nbsp;the&nbsp;format&nbsp;of&nbsp;the&nbsp;box&nbsp;data.&nbsp;The&nbsp;default&nbsp;is&nbsp;0.&nbsp;0&nbsp;-</td><td class="diff_next"></td><td class="diff_header" id="to140_11">11</td><td nowrap="nowrap">&nbsp;&nbsp;Integer&nbsp;indicate&nbsp;the&nbsp;format&nbsp;of&nbsp;the&nbsp;box&nbsp;data.&nbsp;The&nbsp;default&nbsp;is&nbsp;0.&nbsp;0&nbsp;-</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_12">12</td><td nowrap="nowrap">&nbsp;&nbsp;the&nbsp;box&nbsp;data&nbsp;is&nbsp;supplied&nbsp;as&nbsp;[y1,&nbsp;x1,&nbsp;y2,&nbsp;x2]&nbsp;where&nbsp;(y1,&nbsp;x1)&nbsp;and&nbsp;(y2,</td><td class="diff_next"></td><td class="diff_header" id="to140_12">12</td><td nowrap="nowrap">&nbsp;&nbsp;the&nbsp;box&nbsp;data&nbsp;is&nbsp;supplied&nbsp;as&nbsp;[y1,&nbsp;x1,&nbsp;y2,&nbsp;x2]&nbsp;where&nbsp;(y1,&nbsp;x1)&nbsp;and&nbsp;(y2,</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_13">13</td><td nowrap="nowrap">&nbsp;&nbsp;x2)&nbsp;are&nbsp;the&nbsp;coordinates&nbsp;of&nbsp;any&nbsp;diagonal&nbsp;pair&nbsp;of&nbsp;box&nbsp;corners&nbsp;and&nbsp;the</td><td class="diff_next"></td><td class="diff_header" id="to140_13">13</td><td nowrap="nowrap">&nbsp;&nbsp;x2)&nbsp;are&nbsp;the&nbsp;coordinates&nbsp;of&nbsp;any&nbsp;diagonal&nbsp;pair&nbsp;of&nbsp;box&nbsp;corners&nbsp;and&nbsp;the</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_14">14</td><td nowrap="nowrap">&nbsp;&nbsp;coordinates&nbsp;can&nbsp;be&nbsp;provided&nbsp;as&nbsp;normalized&nbsp;(i.e.,&nbsp;lying&nbsp;in&nbsp;the</td><td class="diff_next"></td><td class="diff_header" id="to140_14">14</td><td nowrap="nowrap">&nbsp;&nbsp;coordinates&nbsp;can&nbsp;be&nbsp;provided&nbsp;as&nbsp;normalized&nbsp;(i.e.,&nbsp;lying&nbsp;in&nbsp;the</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_15">15</td><td nowrap="nowrap">&nbsp;&nbsp;interval&nbsp;[0,&nbsp;1])&nbsp;or&nbsp;absolute.&nbsp;Mostly&nbsp;used&nbsp;for&nbsp;TF&nbsp;models.&nbsp;1&nbsp;-&nbsp;the&nbsp;box</td><td class="diff_next"></td><td class="diff_header" id="to140_15">15</td><td nowrap="nowrap">&nbsp;&nbsp;interval&nbsp;[0,&nbsp;1])&nbsp;or&nbsp;absolute.&nbsp;Mostly&nbsp;used&nbsp;for&nbsp;TF&nbsp;models.&nbsp;1&nbsp;-&nbsp;the&nbsp;box</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_16">16</td><td nowrap="nowrap">&nbsp;&nbsp;data&nbsp;is&nbsp;supplied&nbsp;as&nbsp;[x_center,&nbsp;y_center,&nbsp;width,&nbsp;height].&nbsp;Mostly&nbsp;used</td><td class="diff_next"></td><td class="diff_header" id="to140_16">16</td><td nowrap="nowrap">&nbsp;&nbsp;data&nbsp;is&nbsp;supplied&nbsp;as&nbsp;[x_center,&nbsp;y_center,&nbsp;width,&nbsp;height].&nbsp;Mostly&nbsp;used</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_17">17</td><td nowrap="nowrap">&nbsp;&nbsp;for&nbsp;Pytorch&nbsp;models.</td><td class="diff_next"></td><td class="diff_header" id="to140_17">17</td><td nowrap="nowrap">&nbsp;&nbsp;for&nbsp;Pytorch&nbsp;models.</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_18">18</td><td nowrap="nowrap"></td><td class="diff_next"></td><td class="diff_header" id="to140_18">18</td><td nowrap="nowrap"></td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_19">19</td><td nowrap="nowrap">**Inputs**</td><td class="diff_next"></td><td class="diff_header" id="to140_19">19</td><td nowrap="nowrap">**Inputs**</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_20">20</td><td nowrap="nowrap">Between&nbsp;2&nbsp;and&nbsp;5&nbsp;inputs.</td><td class="diff_next"></td><td class="diff_header" id="to140_20">20</td><td nowrap="nowrap">Between&nbsp;2&nbsp;and&nbsp;5&nbsp;inputs.</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_21">21</td><td nowrap="nowrap"></td><td class="diff_next"></td><td class="diff_header" id="to140_21">21</td><td nowrap="nowrap"></td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_22">22</td><td nowrap="nowrap">*&nbsp;**boxes**&nbsp;(heterogeneous)&nbsp;-&nbsp;**tensor(float)**:</td><td class="diff_next"></td><td class="diff_header" id="to140_22">22</td><td nowrap="nowrap">*&nbsp;**boxes**&nbsp;(heterogeneous)&nbsp;-&nbsp;**tensor(float)**:</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_23">23</td><td nowrap="nowrap">&nbsp;&nbsp;An&nbsp;input&nbsp;tensor&nbsp;with&nbsp;shape&nbsp;[num_batches,&nbsp;spatial_dimension,&nbsp;4].&nbsp;The</td><td class="diff_next"></td><td class="diff_header" id="to140_23">23</td><td nowrap="nowrap">&nbsp;&nbsp;An&nbsp;input&nbsp;tensor&nbsp;with&nbsp;shape&nbsp;[num_batches,&nbsp;spatial_dimension,&nbsp;4].&nbsp;The</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_24">24</td><td nowrap="nowrap">&nbsp;&nbsp;single&nbsp;box&nbsp;data&nbsp;format&nbsp;is&nbsp;indicated&nbsp;by&nbsp;center_point_box.</td><td class="diff_next"></td><td class="diff_header" id="to140_24">24</td><td nowrap="nowrap">&nbsp;&nbsp;single&nbsp;box&nbsp;data&nbsp;format&nbsp;is&nbsp;indicated&nbsp;by&nbsp;center_point_box.</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_25">25</td><td nowrap="nowrap">*&nbsp;**scores**&nbsp;(heterogeneous)&nbsp;-&nbsp;**tensor(float)**:</td><td class="diff_next"></td><td class="diff_header" id="to140_25">25</td><td nowrap="nowrap">*&nbsp;**scores**&nbsp;(heterogeneous)&nbsp;-&nbsp;**tensor(float)**:</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_26">26</td><td nowrap="nowrap">&nbsp;&nbsp;An&nbsp;input&nbsp;tensor&nbsp;with&nbsp;shape&nbsp;[num_batches,&nbsp;num_classes,</td><td class="diff_next"></td><td class="diff_header" id="to140_26">26</td><td nowrap="nowrap">&nbsp;&nbsp;An&nbsp;input&nbsp;tensor&nbsp;with&nbsp;shape&nbsp;[num_batches,&nbsp;num_classes,</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_27">27</td><td nowrap="nowrap">&nbsp;&nbsp;spatial_dimension]</td><td class="diff_next"></td><td class="diff_header" id="to140_27">27</td><td nowrap="nowrap">&nbsp;&nbsp;spatial_dimension]</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_28">28</td><td nowrap="nowrap">*&nbsp;**max_output_boxes_per_class**&nbsp;(optional,&nbsp;heterogeneous)&nbsp;-&nbsp;**tensor(int64)**:</td><td class="diff_next"></td><td class="diff_header" id="to140_28">28</td><td nowrap="nowrap">*&nbsp;**max_output_boxes_per_class**&nbsp;(optional,&nbsp;heterogeneous)&nbsp;-&nbsp;**tensor(int64)**:</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_29">29</td><td nowrap="nowrap">&nbsp;&nbsp;Integer&nbsp;representing&nbsp;the&nbsp;maximum&nbsp;number&nbsp;of&nbsp;boxes&nbsp;to&nbsp;be&nbsp;selected&nbsp;per</td><td class="diff_next"></td><td class="diff_header" id="to140_29">29</td><td nowrap="nowrap">&nbsp;&nbsp;Integer&nbsp;representing&nbsp;the&nbsp;maximum&nbsp;number&nbsp;of&nbsp;boxes&nbsp;to&nbsp;be&nbsp;selected&nbsp;per</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_30">30</td><td nowrap="nowrap">&nbsp;&nbsp;batch&nbsp;per&nbsp;class.&nbsp;It&nbsp;is&nbsp;a&nbsp;scalar.&nbsp;Default&nbsp;to&nbsp;0,&nbsp;which&nbsp;means&nbsp;no</td><td class="diff_next"></td><td class="diff_header" id="to140_30">30</td><td nowrap="nowrap">&nbsp;&nbsp;batch&nbsp;per&nbsp;class.&nbsp;It&nbsp;is&nbsp;a&nbsp;scalar.&nbsp;Default&nbsp;to&nbsp;0,&nbsp;which&nbsp;means&nbsp;no</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_31">31</td><td nowrap="nowrap">&nbsp;&nbsp;output.</td><td class="diff_next"></td><td class="diff_header" id="to140_31">31</td><td nowrap="nowrap">&nbsp;&nbsp;output.</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_32">32</td><td nowrap="nowrap">*&nbsp;**iou_threshold**&nbsp;(optional,&nbsp;heterogeneous)&nbsp;-&nbsp;**tensor(float)**:</td><td class="diff_next"></td><td class="diff_header" id="to140_32">32</td><td nowrap="nowrap">*&nbsp;**iou_threshold**&nbsp;(optional,&nbsp;heterogeneous)&nbsp;-&nbsp;**tensor(float)**:</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_33">33</td><td nowrap="nowrap">&nbsp;&nbsp;Float&nbsp;representing&nbsp;the&nbsp;threshold&nbsp;for&nbsp;deciding&nbsp;whether&nbsp;boxes&nbsp;overlap</td><td class="diff_next"></td><td class="diff_header" id="to140_33">33</td><td nowrap="nowrap">&nbsp;&nbsp;Float&nbsp;representing&nbsp;the&nbsp;threshold&nbsp;for&nbsp;deciding&nbsp;whether&nbsp;boxes&nbsp;overlap</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_34">34</td><td nowrap="nowrap">&nbsp;&nbsp;too&nbsp;much&nbsp;with&nbsp;respect&nbsp;to&nbsp;IOU.&nbsp;It&nbsp;is&nbsp;scalar.&nbsp;Value&nbsp;range&nbsp;[0,&nbsp;1].</td><td class="diff_next"></td><td class="diff_header" id="to140_34">34</td><td nowrap="nowrap">&nbsp;&nbsp;too&nbsp;much&nbsp;with&nbsp;respect&nbsp;to&nbsp;IOU.&nbsp;It&nbsp;is&nbsp;scalar.&nbsp;Value&nbsp;range&nbsp;[0,&nbsp;1].</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_35">35</td><td nowrap="nowrap">&nbsp;&nbsp;Default&nbsp;to&nbsp;0.</td><td class="diff_next"></td><td class="diff_header" id="to140_35">35</td><td nowrap="nowrap">&nbsp;&nbsp;Default&nbsp;to&nbsp;0.</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_36">36</td><td nowrap="nowrap">*&nbsp;**score_threshold**&nbsp;(optional,&nbsp;heterogeneous)&nbsp;-&nbsp;**tensor(float)**:</td><td class="diff_next"></td><td class="diff_header" id="to140_36">36</td><td nowrap="nowrap">*&nbsp;**score_threshold**&nbsp;(optional,&nbsp;heterogeneous)&nbsp;-&nbsp;**tensor(float)**:</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_37">37</td><td nowrap="nowrap">&nbsp;&nbsp;Float&nbsp;representing&nbsp;the&nbsp;threshold&nbsp;for&nbsp;deciding&nbsp;when&nbsp;to&nbsp;remove&nbsp;boxes</td><td class="diff_next"></td><td class="diff_header" id="to140_37">37</td><td nowrap="nowrap">&nbsp;&nbsp;Float&nbsp;representing&nbsp;the&nbsp;threshold&nbsp;for&nbsp;deciding&nbsp;when&nbsp;to&nbsp;remove&nbsp;boxes</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_38">38</td><td nowrap="nowrap">&nbsp;&nbsp;based&nbsp;on&nbsp;score.&nbsp;It&nbsp;is&nbsp;a&nbsp;scalar.</td><td class="diff_next"></td><td class="diff_header" id="to140_38">38</td><td nowrap="nowrap">&nbsp;&nbsp;based&nbsp;on&nbsp;score.&nbsp;It&nbsp;is&nbsp;a&nbsp;scalar.</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_39">39</td><td nowrap="nowrap"></td><td class="diff_next"></td><td class="diff_header" id="to140_39">39</td><td nowrap="nowrap"></td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_40">40</td><td nowrap="nowrap">**Outputs**</td><td class="diff_next"></td><td class="diff_header" id="to140_40">40</td><td nowrap="nowrap">**Outputs**</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_41">41</td><td nowrap="nowrap"></td><td class="diff_next"></td><td class="diff_header" id="to140_41">41</td><td nowrap="nowrap"></td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_42">42</td><td nowrap="nowrap">*&nbsp;**selected_indices**&nbsp;(heterogeneous)&nbsp;-&nbsp;**tensor(int64)**:</td><td class="diff_next"></td><td class="diff_header" id="to140_42">42</td><td nowrap="nowrap">*&nbsp;**selected_indices**&nbsp;(heterogeneous)&nbsp;-&nbsp;**tensor(int64)**:</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_43">43</td><td nowrap="nowrap">&nbsp;&nbsp;selected&nbsp;indices&nbsp;from&nbsp;the&nbsp;boxes&nbsp;tensor.&nbsp;[num_selected_indices,&nbsp;3],</td><td class="diff_next"></td><td class="diff_header" id="to140_43">43</td><td nowrap="nowrap">&nbsp;&nbsp;selected&nbsp;indices&nbsp;from&nbsp;the&nbsp;boxes&nbsp;tensor.&nbsp;[num_selected_indices,&nbsp;3],</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from140_44">44</td><td nowrap="nowrap">&nbsp;&nbsp;the&nbsp;selected&nbsp;index&nbsp;format&nbsp;is&nbsp;[batch_index,&nbsp;class_index,&nbsp;box_index].</td><td class="diff_next"></td><td class="diff_header" id="to140_44">44</td><td nowrap="nowrap">&nbsp;&nbsp;the&nbsp;selected&nbsp;index&nbsp;format&nbsp;is&nbsp;[batch_index,&nbsp;class_index,&nbsp;box_index].</td></tr>
            </tbody>
        </table>

.. _l-onnx-op-nonmaxsuppression-10:
NonMaxSuppression - 10
======================
**Version**
* **name**: `NonMaxSuppression (GitHub) <https://github.com/onnx/onnx/blob/main/docs/Operators.md#NonMaxSuppression>`_
* **domain**: **main**
* **since_version**: **10**
* **function**: False
* **support_level**: SupportType.COMMON
* **shape inference**: True

This version of the operator has been available
**since version 10**.

**Summary**

Filter out boxes that have high intersection-over-union (IOU) overlap with previously selected boxes.
Bounding boxes with score less than score_threshold are removed. Bounding box format is indicated by attribute center_point_box.
Note that this algorithm is agnostic to where the origin is in the coordinate system and more generally is invariant to
orthogonal transformations and translations of the coordinate system; thus translating or reflections of the coordinate system
result in the same boxes being selected by the algorithm.
The selected_indices output is a set of integers indexing into the input collection of bounding boxes representing the selected boxes.
The bounding box coordinates corresponding to the selected indices can then be obtained using the Gather or GatherND operation.

**Attributes**
* **center_point_box**:
  Integer indicate the format of the box data. The default is 0. 0 -
  the box data is supplied as [y1, x1, y2, x2] where (y1, x1) and (y2,
  x2) are the coordinates of any diagonal pair of box corners and the
  coordinates can be provided as normalized (i.e., lying in the
  interval [0, 1]) or absolute. Mostly used for TF models. 1 - the box
  data is supplied as [x_center, y_center, width, height]. Mostly used
  for Pytorch models.

**Inputs**
Between 2 and 5 inputs.

* **boxes** (heterogeneous) - **tensor(float)**:
  An input tensor with shape [num_batches, spatial_dimension, 4]. The
  single box data format is indicated by center_point_box.
* **scores** (heterogeneous) - **tensor(float)**:
  An input tensor with shape [num_batches, num_classes,
  spatial_dimension]
* **max_output_boxes_per_class** (optional, heterogeneous) - **tensor(int64)**:
  Integer representing the maximum number of boxes to be selected per
  batch per class. It is a scalar. Default to 0, which means no
  output.
* **iou_threshold** (optional, heterogeneous) - **tensor(float)**:
  Float representing the threshold for deciding whether boxes overlap
  too much with respect to IOU. It is scalar. Value range [0, 1].
  Default to 0.
* **score_threshold** (optional, heterogeneous) - **tensor(float)**:
  Float representing the threshold for deciding when to remove boxes
  based on score. It is a scalar.

**Outputs**

* **selected_indices** (heterogeneous) - **tensor(int64)**:
  selected indices from the boxes tensor. [num_selected_indices, 3],
  the selected index format is [batch_index, class_index, box_index].
