Resize - 13 vs 18
=================

Next section compares an older to a newer version of the same operator 
after both definition are converted into markdown text.
Green means an addition to the newer version, red means a deletion.
Anything else is unchanged.

.. raw:: html


    <div id="div_Resize_2"></div>
    <link rel="stylesheet" type="text/css" href="../_static/diff2html.min.css" />
    <script type="text/javascript" src="../_static/diff2html-ui.min.js"></script>
    <script>
    const diffString = `
    --- a/Resize13
    +++ b/Resize18
    @@ -1 +1 @@
      Resize the input tensor. In general, it calculates every value in the output tensor as a weighted average of neighborhood (a.k.a. sampling locations) in the input tensor.
    - Each dimension value of the output tensor is:
    + Each dimension value of the output tensor is: &amp;lt;br/&amp;gt;
    ?                                              ++++++++++++
    -   output_dimension = floor(input_dimension * (roi_end - roi_start) * scale) if input \&amp;#34;sizes\&amp;#34; is not specified.
    ?                                                                             ^^^^^^^ ^^ ^^^ -----------------------------
    +   output_dimension = floor(input_dimension * (roi_end - roi_start) * scale) &amp;lt;br/&amp;gt;
    ?                                                                             ^^ ^^^^ ^^
    + if input \&amp;#34;sizes\&amp;#34; is not specified.
  
      **Attributes**
  
    + * **antialias**:
    +   If set to 1, &amp;#34;linear&amp;#34; and &amp;#34;cubic&amp;#34; interpolation modes will use an
    +   antialiasing filter when downscaling. Antialiasing is achieved by
    +   stretching the resampling filter by a factor max(1, 1 / scale),
    +   which means that when downsampling, more input pixels contribute to
    +   an output pixel.
    + * **axes**:
    +   If provided, it specifies a subset of axes that &amp;#39;roi&amp;#39;, &amp;#39;scales&amp;#39; and
    +   &amp;#39;sizes&amp;#39; refer to. If not provided, all axes are assumed [0, 1, ...,
    +   r-1], where r = rank(data). Non-specified dimensions are interpreted
    +   as non-resizable. Negative value means counting dimensions from the
    +   back. Accepted range is [-r, r-1], where r = rank(data). Behavior is
    +   undefined if an axis is repeated.
      * **coordinate_transformation_mode**:
         This attribute describes how to transform the coordinate in the
        resized tensor to the coordinate in the original tensor. &amp;lt;br/&amp;gt;  The
        coordinate of each dimension is transformed individually. Let&amp;#39;s
        describe a case using axis x as an example. Denote x_resized as the
        coordinate of axis x in the resized tensor, x_original as the
    -   coordinate of axis x in the original tensor, length_original as the
    ?                                                                  ----
    +   coordinate of axis x in the original tensor, length_original as
    -   length of the original tensor in axis x, length_resized as the
    +   the length of the original tensor in axis x, length_resized as the
    ?  ++++
        length of the resized tensor in axis x, roi_x = (start_x, end_x) of
    -   the axis x in input &amp;#34;roi&amp;#34;, scale = length_resized / length_original,
    ?                                                              -----------------
    +   the axis x in input &amp;#34;roi&amp;#34;, scale = length_resized /
    +   length_original, &amp;lt;br/&amp;gt;  if coordinate_transformation_mode is
    +   &amp;#34;half_pixel&amp;#34;, &amp;lt;br/&amp;gt; x_original = (x_resized + 0.5) / scale - 0.5
    -   &amp;lt;br/&amp;gt;  if coordinate_transformation_mode is &amp;#34;half_pixel&amp;#34;, &amp;lt;br/&amp;gt;
    ?                                                                          ------------
    +   &amp;lt;br/&amp;gt;  if coordinate_transformation_mode is &amp;#34;pytorch_half_pixel&amp;#34;,
    ?                                                          ++++++++
    -   x_original = (x_resized + 0.5) / scale - 0.5, &amp;lt;br/&amp;gt;  if
    -   coordinate_transformation_mode is &amp;#34;pytorch_half_pixel&amp;#34;, &amp;lt;br/&amp;gt;
    -   x_original = length_resized &amp;gt; 1 ? (x_resized + 0.5) / scale - 0.5 :
    ?                                                                   ------
    +   &amp;lt;br/&amp;gt; x_original = length_resized &amp;gt; 1 ? (x_resized + 0.5) / scale -
    ?  ++++++++++++
    -   0, &amp;lt;br/&amp;gt;  if coordinate_transformation_mode is &amp;#34;align_corners&amp;#34;,
    ?    ^                                                  -------------------------
    +   0.5 : 0 &amp;lt;br/&amp;gt;  if coordinate_transformation_mode is
    ?    ^^^^^^
    -   &amp;lt;br/&amp;gt; x_original = x_resized * (length_original - 1) /
    ?                                                        -------
    +   &amp;#34;align_corners&amp;#34;, &amp;lt;br/&amp;gt; x_original = x_resized * (length_original
    ?  +++++++++++++++++++++++++
    +   - 1) / (length_resized - 1) &amp;lt;br/&amp;gt;  if
    +   coordinate_transformation_mode is &amp;#34;asymmetric&amp;#34;, &amp;lt;br/&amp;gt; x_original
    -   (length_resized - 1), &amp;lt;br/&amp;gt;  if coordinate_transformation_mode is
    ?   ^^^^^^^         ^ ^^^
    +   = x_resized / scale &amp;lt;br/&amp;gt;  if coordinate_transformation_mode is
    ?   ^^^         ^ ^^^^^
    +   &amp;#34;tf_crop_and_resize&amp;#34;, &amp;lt;br/&amp;gt; x_original = length_resized &amp;gt; 1 ?
    +   start_x * (length_original - 1) + x_resized * (end_x - start_x) *
    +   (length_original - 1) / (length_resized - 1) : 0.5 * (start_x +
    +   end_x) * (length_original - 1) .
    -   &amp;#34;asymmetric&amp;#34;, &amp;lt;br/&amp;gt; x_original = x_resized / scale, &amp;lt;br/&amp;gt;  if
    -   coordinate_transformation_mode is &amp;#34;tf_crop_and_resize&amp;#34;, &amp;lt;br/&amp;gt;
    -   x_original = length_resized &amp;gt; 1 ? start_x * (length_original - 1) +
    -   x_resized * (end_x - start_x) * (length_original - 1) /
    -   (length_resized - 1) : 0.5 * (start_x + end_x) * (length_original -
    -   1).
      * **cubic_coeff_a**:
        The coefficient &amp;#39;a&amp;#39; used in cubic interpolation. Two common choice
        are -0.5 (in some cases of TensorFlow) and -0.75 (in PyTorch). Check
        out Equation (4) in https://ieeexplore.ieee.org/document/1163711 for
    -   the details. This attribute is valid only if &amp;#34;mode&amp;#34; is &amp;#34;cubic&amp;#34;.
    ?                                                -----    -----
    +   the details. This attribute is valid only if mode is &amp;#34;cubic&amp;#34;.
      * **exclude_outside**:
        If set to 1, the weight of sampling locations outside the tensor
        will be set to 0 and the weight will be renormalized so that their
        sum is 1.0. The default value is 0.
      * **extrapolation_value**:
        When coordinate_transformation_mode is &amp;#34;tf_crop_and_resize&amp;#34; and
        x_original is outside the range [0, length_original - 1], this value
        is used as the corresponding output value. Default is 0.0f.
    + * **keep_aspect_ratio_policy**:
    +    This attribute describes how to interpret the sizes input with
    +   regard to keeping the original aspect ratio of the input, and it is
    +   not applicable when the scales input is used. &amp;lt;br/&amp;gt;  Given a set
    +   of sizes, associated with a subset of axes (explicitly provided
    +   or default), and assuming d = axes[i], with i being the index of
    +   the provided sizes. &amp;lt;br/&amp;gt;  If keep_aspect_ratio_policy is
    +   &amp;#34;stretch&amp;#34;, the original aspect ratio is disregarded, and the input
    +   is resized to the specified size: &amp;lt;br/&amp;gt; out_size[d] = sizes[i]
    +   &amp;lt;br/&amp;gt;  If keep_aspect_ratio_policy is &amp;#34;not_larger&amp;#34;, the sizes
    +   are adjusted so that no extent of the output is larger than the
    +   specified size, while keeping the original aspect ratio: &amp;lt;br/&amp;gt;
    +   scale = Min(sizes[i] / in_size[d]) &amp;lt;br/&amp;gt; out_size[d] =
    +   round_int(scale * in_size[i]) &amp;lt;br/&amp;gt;  If keep_aspect_ratio_policy
    +   is &amp;#34;not_smaller&amp;#34;, the sizes are adjusted so that no extent of the
    +   output is smaller than the specified size, while keeping the
    +   original aspect ratio: &amp;lt;br/&amp;gt; scale = Max(sizes[i] / in_size[d])
    +   &amp;lt;br/&amp;gt; out_size[d] = round_int(scale * in_size[i]) &amp;lt;br/&amp;gt;  For non-
    +   resizable axes (those not specified in axes), the output size will
    +   be equal to the input size.  Note: round_int stands for computing
    +   the nearest integer value, rounding halfway cases up.
      * **mode**:
    -   Three interpolation modes: nearest (default), linear and cubic. The
    ?                                                           -----------
    +   Three interpolation modes: &amp;#34;nearest&amp;#34; (default), &amp;#34;linear&amp;#34; and
    ?                              +++++       +++++            +++++      +++++
    -   &amp;#34;linear&amp;#34; mode includes linear interpolation for 1D tensor and
    ?                                                             -----------
    +   &amp;#34;cubic&amp;#34;. The &amp;#34;linear&amp;#34; mode includes linear interpolation for 1D
    ?  +++++++++++++++++++++
    -   N-linear interpolation for N-D tensor (for example, bilinear
    ?                                                      ---------
    +   tensor and N-linear interpolation for N-D tensor (for example,
    ?  +++++++++++
    -   interpolation for 2D tensor). The &amp;#34;cubic&amp;#34; mode includes cubic
    ?                                                                  ------
    +   bilinear interpolation for 2D tensor). The &amp;#34;cubic&amp;#34; mode includes
    ?  +++++++++
    -   interpolation for 1D tensor and N-cubic interpolation for N-D tensor
    ?                                                                -------
    +   cubic interpolation for 1D tensor and N-cubic interpolation for N-D
    ?  ++++++
    -   (for example, bicubic interpolation for 2D tensor).
    +   tensor (for example, bicubic interpolation for 2D tensor).
    ?  +++++++
      * **nearest_mode**:
    -   Four modes: round_prefer_floor (default, as known as round half
    +   Four modes: &amp;#34;round_prefer_floor&amp;#34; (default, as known as round half
    ?               +++++                  +++++
    -   down), round_prefer_ceil (as known as round half up), floor, ceil.
    ?                                                               ------
    +   down), &amp;#34;round_prefer_ceil&amp;#34; (as known as round half up), &amp;#34;floor&amp;#34;,
    ?          +++++                 +++++                              +++++     +++++
    -   Only used by nearest interpolation. It indicates how to get
    +   &amp;#34;ceil&amp;#34;. Only used by nearest interpolation. It indicates how to get
    ?  ++++++++++++++++
        &amp;#34;nearest&amp;#34; pixel in input tensor from x_original, so this attribute
        is valid only if &amp;#34;mode&amp;#34; is &amp;#34;nearest&amp;#34;.
  
      **Inputs**
  
      Between 1 and 4 inputs.
  
      * **X** (heterogeneous) - **T1**:
        N-D tensor
      * **roi** (optional, heterogeneous) - **T2**:
        1-D tensor given as [start1, ..., startN, end1, ..., endN], where N
    -   is the rank of X. The RoIs&amp;#39; coordinates are normalized in the
    -   coordinate system of the input image. It only takes effect when
    -   coordinate_transformation_mode is &amp;#34;tf_crop_and_resize&amp;#34;
    +   is the rank of X or the length of axes, if provided. The RoIs&amp;#39;
    +   coordinates are normalized in the coordinate system of the input
    +   image. It only takes effect when coordinate_transformation_mode is
    +   &amp;#34;tf_crop_and_resize&amp;#34;
      * **scales** (optional, heterogeneous) - **tensor(float)**:
        The scale array along each dimension. It takes value greater than 0.
        If it&amp;#39;s less than 1, it&amp;#39;s sampling down, otherwise, it&amp;#39;s upsampling.
        The number of elements of &amp;#39;scales&amp;#39; should be the same as the rank of
    -   input &amp;#39;X&amp;#39;. One of &amp;#39;scales&amp;#39; and &amp;#39;sizes&amp;#39; MUST be specified and it is
    -   an error if both are specified. If &amp;#39;sizes&amp;#39; is needed, the user can
    -   use an empty string as the name of &amp;#39;scales&amp;#39; in this operator&amp;#39;s input
    -   list.
    +   input &amp;#39;X&amp;#39; or the length of &amp;#39;axes&amp;#39;, if provided. One of &amp;#39;scales&amp;#39; and
    +   &amp;#39;sizes&amp;#39; MUST be specified and it is an error if both are specified.
    +   If &amp;#39;sizes&amp;#39; is needed, the user can use an empty string as the name
    +   of &amp;#39;scales&amp;#39; in this operator&amp;#39;s input list.
      * **sizes** (optional, heterogeneous) - **tensor(int64)**:
    -   The size of the output tensor. The number of elements of &amp;#39;sizes&amp;#39;
    +   Target size of the output tensor. Its interpretation depends on the
    +   &amp;#39;keep_aspect_ratio_policy&amp;#39; value.The number of elements of &amp;#39;sizes&amp;#39;
    -   should be the same as the rank of input &amp;#39;X&amp;#39;. Only one of &amp;#39;scales&amp;#39;
    ?                                                      ^^^^^^   ^   -----------------
    +   should be the same as the rank of input &amp;#39;X&amp;#39;, or the length of
    ?                                                      ^  ++++++++ ^^^
    -   and &amp;#39;sizes&amp;#39; can be specified.
    +   &amp;#39;axes&amp;#39;, if provided. Only one of &amp;#39;scales&amp;#39; and &amp;#39;sizes&amp;#39; can be
    +   specified.
  
      **Outputs**
  
      * **Y** (heterogeneous) - **T1**:
        N-D tensor after resizing
  
      **Type Constraints**
  
      * **T1** in (
        tensor(bfloat16),
        tensor(bool),
        tensor(complex128),
        tensor(complex64),
        tensor(double),
        tensor(float),
        tensor(float16),
        tensor(int16),
        tensor(int32),
        tensor(int64),
        tensor(int8),
        tensor(string),
        tensor(uint16),
        tensor(uint32),
        tensor(uint64),
        tensor(uint8)
        ):
        Constrain input &amp;#39;X&amp;#39; and output &amp;#39;Y&amp;#39; to all tensor types.
      * **T2** in (
        tensor(double),
        tensor(float),
        tensor(float16)
        ):
        Constrain roi type to float or double.
    `;

    document.addEventListener('DOMContentLoaded', function () {
    var targetElement = document.getElementById('div_Resize_2');
    var configuration = {
        drawFileList: true,
        fileListToggle: false,
        fileListStartVisible: false,
        fileContentToggle: false,
        matching: 'lines',
        outputFormat: 'line-by-line',
        synchronisedScroll: true,
        highlight: true,
        renderNothingWhenEmpty: false,
    };
    var diff2htmlUi = new Diff2HtmlUI(targetElement, diffString, configuration);
    diff2htmlUi.draw();
    diff2htmlUi.highlightCode();
    });
    </script>