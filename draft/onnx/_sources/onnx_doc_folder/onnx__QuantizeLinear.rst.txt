
.. _l-onnx-doc-QuantizeLinear:

==============
QuantizeLinear
==============

.. contents::
    :local:


.. _l-onnx-op-quantizelinear-13:
QuantizeLinear - 13
===================
**Version**
* **name**: `QuantizeLinear (GitHub) <https://github.com/onnx/onnx/blob/main/docs/Operators.md#QuantizeLinear>`_
* **domain**: **main**
* **since_version**: **13**
* **function**: False
* **support_level**: SupportType.COMMON
* **shape inference**: True

This version of the operator has been available
**since version 13**.

**Summary**

The linear quantization operator. It consumes a high precision tensor, a scale, and a zero point to compute the low precision / quantized tensor.
The scale factor and zero point must have same shape, and can be either a scalar for per-tensor / per layer quantization, or a 1-D tensor for per-axis quantization.
The quantization formula is y = saturate ((x / y_scale) + y_zero_point).
For saturation, it saturates to [0, 255] if it's uint8, or [-128, 127] if it's int8.
For (x / y_scale), it's rounding to nearest ties to even. Refer to https://en.wikipedia.org/wiki/Rounding for details. 'y_zero_point' and 'y' must have same type.

**Attributes**
* **axis**:
  (Optional) The axis of the quantization dimension of the input
  tensor. Ignored for per-tensor quantization. Negative value means
  counting dimensions from the back. Accepted range is [-r, r-1] where
  r = rank(input).

**Inputs**
Between 2 and 3 inputs.

* **x** (heterogeneous) - **T1**:
  N-D full precision Input tensor to be quantized.
* **y_scale** (heterogeneous) - **tensor(float)**:
  Scale for doing quantization to get 'y'. It can be a scalar, which
  means per-tensor/layer quantization, or a 1-D Tensor for per-axis
  quantization.
* **y_zero_point** (optional, heterogeneous) - **T2**:
  Zero point for doing quantization to get 'y'. Shape must match
  y_scale. Default is uint8 with zero point of 0 if it's not
  specified.

**Outputs**

* **y** (heterogeneous) - **T2**:
  N-D quantized output tensor. It has same shape as input 'x'.

**Type Constraints**
* **T1** in (
  tensor(float),
  tensor(int32)
  ):
  Constrain 'x' to float or int32 tensor.
* **T2** in (
  tensor(int8),
  tensor(uint8)
  ):
  Constrain 'y_zero_point' and 'y' to 8-bit integer tensor.

**Examples**

**default**
::
    node = onnx.helper.make_node(
        "QuantizeLinear",
        inputs=["x", "y_scale", "y_zero_point"],
        outputs=["y"],
    )

    x = np.array([0, 2, 3, 1000, -254, -1000]).astype(np.float32)
    y_scale = np.float32(2)
    y_zero_point = np.uint8(128)
    y = np.array([128, 129, 130, 255, 1, 0]).astype(np.uint8)

    expect(
        node,
        inputs=[x, y_scale, y_zero_point],
        outputs=[y],
        name="test_quantizelinear",
    )

**_axis**
::
    node = onnx.helper.make_node(
        "QuantizeLinear",
        inputs=["x", "y_scale", "y_zero_point"],
        outputs=["y"],
    )

    x = np.array(
        [
            [
                [[-162, 10], [-100, 232], [-20, -50]],
                [[-76, 0], [0, 252], [32, -44]],
                [[245, -485], [-960, -270], [-375, -470]],
            ],
        ],
        dtype=np.float32,
    )
    y_scale = np.array([2, 4, 5], dtype=np.float32)
    y_zero_point = np.array([84, 24, 196], dtype=np.uint8)
    y = (x / y_scale.reshape(1, 3, 1, 1) + y_zero_point.reshape(1, 3, 1, 1)).astype(
        np.uint8
    )

    expect(
        node,
        inputs=[x, y_scale, y_zero_point],
        outputs=[y],
        name="test_quantizelinear_axis",
    )

**Differences**

.. raw:: html

        <table class="diff" id="difflib_chg_to158__top"
               cellspacing="0" cellpadding="0" rules="groups" >
            <colgroup></colgroup> <colgroup></colgroup> <colgroup></colgroup>
            <colgroup></colgroup> <colgroup></colgroup> <colgroup></colgroup>

            <tbody>
                <tr><td class="diff_next" id="difflib_chg_to158__1"><a href="#difflib_chg_to158__1">n</a></td><td class="diff_header" id="from158_1">1</td><td nowrap="nowrap">The&nbsp;linear<span class="diff_sub">&nbsp;per-tensor/layer</span>&nbsp;quantization&nbsp;operator.&nbsp;It&nbsp;consumes&nbsp;a&nbsp;high&nbsp;precision&nbsp;tensor,&nbsp;a&nbsp;scale,&nbsp;a&nbsp;zero&nbsp;point&nbsp;to&nbsp;compute&nbsp;the&nbsp;low&nbsp;precision&nbsp;/&nbsp;quantized&nbsp;tensor.</td><td class="diff_next"><a href="#difflib_chg_to158__1">n</a></td><td class="diff_header" id="to158_1">1</td><td nowrap="nowrap">The&nbsp;linear&nbsp;quantization&nbsp;operator.&nbsp;It&nbsp;consumes&nbsp;a&nbsp;high&nbsp;precision&nbsp;tensor,&nbsp;a&nbsp;scale,&nbsp;a<span class="diff_add">nd&nbsp;a</span>&nbsp;zero&nbsp;point&nbsp;to&nbsp;compute&nbsp;the&nbsp;low&nbsp;precision&nbsp;/&nbsp;quantized&nbsp;tensor.</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from158_2">2</td><td nowrap="nowrap"><span class="diff_sub">The&nbsp;quantization&nbsp;formula&nbsp;is&nbsp;y&nbsp;=&nbsp;saturate&nbsp;((x&nbsp;/&nbsp;y_scale)&nbsp;+&nbsp;y_zero_point).&nbsp;For&nbsp;saturation,&nbsp;it&nbsp;saturates&nbsp;to&nbsp;[0,&nbsp;255]&nbsp;if&nbsp;it's&nbsp;uint8,&nbsp;or&nbsp;[-128,&nbsp;127]&nbsp;if&nbsp;it's&nbsp;int8.</span></td><td class="diff_next"></td><td class="diff_header" id="to158_2">2</td><td nowrap="nowrap"><span class="diff_add">The&nbsp;scale&nbsp;factor&nbsp;and&nbsp;zero&nbsp;point&nbsp;must&nbsp;have&nbsp;same&nbsp;shape,&nbsp;and&nbsp;can&nbsp;be&nbsp;either&nbsp;a&nbsp;scalar&nbsp;for&nbsp;per-tensor&nbsp;/&nbsp;per&nbsp;layer&nbsp;quantization,&nbsp;or&nbsp;a&nbsp;1-D&nbsp;tensor&nbsp;for&nbsp;per-axis&nbsp;quantization.</span></td></tr>
                <tr><td class="diff_next"></td><td class="diff_header"></td><td nowrap="nowrap"></td><td class="diff_next"></td><td class="diff_header" id="to158_3">3</td><td nowrap="nowrap"><span class="diff_add">The&nbsp;quantization&nbsp;formula&nbsp;is&nbsp;y&nbsp;=&nbsp;saturate&nbsp;((x&nbsp;/&nbsp;y_scale)&nbsp;+&nbsp;y_zero_point).</span></td></tr>
                <tr><td class="diff_next"></td><td class="diff_header"></td><td nowrap="nowrap"></td><td class="diff_next"></td><td class="diff_header" id="to158_4">4</td><td nowrap="nowrap"><span class="diff_add">For&nbsp;saturation,&nbsp;it&nbsp;saturates&nbsp;to&nbsp;[0,&nbsp;255]&nbsp;if&nbsp;it's&nbsp;uint8,&nbsp;or&nbsp;[-128,&nbsp;127]&nbsp;if&nbsp;it's&nbsp;int8.</span></td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from158_3">3</td><td nowrap="nowrap">For&nbsp;(x&nbsp;/&nbsp;y_scale),&nbsp;it's&nbsp;rounding&nbsp;to&nbsp;nearest&nbsp;ties&nbsp;to&nbsp;even.&nbsp;Refer&nbsp;to&nbsp;https://en.wikipedia.org/wiki/Rounding&nbsp;for&nbsp;details.&nbsp;'y_zero_point'&nbsp;and&nbsp;'y'&nbsp;must&nbsp;have&nbsp;same&nbsp;type.</td><td class="diff_next"></td><td class="diff_header" id="to158_5">5</td><td nowrap="nowrap">For&nbsp;(x&nbsp;/&nbsp;y_scale),&nbsp;it's&nbsp;rounding&nbsp;to&nbsp;nearest&nbsp;ties&nbsp;to&nbsp;even.&nbsp;Refer&nbsp;to&nbsp;https://en.wikipedia.org/wiki/Rounding&nbsp;for&nbsp;details.&nbsp;'y_zero_point'&nbsp;and&nbsp;'y'&nbsp;must&nbsp;have&nbsp;same&nbsp;type.</td></tr>
                <tr><td class="diff_next"><a href="#difflib_chg_to158__2">n</a></td><td class="diff_header"></td><td nowrap="nowrap"></td><td class="diff_next"><a href="#difflib_chg_to158__2">n</a></td><td class="diff_header" id="to158_6">6</td><td nowrap="nowrap"><span class="diff_add">&nbsp;</span></td></tr>
                <tr><td class="diff_next"></td><td class="diff_header"></td><td nowrap="nowrap"></td><td class="diff_next"></td><td class="diff_header" id="to158_7">7</td><td nowrap="nowrap"><span class="diff_add">**Attributes**</span></td></tr>
                <tr><td class="diff_next"></td><td class="diff_header"></td><td nowrap="nowrap"></td><td class="diff_next"></td><td class="diff_header" id="to158_8">8</td><td nowrap="nowrap"><span class="diff_add">*&nbsp;**axis**:</span></td></tr>
                <tr><td class="diff_next"></td><td class="diff_header"></td><td nowrap="nowrap"></td><td class="diff_next"></td><td class="diff_header" id="to158_9">9</td><td nowrap="nowrap"><span class="diff_add">&nbsp;&nbsp;(Optional)&nbsp;The&nbsp;axis&nbsp;of&nbsp;the&nbsp;quantization&nbsp;dimension&nbsp;of&nbsp;the&nbsp;input</span></td></tr>
                <tr><td class="diff_next"></td><td class="diff_header"></td><td nowrap="nowrap"></td><td class="diff_next"></td><td class="diff_header" id="to158_10">10</td><td nowrap="nowrap"><span class="diff_add">&nbsp;&nbsp;tensor.&nbsp;Ignored&nbsp;for&nbsp;per-tensor&nbsp;quantization.&nbsp;Negative&nbsp;value&nbsp;means</span></td></tr>
                <tr><td class="diff_next"></td><td class="diff_header"></td><td nowrap="nowrap"></td><td class="diff_next"></td><td class="diff_header" id="to158_11">11</td><td nowrap="nowrap"><span class="diff_add">&nbsp;&nbsp;counting&nbsp;dimensions&nbsp;from&nbsp;the&nbsp;back.&nbsp;Accepted&nbsp;range&nbsp;is&nbsp;[-r,&nbsp;r-1]&nbsp;where</span></td></tr>
                <tr><td class="diff_next"></td><td class="diff_header"></td><td nowrap="nowrap"></td><td class="diff_next"></td><td class="diff_header" id="to158_12">12</td><td nowrap="nowrap"><span class="diff_add">&nbsp;&nbsp;r&nbsp;=&nbsp;rank(input).</span></td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from158_4">4</td><td nowrap="nowrap"></td><td class="diff_next"></td><td class="diff_header" id="to158_13">13</td><td nowrap="nowrap"></td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from158_5">5</td><td nowrap="nowrap">**Inputs**</td><td class="diff_next"></td><td class="diff_header" id="to158_14">14</td><td nowrap="nowrap">**Inputs**</td></tr>
                <tr><td class="diff_next" id="difflib_chg_to158__2"></td><td class="diff_header" id="from158_6">6</td><td nowrap="nowrap">Between&nbsp;2&nbsp;and&nbsp;3&nbsp;inputs.</td><td class="diff_next"></td><td class="diff_header" id="to158_15">15</td><td nowrap="nowrap">Between&nbsp;2&nbsp;and&nbsp;3&nbsp;inputs.</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from158_7">7</td><td nowrap="nowrap"></td><td class="diff_next"></td><td class="diff_header" id="to158_16">16</td><td nowrap="nowrap"></td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from158_8">8</td><td nowrap="nowrap">*&nbsp;**x**&nbsp;(heterogeneous)&nbsp;-&nbsp;**T1**:</td><td class="diff_next"></td><td class="diff_header" id="to158_17">17</td><td nowrap="nowrap">*&nbsp;**x**&nbsp;(heterogeneous)&nbsp;-&nbsp;**T1**:</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from158_9">9</td><td nowrap="nowrap">&nbsp;&nbsp;N-D&nbsp;full&nbsp;precision&nbsp;Input&nbsp;tensor&nbsp;to&nbsp;be&nbsp;quantized.</td><td class="diff_next"></td><td class="diff_header" id="to158_18">18</td><td nowrap="nowrap">&nbsp;&nbsp;N-D&nbsp;full&nbsp;precision&nbsp;Input&nbsp;tensor&nbsp;to&nbsp;be&nbsp;quantized.</td></tr>
                <tr><td class="diff_next" id="difflib_chg_to158__3"></td><td class="diff_header" id="from158_10">10</td><td nowrap="nowrap">*&nbsp;**y_scale**&nbsp;(heterogeneous)&nbsp;-&nbsp;**tensor(float)**:</td><td class="diff_next"></td><td class="diff_header" id="to158_19">19</td><td nowrap="nowrap">*&nbsp;**y_scale**&nbsp;(heterogeneous)&nbsp;-&nbsp;**tensor(float)**:</td></tr>
                <tr><td class="diff_next"><a href="#difflib_chg_to158__3">n</a></td><td class="diff_header" id="from158_11">11</td><td nowrap="nowrap">&nbsp;&nbsp;Scale&nbsp;for&nbsp;doing&nbsp;quantization&nbsp;to&nbsp;get&nbsp;'y'.&nbsp;It<span class="diff_chg">'s&nbsp;</span>a&nbsp;scalar,&nbsp;which<span class="diff_sub">&nbsp;means</span></td><td class="diff_next"><a href="#difflib_chg_to158__3">n</a></td><td class="diff_header" id="to158_20">20</td><td nowrap="nowrap">&nbsp;&nbsp;Scale&nbsp;for&nbsp;doing&nbsp;quantization&nbsp;to&nbsp;get&nbsp;'y'.&nbsp;It<span class="diff_chg">&nbsp;c</span>a<span class="diff_add">n&nbsp;be&nbsp;a</span>&nbsp;scalar,&nbsp;which</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from158_12">12</td><td nowrap="nowrap"><span class="diff_sub">&nbsp;&nbsp;a&nbsp;per-tensor/layer&nbsp;quantization.</span></td><td class="diff_next"></td><td class="diff_header" id="to158_21">21</td><td nowrap="nowrap"><span class="diff_add">&nbsp;&nbsp;means&nbsp;per-tensor/layer&nbsp;quantization,&nbsp;or&nbsp;a&nbsp;1-D&nbsp;Tensor&nbsp;for&nbsp;per-axis</span></td></tr>
                <tr><td class="diff_next"></td><td class="diff_header"></td><td nowrap="nowrap"></td><td class="diff_next"></td><td class="diff_header" id="to158_22">22</td><td nowrap="nowrap"><span class="diff_add">&nbsp;&nbsp;quantization.</span></td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from158_13">13</td><td nowrap="nowrap">*&nbsp;**y_zero_point**&nbsp;(optional,&nbsp;heterogeneous)&nbsp;-&nbsp;**T2**:</td><td class="diff_next"></td><td class="diff_header" id="to158_23">23</td><td nowrap="nowrap">*&nbsp;**y_zero_point**&nbsp;(optional,&nbsp;heterogeneous)&nbsp;-&nbsp;**T2**:</td></tr>
                <tr><td class="diff_next"><a href="#difflib_chg_to158__top">t</a></td><td class="diff_header" id="from158_14">14</td><td nowrap="nowrap">&nbsp;&nbsp;Zero&nbsp;point&nbsp;for&nbsp;doing&nbsp;quantization&nbsp;to&nbsp;get&nbsp;'y'.&nbsp;<span class="diff_chg">I</span>t<span class="diff_chg">'s&nbsp;</span>a<span class="diff_chg">&nbsp;scalar,&nbsp;whi</span>ch</td><td class="diff_next"><a href="#difflib_chg_to158__top">t</a></td><td class="diff_header" id="to158_24">24</td><td nowrap="nowrap">&nbsp;&nbsp;Zero&nbsp;point&nbsp;for&nbsp;doing&nbsp;quantization&nbsp;to&nbsp;get&nbsp;'y'.&nbsp;<span class="diff_chg">Shape&nbsp;mus</span>t<span class="diff_chg">&nbsp;m</span>a<span class="diff_chg">t</span>ch</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from158_15">15</td><td nowrap="nowrap"><span class="diff_sub">&nbsp;&nbsp;means&nbsp;a&nbsp;per-tensor/layer&nbsp;quantization.&nbsp;Default&nbsp;value&nbsp;is&nbsp;uint8&nbsp;typed</span></td><td class="diff_next"></td><td class="diff_header" id="to158_25">25</td><td nowrap="nowrap"><span class="diff_add">&nbsp;&nbsp;y_scale.&nbsp;Default&nbsp;is&nbsp;uint8&nbsp;with&nbsp;zero&nbsp;point&nbsp;of&nbsp;0&nbsp;if&nbsp;it's&nbsp;not</span></td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from158_16">16</td><td nowrap="nowrap"><span class="diff_sub">&nbsp;&nbsp;0&nbsp;if&nbsp;it's&nbsp;not&nbsp;specified.</span></td><td class="diff_next"></td><td class="diff_header" id="to158_26">26</td><td nowrap="nowrap"><span class="diff_add">&nbsp;&nbsp;specified.</span></td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from158_17">17</td><td nowrap="nowrap"></td><td class="diff_next"></td><td class="diff_header" id="to158_27">27</td><td nowrap="nowrap"></td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from158_18">18</td><td nowrap="nowrap">**Outputs**</td><td class="diff_next"></td><td class="diff_header" id="to158_28">28</td><td nowrap="nowrap">**Outputs**</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from158_19">19</td><td nowrap="nowrap"></td><td class="diff_next"></td><td class="diff_header" id="to158_29">29</td><td nowrap="nowrap"></td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from158_20">20</td><td nowrap="nowrap">*&nbsp;**y**&nbsp;(heterogeneous)&nbsp;-&nbsp;**T2**:</td><td class="diff_next"></td><td class="diff_header" id="to158_30">30</td><td nowrap="nowrap">*&nbsp;**y**&nbsp;(heterogeneous)&nbsp;-&nbsp;**T2**:</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from158_21">21</td><td nowrap="nowrap">&nbsp;&nbsp;N-D&nbsp;quantized&nbsp;output&nbsp;tensor.&nbsp;It&nbsp;has&nbsp;same&nbsp;shape&nbsp;as&nbsp;input&nbsp;'x'.</td><td class="diff_next"></td><td class="diff_header" id="to158_31">31</td><td nowrap="nowrap">&nbsp;&nbsp;N-D&nbsp;quantized&nbsp;output&nbsp;tensor.&nbsp;It&nbsp;has&nbsp;same&nbsp;shape&nbsp;as&nbsp;input&nbsp;'x'.</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from158_22">22</td><td nowrap="nowrap"></td><td class="diff_next"></td><td class="diff_header" id="to158_32">32</td><td nowrap="nowrap"></td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from158_23">23</td><td nowrap="nowrap">**Type&nbsp;Constraints**</td><td class="diff_next"></td><td class="diff_header" id="to158_33">33</td><td nowrap="nowrap">**Type&nbsp;Constraints**</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from158_24">24</td><td nowrap="nowrap">*&nbsp;**T1**&nbsp;in&nbsp;(</td><td class="diff_next"></td><td class="diff_header" id="to158_34">34</td><td nowrap="nowrap">*&nbsp;**T1**&nbsp;in&nbsp;(</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from158_25">25</td><td nowrap="nowrap">&nbsp;&nbsp;tensor(float),</td><td class="diff_next"></td><td class="diff_header" id="to158_35">35</td><td nowrap="nowrap">&nbsp;&nbsp;tensor(float),</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from158_26">26</td><td nowrap="nowrap">&nbsp;&nbsp;tensor(int32)</td><td class="diff_next"></td><td class="diff_header" id="to158_36">36</td><td nowrap="nowrap">&nbsp;&nbsp;tensor(int32)</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from158_27">27</td><td nowrap="nowrap">&nbsp;&nbsp;):</td><td class="diff_next"></td><td class="diff_header" id="to158_37">37</td><td nowrap="nowrap">&nbsp;&nbsp;):</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from158_28">28</td><td nowrap="nowrap">&nbsp;&nbsp;Constrain&nbsp;'x'&nbsp;to&nbsp;float&nbsp;or&nbsp;int32&nbsp;tensor.</td><td class="diff_next"></td><td class="diff_header" id="to158_38">38</td><td nowrap="nowrap">&nbsp;&nbsp;Constrain&nbsp;'x'&nbsp;to&nbsp;float&nbsp;or&nbsp;int32&nbsp;tensor.</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from158_29">29</td><td nowrap="nowrap">*&nbsp;**T2**&nbsp;in&nbsp;(</td><td class="diff_next"></td><td class="diff_header" id="to158_39">39</td><td nowrap="nowrap">*&nbsp;**T2**&nbsp;in&nbsp;(</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from158_30">30</td><td nowrap="nowrap">&nbsp;&nbsp;tensor(int8),</td><td class="diff_next"></td><td class="diff_header" id="to158_40">40</td><td nowrap="nowrap">&nbsp;&nbsp;tensor(int8),</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from158_31">31</td><td nowrap="nowrap">&nbsp;&nbsp;tensor(uint8)</td><td class="diff_next"></td><td class="diff_header" id="to158_41">41</td><td nowrap="nowrap">&nbsp;&nbsp;tensor(uint8)</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from158_32">32</td><td nowrap="nowrap">&nbsp;&nbsp;):</td><td class="diff_next"></td><td class="diff_header" id="to158_42">42</td><td nowrap="nowrap">&nbsp;&nbsp;):</td></tr>
                <tr><td class="diff_next"></td><td class="diff_header" id="from158_33">33</td><td nowrap="nowrap">&nbsp;&nbsp;Constrain&nbsp;'y_zero_point'&nbsp;and&nbsp;'y'&nbsp;to&nbsp;8-bit&nbsp;integer&nbsp;tensor.</td><td class="diff_next"></td><td class="diff_header" id="to158_43">43</td><td nowrap="nowrap">&nbsp;&nbsp;Constrain&nbsp;'y_zero_point'&nbsp;and&nbsp;'y'&nbsp;to&nbsp;8-bit&nbsp;integer&nbsp;tensor.</td></tr>
            </tbody>
        </table>

.. _l-onnx-op-quantizelinear-10:
QuantizeLinear - 10
===================
**Version**
* **name**: `QuantizeLinear (GitHub) <https://github.com/onnx/onnx/blob/main/docs/Operators.md#QuantizeLinear>`_
* **domain**: **main**
* **since_version**: **10**
* **function**: False
* **support_level**: SupportType.COMMON
* **shape inference**: True

This version of the operator has been available
**since version 10**.

**Summary**

The linear per-tensor/layer quantization operator. It consumes a high precision tensor, a scale, a zero point to compute the low precision / quantized tensor.
The quantization formula is y = saturate ((x / y_scale) + y_zero_point). For saturation, it saturates to [0, 255] if it's uint8, or [-128, 127] if it's int8.
For (x / y_scale), it's rounding to nearest ties to even. Refer to https://en.wikipedia.org/wiki/Rounding for details. 'y_zero_point' and 'y' must have same type.

**Inputs**
Between 2 and 3 inputs.

* **x** (heterogeneous) - **T1**:
  N-D full precision Input tensor to be quantized.
* **y_scale** (heterogeneous) - **tensor(float)**:
  Scale for doing quantization to get 'y'. It's a scalar, which means
  a per-tensor/layer quantization.
* **y_zero_point** (optional, heterogeneous) - **T2**:
  Zero point for doing quantization to get 'y'. It's a scalar, which
  means a per-tensor/layer quantization. Default value is uint8 typed
  0 if it's not specified.

**Outputs**

* **y** (heterogeneous) - **T2**:
  N-D quantized output tensor. It has same shape as input 'x'.

**Type Constraints**
* **T1** in (
  tensor(float),
  tensor(int32)
  ):
  Constrain 'x' to float or int32 tensor.
* **T2** in (
  tensor(int8),
  tensor(uint8)
  ):
  Constrain 'y_zero_point' and 'y' to 8-bit integer tensor.
