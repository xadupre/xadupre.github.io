
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "gyexamples/plot_benchmark_ort_api.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_gyexamples_plot_benchmark_ort_api.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_gyexamples_plot_benchmark_ort_api.py:


.. _benchmark-ort-api:

Benchmark onnxruntime API: run or ...
=====================================

This short code compares different methods to call onnxruntime API.

* `run`
* `run_with_ort_values`
* `run_with_iobinding`

You may profile this code:

::

    py-spy record -o plot_benchmark_ort_api.svg -r 10
    --native -- python plot_benchmark_ort_api.py


.. contents::
    :local:

Linear Regression
+++++++++++++++++

.. GENERATED FROM PYTHON SOURCE LINES 28-42

.. code-block:: default

    import numpy
    import pandas
    from onnxruntime import InferenceSession
    from onnxruntime.capi._pybind_state import (  # pylint: disable=E0611
        SessionIOBinding, OrtDevice as C_OrtDevice,
        OrtMemType, OrtValue as C_OrtValue, RunOptions)
    from sklearn import config_context
    from sklearn.linear_model import LinearRegression
    from skl2onnx import to_onnx
    from cpyquickhelper.numbers.speed_measure import measure_time
    from mlprodict.onnxrt import OnnxInference
    from mlprodict.plotting.plotting import onnx_simple_text_plot
    from mlprodict.testing.experimental_c_impl.experimental_c import code_optimisation








.. GENERATED FROM PYTHON SOURCE LINES 43-44

Available optimisation on this machine.

.. GENERATED FROM PYTHON SOURCE LINES 44-50

.. code-block:: default


    print(code_optimisation())
    repeat = 250
    number = 250






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    AVX-omp=8




.. GENERATED FROM PYTHON SOURCE LINES 51-53

Building the model
++++++++++++++++++

.. GENERATED FROM PYTHON SOURCE LINES 53-60

.. code-block:: default


    X = numpy.random.randn(1000, 10).astype(numpy.float32)
    y = X.sum(axis=1)

    model = LinearRegression()
    model.fit(X, y)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    LinearRegression()



.. GENERATED FROM PYTHON SOURCE LINES 61-63

Conversion to ONNX
++++++++++++++++++

.. GENERATED FROM PYTHON SOURCE LINES 63-67

.. code-block:: default

    onx = to_onnx(model, X, black_op={'LinearRegressor'})
    print(onnx_simple_text_plot(onx))






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    opset: domain='' version=13
    input: name='X' type=dtype('float32') shape=(0, 10)
    init: name='coef' type=dtype('float32') shape=(10,)
    init: name='intercept' type=dtype('float32') shape=(1,) -- array([1.4016405e-07], dtype=float32)
    init: name='shape_tensor' type=dtype('int64') shape=(2,) -- array([-1,  1])
    MatMul(X, coef) -> multiplied
      Add(multiplied, intercept) -> resh
        Reshape(resh, shape_tensor) -> variable
    output: name='variable' type=dtype('float32') shape=(0, 1)




.. GENERATED FROM PYTHON SOURCE LINES 68-70

Benchmarks
++++++++++

.. GENERATED FROM PYTHON SOURCE LINES 70-73

.. code-block:: default


    data = []








.. GENERATED FROM PYTHON SOURCE LINES 74-75

scikit-learn

.. GENERATED FROM PYTHON SOURCE LINES 75-85

.. code-block:: default

    print('scikit-learn')

    with config_context(assume_finite=True):
        obs = measure_time(lambda: model.predict(X),
                           context=dict(model=model, X=X),
                           repeat=repeat, number=number)
        obs['name'] = 'skl'
        data.append(obs)






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    scikit-learn




.. GENERATED FROM PYTHON SOURCE LINES 86-87

numpy runtime

.. GENERATED FROM PYTHON SOURCE LINES 87-96

.. code-block:: default

    print('numpy')
    oinf = OnnxInference(onx, runtime="python_compiled")
    obs = measure_time(
        lambda: oinf.run({'X': X}), context=dict(oinf=oinf, X=X),
        repeat=repeat, number=number)
    obs['name'] = 'numpy'
    data.append(obs)






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    numpy




.. GENERATED FROM PYTHON SOURCE LINES 97-98

onnxruntime: run

.. GENERATED FROM PYTHON SOURCE LINES 98-108

.. code-block:: default

    print('ort')
    sess = InferenceSession(onx.SerializeToString(),
                            providers=['CPUExecutionProvider'])
    obs = measure_time(lambda: sess.run(None, {'X': X}),
                       context=dict(sess=sess, X=X),
                       repeat=repeat, number=number)
    obs['name'] = 'ort-run'
    data.append(obs)






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    ort




.. GENERATED FROM PYTHON SOURCE LINES 109-110

onnxruntime: run

.. GENERATED FROM PYTHON SOURCE LINES 110-123

.. code-block:: default

    print('ort-c')
    sess = InferenceSession(onx.SerializeToString(),
                            providers=['CPUExecutionProvider'])
    ro = RunOptions()
    output_names = [o.name for o in sess.get_outputs()]
    obs = measure_time(
        lambda: sess._sess.run(output_names, {'X': X}, ro),
        context=dict(sess=sess, X=X),
        repeat=repeat, number=number)
    obs['name'] = 'ort-c'
    data.append(obs)






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    ort-c




.. GENERATED FROM PYTHON SOURCE LINES 124-125

onnxruntime: run_with_ort_values

.. GENERATED FROM PYTHON SOURCE LINES 125-143

.. code-block:: default

    print('ort-ov-c')
    device = C_OrtDevice(C_OrtDevice.cpu(), OrtMemType.DEFAULT, 0)

    Xov = C_OrtValue.ortvalue_from_numpy(X, device)

    sess = InferenceSession(onx.SerializeToString(),
                            providers=['CPUExecutionProvider'])
    ro = RunOptions()
    output_names = [o.name for o in sess.get_outputs()]
    obs = measure_time(
        lambda: sess._sess.run_with_ort_values(
            {'X': Xov}, output_names, ro),
        context=dict(sess=sess),
        repeat=repeat, number=number)
    obs['name'] = 'ort-ov'
    data.append(obs)






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    ort-ov-c




.. GENERATED FROM PYTHON SOURCE LINES 144-145

onnxruntime: run_with_iobinding

.. GENERATED FROM PYTHON SOURCE LINES 145-172

.. code-block:: default

    print('ort-bind')
    sess = InferenceSession(onx.SerializeToString(),
                            providers=['CPUExecutionProvider'])
    bind = SessionIOBinding(sess._sess)
    ort_device = C_OrtDevice(C_OrtDevice.cpu(), C_OrtDevice.default_memory(), 0)


    def run_with_iobinding(sess, X, bind, ort_device):
        if X.__array_interface__['strides'] is not None:
            raise RuntimeError("onnxruntime only supports contiguous arrays.")
        bind.bind_input('X', ort_device, X.dtype, X.shape,
                        X.__array_interface__['data'][0])
        bind.bind_output('variable', ort_device)
        sess._sess.run_with_iobinding(bind, None)
        ortvalues = bind.get_outputs()
        return ortvalues[0].numpy()


    obs = measure_time(lambda: run_with_iobinding(sess, X, bind, ort_device),
                       context=dict(run_with_iobinding=run_with_iobinding, X=X,
                                    sess=sess, bind=bind, ort_device=ort_device),
                       repeat=repeat, number=number)

    obs['name'] = 'ort-bind'
    data.append(obs)






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    ort-bind




.. GENERATED FROM PYTHON SOURCE LINES 173-179

This fourth implementation is very similar to the previous
one but it only binds array once and reuse the memory
without changing the binding. It assumes that input size
and output size never change. It copies the data into
the fixed buffer and returns the same array, modified
inplace.

.. GENERATED FROM PYTHON SOURCE LINES 179-216

.. code-block:: default


    print('ort-bind-inplace')
    sess = InferenceSession(onx.SerializeToString(),
                            providers=['CPUExecutionProvider'])
    bind = SessionIOBinding(sess._sess)
    ort_device = C_OrtDevice(C_OrtDevice.cpu(), C_OrtDevice.default_memory(), 0)

    Y = sess.run(None, {'X': X})[0]
    bX = X.copy()
    bY = Y.copy()

    bind.bind_input('X', ort_device, numpy.float32, bX.shape,
                    bX.__array_interface__['data'][0])
    bind.bind_output('variable', ort_device, numpy.float32, bY.shape,
                     bY.__array_interface__['data'][0])
    ortvalues = bind.get_outputs()


    def run_with_iobinding(sess, bX, bY, X, bind, ortvalues):
        if X.__array_interface__['strides'] is not None:
            raise RuntimeError("onnxruntime only supports contiguous arrays.")
        bX[:, :] = X[:, :]
        sess._sess.run_with_iobinding(bind, None)
        return bY


    obs = measure_time(
        lambda: run_with_iobinding(
            sess, bX, bY, X, bind, ortvalues),
        context=dict(run_with_iobinding=run_with_iobinding, X=X,
                     sess=sess, bind=bind, ortvalues=ortvalues, bX=bX, bY=bY),
        repeat=repeat, number=number)

    obs['name'] = 'ort-bind-inplace'
    data.append(obs)






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    ort-bind-inplace




.. GENERATED FROM PYTHON SOURCE LINES 217-219

Fifth implementation is equivalent to the previous one
but does not copy anything.

.. GENERATED FROM PYTHON SOURCE LINES 219-256

.. code-block:: default


    print('ort-run-inplace')
    sess = InferenceSession(onx.SerializeToString(),
                            providers=['CPUExecutionProvider'])
    bind = SessionIOBinding(sess._sess)
    ort_device = C_OrtDevice(C_OrtDevice.cpu(), C_OrtDevice.default_memory(), 0)

    Y = sess.run(None, {'X': X})[0]
    bX = X.copy()
    bY = Y.copy()

    bind.bind_input('X', ort_device, numpy.float32, bX.shape,
                    bX.__array_interface__['data'][0])
    bind.bind_output('variable', ort_device, numpy.float32, bY.shape,
                     bY.__array_interface__['data'][0])
    ortvalues = bind.get_outputs()


    def run_with_iobinding_no_copy(sess, bX, bY, X, bind, ortvalues):
        if X.__array_interface__['strides'] is not None:
            raise RuntimeError("onnxruntime only supports contiguous arrays.")
        # bX[:, :] = X[:, :]
        sess._sess.run_with_iobinding(bind, None)
        return bY


    obs = measure_time(
        lambda: run_with_iobinding_no_copy(
            sess, bX, bY, X, bind, ortvalues),
        context=dict(run_with_iobinding_no_copy=run_with_iobinding_no_copy, X=X,
                     sess=sess, bind=bind, ortvalues=ortvalues, bX=bX, bY=bY),
        repeat=repeat, number=number)

    obs['name'] = 'ort-run-inplace'
    data.append(obs)






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    ort-run-inplace




.. GENERATED FROM PYTHON SOURCE LINES 257-259

Final
+++++

.. GENERATED FROM PYTHON SOURCE LINES 259-264

.. code-block:: default


    df = pandas.DataFrame(data)
    print(df[['name', 'average', 'number', 'repeat', 'deviation']])
    df





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

                   name   average  number  repeat  deviation
    0               skl  0.062533     250     250   0.017054
    1             numpy  0.098921     250     250   0.021386
    2           ort-run  0.037019     250     250   0.002043
    3             ort-c  0.033772     250     250   0.000150
    4            ort-ov  0.032038     250     250   0.000071
    5          ort-bind  0.046441     250     250   0.000126
    6  ort-bind-inplace  0.036102     250     250   0.000284
    7   ort-run-inplace  0.032373     250     250   0.000039


.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }

        .dataframe tbody tr th {
            vertical-align: top;
        }

        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>average</th>
          <th>deviation</th>
          <th>min_exec</th>
          <th>max_exec</th>
          <th>repeat</th>
          <th>number</th>
          <th>ttime</th>
          <th>context_size</th>
          <th>name</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>0.062533</td>
          <td>0.017054</td>
          <td>0.052082</td>
          <td>0.127703</td>
          <td>250</td>
          <td>250</td>
          <td>15.633355</td>
          <td>232</td>
          <td>skl</td>
        </tr>
        <tr>
          <th>1</th>
          <td>0.098921</td>
          <td>0.021386</td>
          <td>0.040168</td>
          <td>0.169376</td>
          <td>250</td>
          <td>250</td>
          <td>24.730248</td>
          <td>232</td>
          <td>numpy</td>
        </tr>
        <tr>
          <th>2</th>
          <td>0.037019</td>
          <td>0.002043</td>
          <td>0.036602</td>
          <td>0.060717</td>
          <td>250</td>
          <td>250</td>
          <td>9.254672</td>
          <td>232</td>
          <td>ort-run</td>
        </tr>
        <tr>
          <th>3</th>
          <td>0.033772</td>
          <td>0.000150</td>
          <td>0.033562</td>
          <td>0.035747</td>
          <td>250</td>
          <td>250</td>
          <td>8.442984</td>
          <td>232</td>
          <td>ort-c</td>
        </tr>
        <tr>
          <th>4</th>
          <td>0.032038</td>
          <td>0.000071</td>
          <td>0.031911</td>
          <td>0.032308</td>
          <td>250</td>
          <td>250</td>
          <td>8.009545</td>
          <td>232</td>
          <td>ort-ov</td>
        </tr>
        <tr>
          <th>5</th>
          <td>0.046441</td>
          <td>0.000126</td>
          <td>0.046264</td>
          <td>0.046998</td>
          <td>250</td>
          <td>250</td>
          <td>11.610148</td>
          <td>232</td>
          <td>ort-bind</td>
        </tr>
        <tr>
          <th>6</th>
          <td>0.036102</td>
          <td>0.000284</td>
          <td>0.035914</td>
          <td>0.038481</td>
          <td>250</td>
          <td>250</td>
          <td>9.025473</td>
          <td>360</td>
          <td>ort-bind-inplace</td>
        </tr>
        <tr>
          <th>7</th>
          <td>0.032373</td>
          <td>0.000039</td>
          <td>0.032274</td>
          <td>0.032611</td>
          <td>250</td>
          <td>250</td>
          <td>8.093184</td>
          <td>360</td>
          <td>ort-run-inplace</td>
        </tr>
      </tbody>
    </table>
    </div>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 265-267

Graph
+++++

.. GENERATED FROM PYTHON SOURCE LINES 267-272

.. code-block:: default


    ax = df.set_index('name')[['average']].plot.bar()
    ax.set_title("Average inference time\nThe lower the better")
    ax.tick_params(axis='x', labelrotation=15)




.. image-sg:: /gyexamples/images/sphx_glr_plot_benchmark_ort_api_001.png
   :alt: Average inference time The lower the better
   :srcset: /gyexamples/images/sphx_glr_plot_benchmark_ort_api_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 273-281

Conclusion
++++++++++

A profiling (:epkg:`onnxruntime` is compiled with debug information)
including # calls to native C++ functions shows that referencing input
by name # takes a significant time when the graph is very small such
as this one. The logic in method *run_with_iobinding* is much longer
that the one implemented in *run*.

.. GENERATED FROM PYTHON SOURCE LINES 281-284

.. code-block:: default


    # import matplotlib.pyplot as plt
    # plt.show()








.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 1 minutes  35.485 seconds)


.. _sphx_glr_download_gyexamples_plot_benchmark_ort_api.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_benchmark_ort_api.py <plot_benchmark_ort_api.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_benchmark_ort_api.ipynb <plot_benchmark_ort_api.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
